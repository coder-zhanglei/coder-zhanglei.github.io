<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2022%2F02%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[title:Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[log4cxx移植笔记]]></title>
    <url>%2F2022%2F01%2F04%2Flog4cxx%E7%A7%BB%E6%A4%8D%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[log4cxx文件的编译编译需要的三个文件：1、apache-log4cxx-0.10.0]]></content>
      <categories>
        <category>log4cxx</category>
      </categories>
      <tags>
        <tag>log4cxx的移植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 迁移]]></title>
    <url>%2F2021%2F10%2F24%2Fhexo-%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[迁移时候主要用到可参考的博客 https://www.cnblogs.com/iHeling/p/14095937.html 准备工作 先安装必备软件git, node.js, 开始迁移迁移hexo用到的相关命令1234567git config --global user.name "coder-zhanglei" #设置用户名git config --global user.email "1357028281@qq.com" #设置邮箱git config user.name #查询设置的用户名git config user.email #查询设置的邮箱## 正式部署hexo clean &amp;&amp; hexo g &amp;&amp; hexo d MARKDOWn编辑vscode安装如下插件即可实现markdown语法的编辑1、markdown all in one2、markdown Preview enhanced，将原生markdown预览的黑色背景改为白色3、markdown preview github stying，Github风格的预览 注：这三个插件是实现markdown编辑预览的基本插件，实现更多的markdown语法的功能，可探索更多相关的插件。 问题记录1、 hexo d提交时出现错误：FATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/do TypeError [ERR_INVALID_ARG_TYPE]: 解决方法：该问题是node.js版本过高，切换会旧版本即可，旧版本为：node-v12.22.9-x64.msi2、 OpenSSL SSL_read: Connection was reset, errno 10054解决方法：执行命令12git config --global http.sslVerify "false"3、 Failed to connect to github.com port 443 after 21098 ms: Timed out解决方法： 解决方法：我们直接在终端先输入设置代理的命令，再输入取消代理的命令即可解决 123git config --global https.proxygit config --global --unset https.proxy]]></content>
      <categories>
        <category>初识hexo</category>
      </categories>
      <tags>
        <tag>初识hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 迁移]]></title>
    <url>%2F2021%2F10%2F24%2Fhexo-%E6%96%87%E7%AB%A0%E7%89%B9%E6%80%A7%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[为字体添加颜色效果展示这是红色字体这是绿色字体这是黄色字体这是蓝色字体这是青色，蓝绿色字体 语法12345这是&lt;label style=&quot;color:red&quot;&gt;红色&lt;/label&gt;字体这是&lt;label style=&quot;color:green&quot;&gt;绿色&lt;/label&gt;字体这是&lt;label style=&quot;color:yellow&quot;&gt;黄色&lt;/label&gt;字体这是&lt;label style=&quot;color:blue&quot;&gt;蓝色&lt;/label&gt;字体这是&lt;label style=&quot;color:cyan&quot;&gt;青色，蓝绿色&lt;/label&gt;字体 内容块1&gt; 这里的内容显示在内容块中 删除线（中划线），需要使用“~”来包含需要删除线的文本 12~~fsadfsa~~ fsadfsa下划线，需要选中需要下划线的文本，按下“CTRL”+“U”快捷键实现。 下划线的文本 粗体+斜体，需要使用“***”，也就是三个星号，来包含需要粗体和斜体的文本 也就是三个星号 斜体，需要使用“*”，也就是一个星号，来包含需要斜体的文本 也就是一个星号]]></content>
      <categories>
        <category>初识hexo</category>
      </categories>
      <tags>
        <tag>初识hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FPGA电子系统设计方法]]></title>
    <url>%2F2019%2F12%2F31%2FFPGA%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[电子系统设计步骤 电子系统设计–&gt; 电子系统实验调试–&gt; 制作电路板–&gt;电子系统安装–&gt; 电子系统调试–&gt; 合格成品 总体方案确定 根据掌握的资料，将总体系统分为若干个子系统（硬件单元电路。软件设计的功能模块），并画出有各个子系统相互连接而形成系统原理框图。多分析，多思考，多比较，要从稳定性、工作可靠性、电路简单、成本低、功耗小、调试维修方便等方面综合考量，选出最佳方案。 1、硬件单元电路设计 为了使电子系统的体积小，可靠性高，单元电路尽可能使集成电路组成。计算单元电路参数时应注意以下几点： （1） 在计算元器件工作电流、电压和功率等参数时，应考虑工作条件最为不利的情况，并留有适当的余量。 （2） 对于原器件的极限参数必须留有足够的余量，一般取1.5~2倍的额定值 （3） 对于电阻、电容参数的取值，应选计算值附近的标称值。电阻值一般在1MΩ内选择：非电解电容一般在100pf~0.47F选择；电解电容一般在1~2000uf范围内选用。 （4）在保证电路达到功能指标要求的前提下。尽量减少元器件的品种，价格，体积等。2、软件设计 软件设计首先要完成功能模块的设计，功能模块设计好后可以反复使用。用VHDL语言编程写功能模块，用图形输入的方法将各个功能模块连接起来。3、元器件的选择 （1）一般优先选择集成电路 （2）电阻器和电容器是两种最长见的元器件 （3）分立半导体的选择4、计算机模拟仿真5、实验调试6、绘总体电路图 （1） 总体电路图尽可能画在同一张图上；注意信号的流向，一般从输入端画起，由左向右或由上至下按信号的流向依次画出各单元电路。 （2） 注意总体电路图的紧凑和协调，要求布局合理、排列均匀。 （3） 连线一般画成水平线或垂直线，尽可能的减少交叉和拐弯。 元器件布局与布线1、 按照信号流走向布局2、 优先确定特殊元器件位置3、 防止电磁干扰 （1）减小磁力线对印制导线的切割 （2）两个电感类元件的位置应当使它们的磁场方向相互垂直，减小彼此间的磁力线耦合 （3）对干扰源进行磁屏蔽，屏蔽罩应该良好接地 （4）使用高频电缆直接传输信号时，电缆的屏蔽层应该一端接地4、抑制热干扰 首先要区分发热元器件和温度敏感元器件，尽量不要把几个发热元器件放在一起，并且考虑使用散热器或小风扇等装置，使元器件的温升不超过允许值。大功率器件可以直接固定在机壳上，利用金属外壳传导散热。 印制焊盘的尺寸及形状 1、焊盘的内径（引线孔的直径） 2、焊盘的外径 3、焊盘形状 4、灵活设计焊盘]]></content>
      <categories>
        <category>FPGA学习笔记</category>
      </categories>
      <tags>
        <tag>FPGA电子系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程-第二章：系统设计]]></title>
    <url>%2F2019%2F11%2F02%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[结构化分析 结构化方法遵循的原理是自顶向下、逐步求精，使用的工具有数据流图、数据字典、判定表、判定树和结构化语言等。 1969年Bohm和jacopini首次证明了只要用三种结构（顺序，选择和循环）就能表达一个入口和出口的流程图所能表达的任何程序逻辑。 面向对象分析的基本过程 需求陈述的内容包括问题范围、功能需求、性能需求、应用环境及假设条件等。 基本模型 面向对象建模得到模型包含对象的三个要素：对象模型（静态结构）、交互次序（动态结构）和数据变换（功能模型）。大型系统的对象模型由4个层次组成：主题层、对象层、特征层（可细分为属性层、服务层）、关系层。 系统设计 结构设计的一般准则：划分模块时，尽量做到高内聚，低耦合，保持模块的相对独立性，以此为原则优化初始化的软件结构。 模块化 所有软件结构设计都是要以模块化为基础，模块由单独命名和可编程的构件集成，以满足问题的需求。模块的基本属性有： 接口：模块的输入输出口 功能：指模块实现什么功能 逻辑：描述内部如何实现要求的功能及所需的数据 状态：指模块的运行环境，即模块的调用与被调用关系在设计模块时要考虑软件的模块数目、模块接口成本和软件总成本之间的关系。模块数越多接口越多。模块的耦合耦合表示软件结构内不同模块彼此之间相互依赖的紧密程度，是衡量软件模块结构质量好坏的度量。软件设计应追求尽可能的松散合，避免强耦合。越松散，模块间的联系就越少。模块的独立性就越强。一般的耦合分为：数据、控制、公共环境、内容和标记耦合。耦合原则：尽量使用数据耦合，少使用控制耦合，限制公共耦合，完全不使用内容耦合。模块的内聚内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。简单的说，理想内聚的模块只做一件事。模块尽量使用高内聚，少用中内聚，不用低内聚。设计的优化（1） 输入部分求精（2） 输出部分求精（3） 变化部分求精详细设计描述详细设计的常用的三种工具：图形，表格和语言，以下是设计的具体方法。 结构化语言 判定表 判定树 结构化程序设计面向对象设计面向对象抽象方法分类的原则是抽象，即忽略事物的非本质特征，只注意那些与当前目标相关的本质特征，从而找出事物的特性，把具有共同性质的事物划分为一类，得到一个抽象的概念。面向对象方法支持过程抽象和数据抽象。类似一种抽象数据类型，对外提供方法，对内封装数据及实现。参数化抽象是指在类的规格说明描述时，不具体说明所要操作的数据类型，而是把数据类型作为参数。这使得类的抽象程度更高。比如c++中的“模板”机制。 面向对象的基本原理面向对象的而基本原理如下：（1） 抽象（过程，数据）（2） 封装（3） 继承（4） 消息（5） 组织方法（对象和属性、类专成员、整体与部分）（6） 功能分类（基本函数，状态-文件-响应、对象生命历程）（7） 分类结论（8） 组织结构（9） 实例连接（10） 消息连接 数据库系统模型和结构数据库模型（1） 层次模型（2） 网状模型（3） 关系模型（4） 数据独立存取模型 关系数据库的范式理论 有5中不同层次的范式：第一范式（1nf）、第二范式（2nf）、第三范式（3nf）、第四范式（4nf）、第五范式（5nf）。一个低一级范式的关系模型，通过分解方法转换为若干个高一级范式的关系模式的集合，称为规范化。 第一范式 要求元组中的每一个数据项都不能再分割，都是原子项，记作1NF。简单的说就是表中每一个元素都是单一的、不可再分的数据。 第二范式 满足第一范式，并且每个非关键字属性都完全依赖于主关键字。 第三范式 符合第二范式，所有非关键字属性之间不存在函数依赖关系。即非主关键字不能拆分为其他关键字的组合。 第四范式 符合第三范式，在关系模型中没有超过一个的多值事实。多值事实就是某个属性有若干个值，这些值由另一个属性的一个值决定。 第五范式 符合第五范式的表不能分解成两个或则多个表，且不丢失信息。 范式之间的关系 一般程度来说，规范化程度低会造成数据冗余和操作异常，但是范式程度低则检索直接，处理比较简单；范式程度高可以减少操作异常和减少数据冗余，但是规范化程度高则在检索是要访问更多的关系，即需要做更多的操作，比较复杂。]]></content>
      <categories>
        <category>软件工程学习</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab 最优化设计]]></title>
    <url>%2F2019%2F08%2F22%2Fmatlab-%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[线性规划（line programming）MATLAB 求解 lineprog()是解线性规划的命令。调用格式在软件中可查。 lsqnonlin()是解决非线性最小二乘法问题。数理统计分析对离散数据和连续数据进行分析处理，即数理统计分析。matlab中包括曲线拟合和回归分析。均值计算样本均值的函数是mean。样本方差与标准差计算样本方差的函数是var；标准差的函数为std；协方差和相关系数计算协方差的函数为cov；计算相关系数的函数为corroef；lyfit(x,y,n):表示用二乘法对已知数据x，y进行拟合，以求得n阶多项式系数向量。[p,s] = polyfit(x,y,n) p为拟合多项式系数向量，s为拟合多项式系数向量的信息结构。函数线性组合g(x) = c1 + c2e^-2x + c3cos(-2x)e^-4x + c4x^2;求出待定系数。实验数据| x | 0 | 0.2 | 0.4 | 0.7 | 0.9 | 0.92 || y | 2.88 | 2.2576 | 1.9638 | 1.9258 | 2.0862 | 2.109 |解：（1） 编写M文件123456function yy = linefit2(x,y,A)n = length(x);y = reshape(y,n,1);A = A';yy = A\y;yy = yy'; (2) 变量量矩阵12x = [0 0.2 0.4 0.7 0.9 0.92];y = [2.88 2.2576 1.9638 1.9258 2.0862 2.109]; (3) 输入表达式1A = [ones(size(x)); exp(-2*x);cos(-2*x).*exp(-4*x);x.^2]; (4) 调用linefit2函数1yy = linefit2(x,y,A); (5) 绘制图形12345plot(x,y1);x = [0:0.01:0.92]';A1 = [ones(size(x)); exp(-2*x);cos(-2*x).*exp(-4*x);x.^2];y1 = A1 * yy';plot(x,y1); 最小二乘法曲线拟合 MATLAB提供了polyfit函数命令进行最小二乘法的曲线拟合。 p = ployfit(x,y,n) 对向量x和y进行n维多项式的最小二乘拟合，输出结果P为含有n+1个元素的行向量，该向量以维数递减的形式给出多项式的系数。n为次数。 回归分析 变量之间的关系可以分为两种：确定性的函数关系和不确定性统计关系。统计分析是研究统计关系的一种数学方法，可以由一个变量的值去估计另一个变量的值。 一元线性回归 如果在总体中，因变量与自变量的统计关系符合一元线性的正态误差模型，即对给定的Xi有Yi=b0+b1xi+ε。 matlab提供的一元线性回归函数为polyfit，因为一元线性回归其实就是一阶多项式拟合。 多元线性回归 对于因变量y的全面解释往往需要多个自变量的共同作用。当有p个自变量x1,x2,…..xp时，多元线性回归的理论模型为： y = β0+β1x1+….+βxp+ε; 其中，ε是随机误差，E(ε) = 0； matlab提供了regress函数进行多元线性回归，。]]></content>
      <categories>
        <category>matlab学习</category>
      </categories>
      <tags>
        <tag>matlab基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab 图形绘制]]></title>
    <url>%2F2019%2F08%2F07%2Fmatlab-%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[二维曲线的绘制相关的绘图命令1、 figure figure：创建一个图形窗口。 figure(n)：n是正整数，创建一个编号为n的图形窗口 figure(‘PropertyName’,’PropertyValue’,…):对指定的属性PropertyName，用指定的属性值PropertyValue创建一个新的图形窗口。2、 plot plot(x) plot(x,y) plot(x1,y1,x2,y2) plot(x,y,s)其中x，y为向量或矩阵，s为用单引号标记的字符串，用来设置所画数据点的类型、大小、颜色以及数据点之间的连线的类型、粗细、颜色等。实际应用中，s是某些字母或符号的组合。 plot(x1,y1,s1,x2,y2,s2……)3、 多图形显示(1)、 图形分割 subplot(m,n,p)将当前窗口分割为m×n个视图区域，并指定地p个视图为当前视图。 subplot(‘position’,[left bottom width height]):产生的新子区域的位置由用户指定，后面的四元组为区域的具体参数控制，宽高的取值范围都是[0,9] 图形的叠加图形保持命令hold on/off控制原有图形的保持与不保持 一元函数的绘制fplot plot命令是依据给定的数据点来做图的，在实际情况中，一般不清楚函数具体情况，因此依据所选取的数据点作图可能会忽略真实函数的某些特性。 fplot命令用于指导数据点的选取，通过其内部自适应算法，在函数变化比较平稳处，它所区的值相对稀疏些，在函数变化明显处取的数据点自动密一些。 图形注释 title(‘string’),title(fname) h = title(….) xlable(‘string’)在当前轴对象中的x轴标注说明语句string ylabel(‘’)在当前轴对象中的y轴标注说明语句string text(x,y,’string’)在图形中指定的位置（x,y）上显示字符串string gtext（‘string’,’property’,’propertyvalue’）可以让鼠标在图形的任意位置进行标注。图例标注当在一幅图中出现多种曲线时，用户可以根据自己的需要，利用legend命令对不同的图例进行说明。 编译.m文件 在命令窗口中输入1mcc -m test.m 动画演示1、 利用moviein命令对内存进行初始化，创建一个足够大的矩阵，使其能够容纳基于当前坐标轴大小的一系列指定的图形（帧）；moviein(n)可以创建一个足够大的n列矩阵。2、 利用getframe命令生成每个帧。3、 利用movie命令按照指定的速度和次数运行该动画，movie(M,n)可以播放由矩阵M所定义的画面n次默认n时，播放一次。12345678910111213[X,Y,Z] = peaks(30);surf(X,Y,Z)axis([-3,3,-3,3,-10,10])axis offshading interpcolormap(hot)M = moviein(20);%建立一个20列的大矩阵for i= 1:20 view(-37.5+24*(i-1),30)%改变视点 M(:,i) = getframe; %将图像保存到M矩阵中endmovie(M,2)%画面播放两次]]></content>
      <categories>
        <category>matlab学习</category>
      </categories>
      <tags>
        <tag>matlab基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab 程序设计基础]]></title>
    <url>%2F2019%2F08%2F03%2Fmatlab-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[程序结构 程序设计语言，程序结构大致可分为顺序结构，循环结构，与分支结构三类。 程序流程控制指令1、 中断命令break2、 return命令3、 等待用户反应命令pause pause指令是暂停指令。程序运行时，到pause指令执行后，程序将暂停，等待用户按任意键后而继续执行。 pause 暂停程序等待回应 pause(n) 程序运行过程中，等待n秒后继续运行 pause on 显示其后的pause指令，并执行pause指令 pause off 显示其后的pause指令，但不执行该指令人机交互语句1、 input命令v= input(‘string’) %以文本字符串string为信息给出用户提示信息，将用户输入的内容赋值给变量vv = input(‘string’,’s’) % 以文本字符串string为信息给出用户提示信息，将用户输入的内容作为字符串赋值给变量v2、 keyboard命令 是调用键盘命令。当用户输入return并按enter键后，控制权交还给M文件。3、 menu命令生成一个菜单供用户选择输入k = menu(‘mtitle’,’opt1’,’opt2’,…..,’optn’)子函数与私有函数子函数 在函数文件中定义的函数作为主函数，而在函数体内定义的其他函数均被视作子函数。子函数只能为主函数或同一主函数下其他的子函数所调用。私有函数 MATLAB语言中把放置在目录private下的函数称为私有函数，这些函数只有private目录的父目录中的函数才能调用，其他目录的函数不能调用 子函数与私有函数的区别1、 私有函数在可用的范围上大于子函数2、 在函数编辑上的结构上，私有函数与一般的函数文件的编辑相同，而子函数则只能在主函数文件中编辑。3、 当在MATLAB的M文件中调用函数时，首先检测该函数是否为此文件加下的子函数，若否，则检测是否为可用的私有函数，任然否，检测该函数是否为MATLAB搜索路径上的其他M文件。 程序设计的优化 虽然在MATLAB语言中没有规定使用变量是必须先定义，但是对于未定义的变量，如果操作系统出现越界赋值时，系统将不得不对变量进行扩充，这样大大降低了程序的运行效率，对于可能出现变量的维度不断扩大的情况下，应当预先估计变量可能出现的最大维度，进行预定义。]]></content>
      <categories>
        <category>matlab学习</category>
      </categories>
      <tags>
        <tag>matlab基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab基础知识]]></title>
    <url>%2F2019%2F07%2F30%2Fmatlab%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[matlab基本命令1、 path命令 在matlab的命令行中输入可以得到matlab的所有搜索路径。使用path扩展搜索目录：path(path,’D:\matlab’)2、 genpath命令 在命令行中输入可以得到，有MATLAB所有的搜索路径连接而成的一个长字符串。3、 使addpath命令扩展目录 addpathD:\matlab -begin 将matlab添加到整个搜索路径的开始 addpathD:\matlab -end 将matlab添加到整个搜索路径的末尾。 MATLAB帮助系统1、 帮助命令 help、help+函数名（类）、helpwin和helpdesk，其中后两个是用来调用MATLAB联机帮助窗口。2、 lookfor函数 当用户不知道某个函数的确切名称，可以用lookfor函数，根据关键字搜索。3、 其他的帮助命令 who：内存变量列表 whos：内存变量的详细信息 what：目录中的文件列表 which：确定文件位置 exist：变量检验函数常用指令1、 cd：显示或者改变工作目录2、 clc：清除工作窗3、 clear：清除内存变量续行符 “…”用3个或3个以上的连续黑点表示“续行” 数据类型 主要的数据类型：数字，字符串，向量，矩阵，单元型数据及结构型数据 变量与常量 在未加特殊说明的情况下，matlab语言将所识别的一切变量视为局部变量，仅在其使用的M文件内有效。如果要将其定义为全局变量加关键字global。 数字的显示格式 在默认的状态下，数据为整型，以整数表示，数据为实数，保留小数后4位的精度近式值。 format控制数字显示格式 format long,pi ;15位定点表示 基本格式：format后加变量的类型用逗号隔开，加要输出的变量。 字符串 所有的字符串都用单引号设定后输入或赋值；字符串相关函数以str开头。 向量 冒号法创建向量：x = first：increment：last；向量就相当于一维数组。 对数分隔的向量，x = logspace（first_value,last_value,number） 矩阵矩阵的创建 eye函数；创建单位矩阵；eye（size(A)） 创建和A相同的单位矩阵 rand函数，创建随机矩阵 compan(P) 创建系数向量是P的多项式伴随矩阵 diag(v) 创建一向量v中的元素为对角的对角阵 hilb(n) 创建nxn的Hilbert矩阵 zeros ones 矩阵元素的修改 A(m,:) = [] ;删除A的第m行 A(:,n) = [] ;删除A的第n列 A(m,n) = a; 对m行n列的元素赋值 单元型变量 单元型变量是以单元为元素的数组，每个元素称为单元，每个单元可以包含其他类型的数组，如实数矩阵、字符串，复数向量。单元变量通常用{}创建，其数据通过数组下标来引用。A={}； 结构型变量 结构型变量是根据属性名（field）组织起来的不同数据类型的集合。结构的任何一个属性可以包含不同的数据类型，如字符串，矩阵等。结构型变量用函数struct来创建。s = struct(‘field’,{},’field2’,{},…) ;s = struct(‘field’,values1,’field2,values2’) 运算符 .* 点乘 .^ 点乘方 ./ 、 .\ 点右除，点左除 ‘ 矩阵转置。当矩阵是复数时，求矩阵的共轭转置 .’ 矩阵转置。当矩阵是复数时，不求矩阵的共轭转置注解：点运算是指元素点对点的运算，即矩阵内元素对元素之间的运算。点运算要求参与运算的变量在结构上必须是相似的。 ~= 不等于]]></content>
      <categories>
        <category>matlab学习</category>
      </categories>
      <tags>
        <tag>matlab基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stm32 uip心得]]></title>
    <url>%2F2019%2F06%2F25%2Fstm32-uip%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[uip时钟 uIP-APP文件夹下的clock-arch.c文件是记录数据收发的时钟，即协议的系统心跳，系统心跳是用stm32中的定时器进行定时。改变定时的时间即可改变数据的收发速度。 123456789101112131415161718192021222324//clock-arch.c文件extern u32 uip_timer;//uip 计时器，每10ms增加1./*---------------------------------------------------------------------------*/clock_time_tclock_time(void)&#123; return uip_timer; /* 10ms 单位 */ &#125;//定时器文件下的定时中断//定时器6中断服务程序 void TIM6_IRQHandler(void)&#123; #if SYSTEM_SUPPORT_OS OSIntEnter();#endif if (TIM_GetITStatus(TIM6, TIM_IT_Update) != RESET) //检查指定的TIM中断发生与否:TIM 中断源 &#123; uip_timer++;//uip计时器增加1 &#125; TIM_ClearITPendingBit(TIM6, TIM_IT_Update); //清除TIMx的中断待处理位:TIM 中断源 #if SYSTEM_SUPPORT_OS OSIntExit();#endif &#125; 服务器初始化1、 初始化硬件参数2、 初始化uip协议3、 绑定本机ip地址4、 绑定网关5、 设置网络掩码6、 监听网路端口12345678910111213141516 uip_ipaddr_t ipaddr; //定义uipIP地址变量 //初始化硬件芯片-----ENC28J60 while(tapdev_init()) //初始化ENC28J60错误&#123; delay_ms(200); &#125;; //初始化uip协议 uip_init(); //uIP初始化 AnalyzeIpAddress(); //解析IP地址 uip_ipaddr(ipaddr, UIP_DRIPADDR0,UIP_DRIPADDR1,UIP_DRIPADDR2,UIP_DRIPADDR3); //设置本地设置IP地址uip_sethostaddr(ipaddr); uip_ipaddr(ipaddr, UIP_DRIPADDR0,UIP_DRIPADDR1,UIP_DRIPADDR2,UIP_DRIPADDR2); //设置网关IP地址(其实就是你路由器的IP地址)uip_setdraddr(ipaddr); uip_ipaddr(ipaddr, 255,255,255,0); //设置网络掩码uip_setnetmask(ipaddr); uip_listen(HTONS(1200)); //监听1200端口,用于TCP Server 网络事件处理 uip_input(); IP包处理，该函数是和应用层结合的关键函数，该函数本质上是调用底层uip_process(UIP_DATA)函数，uip_process函数回调应用层的函数void tcp_server_demo_appcall(void)，同理，事件轮询函数，即对每个client的事件的轮询函数uip_udp_periodic，都是调用uip_process，然后掉应应用层的回调函数，对每个client事件进行轮询。作为服务器可将数据发送到每个客户端。在应用层里可以解析收到的数据和发送数据。(struct tcp_demo_appstate *)&amp;uip_conn-&gt;appstate; 该变量是存储需要发送的数据长度和数据内容。 底层存储发送数据用的是uip_conn结构体，该结构体类有对应的ip和相应的应用层的数据接口，收到和发送的数据都存储在uip_buf中，数据的长度存储在uip_len中。应用层所有的操作都是对底层变量uip_buf,和uip_len进行赋值。发送数据都先调用uip_arp_out()函数;加以太网头结构，然后调用硬件网格芯片接口函数tapdev_send();发送数据到以太网。在此之前已经在应用层回调函数中对发送的数据进行赋值，即对uip_buf,和uip_len 进行了赋值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//应用层发送函数void tcp_server_senddata(void)&#123; struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&amp;uip_conn-&gt;appstate; //s-&gt;textptr : 发送的数据包缓冲区指针 //s-&gt;textlen ：数据包的大小（单位字节） if(s-&gt;textlen&gt;0)uip_send(s-&gt;textptr, s-&gt;textlen);//发送TCP数据包 &#125;//底层发送函数，对底层uip_buf变量进行赋值，对uip_len进行赋值void uip_send(const void *data, int len)&#123; if(len &gt; 0) &#123; uip_slen = len; if(data != uip_sappdata) &#123; memcpy(uip_sappdata, (data), uip_slen); &#125; &#125;&#125;//真正的发送函数tapdev_send();//发送数据到以太网，该数是对网络芯片的操作。//应用层的回调函数void tcp_server_demo_appcall(void)&#123; struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&amp;uip_conn-&gt;appstate; if(uip_aborted())tcp_server_aborted(); //连接终止 if(uip_timedout())tcp_server_timedout(); //连接超时 if(uip_closed())tcp_server_closed(); //连接关闭 if(uip_connected())tcp_server_connected(); //连接成功 if(uip_acked())tcp_server_acked(); //发送的数据成功送达 //接收到一个新的TCP数据包 if (uip_newdata())//收到客户端发过来的数据 &#123; if(uip_len&gt;199) &#123; ((u8*)uip_appdata)[199]=0; &#125; strcpy((char*)tcp_server_receive,uip_appdata); tcp_server_sta|=1&lt;&lt;6;//表示收到客户端数据 //反馈信息可在这儿赋值 &#125; else if(tcp_server_sta&amp;(1&lt;&lt;5))//有数据需要发送 &#123; if(sendFlag &lt; clientFlag) &#123; s-&gt;textptr=tcp_server_sendCache; s-&gt;textlen=strlen((const char*)tcp_server_sendCache); sendFlag++; &#125; else &#123; sendFlag = 0; tcp_server_sta&amp;=~(1&lt;&lt;5);//清除标记 &#125; &#125; //当需要重发、新数据到达、数据包送达、连接建立时，通知uip发送数据 if(uip_rexmit()||uip_newdata()||uip_acked()||uip_connected()||uip_poll()) &#123; tcp_server_senddata(); &#125;&#125;//网络事件处理函数//uip事件处理函数//必须将该函数插入用户主循环,循环调用.void uip_polling(void)&#123; u8 i; static struct timer periodic_timer, arp_timer; static u8 timer_ok=0; if(timer_ok==0)//仅初始化一次 &#123; timer_ok = 1; timer_set(&amp;periodic_timer,CLOCK_SECOND/2); //创建1个0.5秒的定时器 timer_set(&amp;arp_timer,CLOCK_SECOND*10); //创建1个10秒的定时器 &#125; uip_len=tapdev_read(); //从网络设备读取一个IP包,得到数据长度.uip_len在uip.c中定义 if(uip_len&gt;0) //有数据 &#123; //处理IP数据包(只有校验通过的IP包才会被接收) if(BUF-&gt;type == htons(UIP_ETHTYPE_IP))//是否是IP包? &#123; uip_arp_ipin(); //去除以太网头结构，更新ARP表 uip_input(); //IP包处理 //当上面的函数执行后，如果需要发送数据，则全局变量 uip_len &gt; 0 //需要发送的数据在uip_buf, 长度是uip_len (这是2个全局变量) if(uip_len&gt;0)//需要回应数据 &#123; uip_arp_out();//加以太网头结构，在主动连接时可能要构造ARP请求 tapdev_send();//发送数据到以太网 &#125; &#125; else if (BUF-&gt;type==htons(UIP_ETHTYPE_ARP))//处理arp报文,是否是ARP请求包? &#123; uip_arp_arpin(); //当上面的函数执行后，如果需要发送数据，则全局变量uip_len&gt;0 //需要发送的数据在uip_buf, 长度是uip_len(这是2个全局变量) if(uip_len&gt;0)tapdev_send();//需要发送数据,则通过tapdev_send发送 &#125; &#125; else if(timer_expired(&amp;periodic_timer)) //0.5秒定时器超时 &#123; timer_reset(&amp;periodic_timer); //复位0.5秒定时器 //轮流处理每个TCP连接, UIP_CONNS缺省是40个 for(i=0;i&lt;UIP_CONNS;i++) &#123; uip_periodic(i); //处理TCP通信事件 //当上面的函数执行后，如果需要发送数据，则全局变量uip_len&gt;0 //需要发送的数据在uip_buf, 长度是uip_len (这是2个全局变量) if(uip_len&gt;0) &#123; uip_arp_out();//加以太网头结构，在主动连接时可能要构造ARP请求 tapdev_send();//发送数据到以太网 &#125; &#125;#if UIP_UDP //UIP_UDP //轮流处理每个UDP连接, UIP_UDP_CONNS缺省是10个 for(i=0;i&lt;UIP_UDP_CONNS;i++) &#123; uip_udp_periodic(i); //处理UDP通信事件 //当上面的函数执行后，如果需要发送数据，则全局变量uip_len&gt;0 //需要发送的数据在uip_buf, 长度是uip_len (这是2个全局变量) if(uip_len &gt; 0) &#123; uip_arp_out();//加以太网头结构，在主动连接时可能要构造ARP请求 tapdev_send();//发送数据到以太网 &#125; &#125;#endif //每隔10秒调用1次ARP定时器函数 用于定期ARP处理,ARP表10秒更新一次，旧的条目会被抛弃 if(timer_expired(&amp;arp_timer)) &#123; timer_reset(&amp;arp_timer); uip_arp_timer(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>嵌入式网络通信</category>
      </categories>
      <tags>
        <tag>stm32 上uip移植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plotly与机器学习]]></title>
    <url>%2F2019%2F06%2F03%2FPlotly%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[分类问题用SVM对经典的IRIS数据集（鸢尾花）进行分类12345678910111213141516171819202122232425262728293031323334353637383940414243# 3.1 SVMimport plotly as pyimport plotly.graph_objs as goimport numpy as npimport matplotlib.pyplot as pltfrom sklearn import svm, datasetspyplt = py.offline.plotiris = datasets.load_iris()X = iris.data[:, :2] # 只去前两个特征Y = iris.target # 分类标签h = .02 # 设定网格大小clf = svm.SVC(kernel='linear')clf.fit(X, Y)x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1x_ = np.arange(x_min, x_max, h)y_ = np.arange(y_min, y_max, h)xx, yy = np.meshgrid(x_, y_)Z = clf.predict(np.c_[xx.ravel(), yy.ravel()]) # xx.ravel() 返回连续扁平的数组# Put the result into a color plotZ = Z.reshape(xx.shape)cmap = [[1.0,'RGB(10,64,159)'],[0.5,'RGB(5,159,126)'],[1.0,'RGB(159,26,64)']]# 画布trace1 = go.Heatmap(x=x_, y=y_, z=Z, colorscale=cmap, showscale=False)# 画点trace2 = go.Scatter(x=X[:, 0], y=X[:, 1], mode='markers', marker=dict(color=Y, colorscale=cmap, showscale=False, line=dict(color='black', width=1)))layout = go.Layout(title="3-Class classification using Support Vector Machine with linear kernel")fig = go.Figure(data= [trace1, trace2], layout=layout)pyplt(fig, filename = r'tmp\SVM_clustering.html') 绘制热力图时，用到了Plotly.graph_objs中的Heatmap函数，函数中的x，y，z三个参数分别对应X轴坐标，Y坐标，以及X轴线与Y轴线相交所得的每个小方块的颜色。如果传递给x参数的大小是a，传递给y参数的大小是b，则传递给z参数的大小为a*b的矩阵。 回归问题 本案例使用三种模型（RBF、Linear、Plotlynomial）进行回归实践，并可视化结果，数据使用NumPy随机生成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 # 3.2 SVRimport plotly as pyimport plotly.graph_objs as goimport numpy as npfrom sklearn.svm import SVRpyplt = py.offline.plotX = np.sort(5 * np.random.rand(40, 1), axis=0)y = np.sin(X).ravel()y[::5] += 3 * (0.5 - np.random.rand(8))svr_rbf = SVR(kernel='rbf', C=1e3, gamma=0.1)svr_lin = SVR(kernel='linear', C=1e3)svr_poly = SVR(kernel='poly', C=1e3, degree=2)y_rbf = svr_rbf.fit(X, y).predict(X)y_lin = svr_lin.fit(X, y).predict(X)y_poly = svr_poly.fit(X, y).predict(X)def data_to_plotly(x): k = [] for i in range(0, len(x)): k.append(x[i][0]) return klw = 2p1 = go.Scatter(x=data_to_plotly(X), y=y, mode='markers', marker=dict(color='darkorange'), name='data')p2 = go.Scatter(x=data_to_plotly(X), y=y_rbf, mode='lines', line=dict(color='navy', width=lw), name='RBF model')p3 = go.Scatter(x=data_to_plotly(X), y=y_lin, mode='lines', line=dict(color='cyan', width=lw), name='Linear model')p4 = go.Scatter(x=data_to_plotly(X), y=y_poly, mode='lines', line=dict(color='cornflowerblue', width=lw), name='Polynomial model')layout = go.Layout(title='Support Vector Regression', hovermode='closest', xaxis=dict(title='data'), yaxis=dict(title='target'))fig = go.Figure(data=[p1, p2, p3, p4], layout=layout)pyplt(fig, filename = r'tmp\SVR.html') 聚类问题 聚类结果可视化一般分为两部分，一个是画出聚类中心点，另一个是将同类别的数据绘制为同一种颜色。这里仍然使用Scatter函数完成。案列分为三部分，第一部分产生聚类数据，第二部分是使用K-means算法与MiniBatchKmeans算法训练模型；第三部分是绘制三张图片。第一张是K-means分类的结果；第二张是MiniBatchKmeans分类的结果，第三张是突出两种分类结果的差异。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import plotly as pyimport plotly.graph_objs as gofrom plotly import toolsimport timeimport numpy as npfrom sklearn.cluster import MiniBatchKMeans, KMeansfrom sklearn.metrics.pairwise import pairwise_distances_argminfrom sklearn.datasets.samples_generator import make_blobs# 产生随机数据np.random.seed(0)batch_size = 45centers = [[1, 1], [-1, -1], [1, -1]]n_clusters = len(centers)X, labels_true = make_blobs(n_samples = 3000, centers = centers, cluster_std = 0.7)# n_samples是待生成的样本的总数# centers表示类别数# cluster_std表示每个类别的方差，例如我们希望生成2类数据，其中一类比另一类具有更大的方差，可以将cluster_std设置为[1.0,3.0]。# 使用K-means算法k_means = KMeans(init = 'k-means++', n_clusters = 3, n_init = 10)t0 = time.time()k_means.fit(X)t_batch = time.time() - t0# 使用MiniBatchKMeans算法mbk = MiniBatchKMeans(init = 'k-means++', n_clusters = 3, batch_size = batch_size, n_init = 10, max_no_improvement = 10, verbose = 0)t0 = time.time()mbk.fit(X)t_mini_batch = time.time() - t0pyplt = py.offline.plotcolors = ['#4EACC5', '#FF9C34', '#4E9A06']# We want to have the same colors for the same cluster from the# MiniBatchKMeans and the KMeans algorithm. Let's pair the cluster centers per# closest one.k_means_cluster_centers = np.sort(k_means.cluster_centers_, axis=0)mbk_means_cluster_centers = np.sort(mbk.cluster_centers_, axis=0)# Compute minimum distances between one point and a set of pointsk_means_labels = pairwise_distances_argmin(X, k_means_cluster_centers)mbk_means_labels = pairwise_distances_argmin(X, mbk_means_cluster_centers)order = pairwise_distances_argmin(k_means_cluster_centers, mbk_means_cluster_centers)#第一张图fig = tools.make_subplots(rows=1, cols=3, print_grid=False, subplot_titles=('KMeans&lt;br&gt;train time: %.2fs\ninertia: %f' % (t_mini_batch, mbk.inertia_), 'MiniBatchKmeans&lt;br&gt;train time: %.2fs\ninertia: %f' % (t_mini_batch, mbk.inertia_), 'Difference'))# k-meansfor k, col in zip(range(n_clusters), colors): my_members = k_means_labels == k cluster_center = k_means_cluster_centers[k] kmeans1 = go.Scatter(x=X[my_members, 0], y=X[my_members, 1], showlegend=False, mode='markers', marker=dict(color=col, size=4)) kmeans2 = go.Scatter(x=[cluster_center[0]], y=[cluster_center[1]], showlegend=False, mode='markers', marker=dict(color=col, size=14, line=dict(color='black', width=1))) fig.append_trace(kmeans1, 1, 1) fig.append_trace(kmeans2, 1, 1) fig['layout']['xaxis1'].update(showticklabels=False, ticks='', zeroline=False, showgrid=False)fig['layout']['yaxis1'].update(showticklabels=False, ticks='', zeroline=False, showgrid=False)# minibatchkmeans 第二张图for k, col in zip(range(n_clusters), colors): my_members = mbk_means_labels == order[k] cluster_center = mbk_means_cluster_centers[order[k]] minibatchkmeans1 = go.Scatter(x=X[my_members, 0], y=X[my_members, 1], showlegend=False, mode='markers', marker=dict(color=col, size=4)) minibatchkmeans2 = go.Scatter(x=[cluster_center[0]], y=[cluster_center[1]], showlegend=False, mode='markers', marker=dict(color=col, size=14, line=dict(color='black', width=1))) fig.append_trace(minibatchkmeans1, 1, 2) fig.append_trace(minibatchkmeans2, 1, 2)fig['layout']['xaxis2'].update(showticklabels=False, ticks='', zeroline=False, showgrid=False)fig['layout']['yaxis2'].update(showticklabels=False, ticks='', zeroline=False, showgrid=False)# Initialise the different array to all False第三张图different = (mbk_means_labels == 4)for k in range(n_clusters): different += ((k_means_labels == k) != (mbk_means_labels == order[k]))identic = np.logical_not(different)difference1 = go.Scatter(x=X[identic, 0], y=X[identic, 1], showlegend=False, mode='markers', marker=dict(color='#bbbbbb', size=4)) difference2 = go.Scatter(x=X[different, 0], y=X[different, 1], showlegend=False, mode='markers', marker=dict(color='magenta', size=4))fig.append_trace(difference1, 1, 3)fig.append_trace(difference2, 1, 3)fig['layout']['xaxis3'].update(showticklabels=False, ticks='', zeroline=False, showgrid=False)fig['layout']['yaxis3'].update(showticklabels=False, ticks='', zeroline=False, showgrid=False)pyplt(fig, filename = r'tmp\K-means.html')]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Plotly分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plotly与GUI开发]]></title>
    <url>%2F2019%2F06%2F03%2FPlotly%E4%B8%8EGUI%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[各种Python GUI编程的实现TKinter Tkinter 是绑定了Python的Tk GUI框架，就是Python包装的Tcl代码，通过内嵌在Python的Tcl解释器实现。 wxPython wxPython是Python对跨平台的GUI框架wxWidgets的包装，作为一个Python的一个扩展模块来实现。 PyGTK PyGTK是Python对GTK+GUI库的一系列包装。 PySide PySide是Qt官方维护 PyQt的安装12pip install PyQt5 -i https://pypi.tuna.tsinghua.edu.cn/simplepip install PyQt5==10.1.1]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>python GUI开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[plotly网页开发01]]></title>
    <url>%2F2019%2F06%2F03%2Fplotly%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%9101%2F</url>
    <content type="text"><![CDATA[plotly在Django中的应用 Django是用Python语言开发的一个免费开源的web框架，用于快速搭建高性能、优雅的网站，通过Django可以建立一个高性能web应用花费的时间和精力少。 安装环境搭建安装命令 1pip install django 测试：123456789#测试命令django-admin startproject plotly_and_django#执行命令后plotly_and_django/ manage.py plotly_and_django/ settings.py urls.py wsgi.py 这些文件的具体含义如下：(1)、 manage.py:这是项目交互的命令行实用程序，是django-admi.py工具周围的包装，不需要编辑此文件(2)、 plotly_and_django/：用户的项目文件夹，包含以下文件 init.py :一个空的文件，用来告诉Python把这个文件当作Python的包对待 settings.py: 用于调整项目的设置和参数 urls.py : 用来存储项目中的URL，Django会通过正则表达式来匹配URL wsgi.py: 里面包含了通过WSGI方式运行Django项目的一系列参数 测试服务器：1python manage.py runserver]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib简介02]]></title>
    <url>%2F2019%2F06%2F02%2FMatplotlib%E7%AE%80%E4%BB%8B02%2F</url>
    <content type="text"><![CDATA[确定坐标范围 在matplotlib中，使用xlim(x,y)和ylim(x,y)函数可以确定坐标范围：1234567891011121314151617181920212223242526from pylab import *import numpy as np#使用import导入模块numpyimport matplotlib.pyplot as plt#使用import导入模块matplotlib.pyplotimport plotly as py # 导入plotly库并命名为py# -------------pre defpympl = py.offline.plot_mpl# 配置中文显示plt.rcParams['font.family'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号x = np.arange(-5.0, 5.0, 0.02)# x = np.linspace(-5, 5, num=50, endpoint=True, retstep=False, dtype=None)y1 = x**2+1plt.figure(1)plt.subplot(211)xlabel('x 值')ylabel('y1 值')#设置x轴范围，x轴只显示（-5,3），总区间（-5,5)xlim(-5, 3)#设置y轴范围ylim(-10, 50)plt.plot(x,y1)fig= plt.gcf()plot_url = pympl(fig,filename=r'tmp/axis_limit.html', show_link=False,resize=True) 散点图 散点图时指在回归分析中，数据点在指教坐标系平面上的分布图。散点图表示因变量随自变量变化的大致趋势，因此可以选择合适的函数对数据点进行拟合。散点图通常用于跨类别的聚合数据。 12345678910111213141516171819202122232425import numpy as np#使用import导入模块numpyimport matplotlib.pyplot as plt#使用import导入模块matplotlib.pyplotimport plotly as py # 导入plotly库并命名为py# -------------pre defpympl = py.offline.plot_mpl# 配置中文显示plt.rcParams['font.family'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号fig, ax = plt.subplots()#产生测试数据x = np.arange(1,30)y =np.sin(x)ax1 = fig.add_subplot(111)#设置标题ax1.set_title('散点图')#设置X轴标签plt.xlabel('X')#设置Y轴标签plt.ylabel('Y')#画散点图lValue = xax1.scatter(x,y,c='r',s= 100,linewidths=lValue,marker='o')#设置图标plt.legend('x1')plot_url = pympl(fig,filename=r'tmp/scatter_1.html', show_link=False,resize=True) 散点图2：123456789101112131415161718192021from numpy.random import rand#使用import导入模块numpyimport matplotlib.pyplot as plt#使用import导入模块matplotlib.pyplotimport plotly as py # 导入plotly库并命名为py# -------------pre defpympl = py.offline.plot_mpl# 配置中文显示plt.rcParams['font.family'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号fig, ax = plt.subplots()for color in ['red', 'green', 'blue']: n = 500 x, y = rand(2, n)#产生2*n的矩阵 ax.scatter(x, y, c=color, label=color, alpha=0.3, edgecolors='none')#设置每个点的颜色，x,y分别代表的横纵坐标，通过横纵坐标确定点的位置，c表示点的颜色color，s表示点的大小size，alpha表示点的透明度，1是不透明，0是透明。ax.legend()ax.grid(True)#设置网格plot_url = pympl(fig,filename=r'tmp/scatter_2.html', show_link=False,resize=True) scatter函数中比较常用的参数如系： x，y:形如shape(n,)的数组，可选值 s:点的大小（也就是面积），默认值为20 c：点的颜色或颜色序列，默认为蓝色，其他如c = ‘r’(red),c== g‘green’ marker:形状，可选值，默认是圆 柱状图123456789101112131415161718192021222324252627import numpy as np#使用import导入模块numpyimport matplotlib.pyplot as plt#使用import导入模块matplotlib.pyplotimport plotly as py # 导入plotly库并命名为py# -------------pre defpympl = py.offline.plot_mpl# 配置中文显示plt.rcParams['font.family'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号plt.figure(figsize=(7,5))X = np.arange(1,6)#X是1,2,3,4,5,6,7,8,柱的个数# numpy.random.uniform(low=0.0, high=1.0, size=None), normal#uniform均匀分布的随机数，normal是正态分布的随机数，0.5-1均匀分布的数，一共有n个Y1 = np.random.uniform(0.5,1.0,5)Y2 = np.random.uniform(0.5,1.0,5)plt.bar(X,Y1,width = 0.35,facecolor = 'lightskyblue',edgecolor = 'white')#width:柱的宽度plt.bar(X+0.35,Y2,width = 0.20,facecolor = 'yellowgreen',edgecolor = 'white')#水平柱状图plt.barh，属性中宽度width变成了高度height#打两组数据时用+#facecolor柱状图里填充的颜色#edgecolor是边框的颜色#想把一组数据打到下边，在数据前使用负号fig = plt.gcf()plot_url = pympl(fig,filename=r'tmp/bar_1.html', show_link=False,resize=True) bar函数的使用方法是：bar(left,height,width,bottom=None,**kwargs) left,height,width,bottom这四个参数确定了柱体的位置和大小。默认情况下，left为柱体的居中位置（可以通过align参数改变left值的含义），即： （left-width/2,bottom）为左下角位置 （left-width/2,bottom+height）为右上角位置 更多扩展网址：https://plot.ly.matplotlib/ ,获取Matplotlib与plotly结合的所有官方案例。]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib简介01]]></title>
    <url>%2F2019%2F06%2F02%2FMatplotlib%E7%AE%80%E4%BB%8B01%2F</url>
    <content type="text"><![CDATA[安装Matplotlib1pip install matplotlib 调整Matplotlib参数使用参数字典123import matplotlib as plt#导入模块包print （plt.rc_params()）#打印所有的参数 在以上的参数中，常用的参数解释如下; axes：设置坐标轴边界，颜色，坐标刻度值大小和网络的显示 figure：设置边界颜色，图形大小和子区 font：设置字体，字号和样式 grid：设置网络颜色和线型 legend：设置图例和其中的文本显示 lines: 设置线条（颜色，线型，宽度等）和标记 savefig：对保存的图形进行单独设置 xtick和ytick：为X,Y轴的主刻度和次刻度设置颜色，大小，方向和标签大小下面调用Matplotlib.rc()命令，通过传入关键字修改参数，12345import matplotlib as pltimport pylabpylab.plot([1,2,3,4,5,6,7,8,9,10])plt.rc("lines", marker= 'x',linewidth=12, color= 'red')pylab.show() 修改配置文件 可以使用matplot.matplotlib_fname()命令查找当前用户的配置文件目录，从而修改Matplotlib的文件参数，代码如下12import matplotlib as pltprint (plt.matplotlib_fname()) 常用的API功能 figure():多次使用figure命令生成多个图时，图片号按顺序增加 text():添加文字说明，可以在图中的任意位置添加文字，并支持LaTex语法 xlable()、ylable():用于添加X轴和Y轴标签 title():用于添加图的标题 axis([xmin,xmax,ymin,ymax]):用于确定坐标范围 xlim(xmin,xmax)和ylim(ymin,ymax):用于调整坐标范围 annotate():文本注释 xticks(),yticks():设置轴记号，人为设置坐标轴刻度显示的值 subplot():设置子图，例如subplot（2,3,1） axes：在Matplotlib中，整个图像为一个Figure对象 线性函数123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-"""Created on Sat Nov 25 11:39:15 2017"""import matplotlib.pyplot as plt#使用import导入模块matplotlib.pyplot，并简写成pltimport numpy as np#使用import导入模块numpy，并简写成npimport plotly as py # 导入plotly库并命名为py# -------------pre defpympl = py.offline.plot_mpl# 配置中文显示plt.rcParams['font.family'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号fig, ax = plt.subplots()x = np.linspace(1,10)# np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)# 参数解释：start,stop是开始，结束的数字，num是生成多少个数字，默认50个；endpoint是最后一个stop数字是否包含进去，默认包含；retstep,是两个数字间的间距，默认不显示；dtype默认。y = x*3 + 5#线性方程y= x*3 + 5plt.title("线性函数")#设置标题plt.xlabel("x 值")#设置x轴标签plt.ylabel("y 值")#设置y轴标签ax.plot(x, y)#画图plot_url = pympl(fig,filename=r'tmp/simple_line.html', show_link=False,resize=True) 增加子图案例1：12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding: utf-8 -*-"""Created on Sun Nov 26 15:10:23 2017@author: Administrator"""import numpy as np#使用import导入模块numpyimport matplotlib.pyplot as plt#使用import导入模块matplotlib.pyplotimport plotly as py # 导入plotly库并命名为py# -------------pre defpympl = py.offline.plot_mplfig, ax = plt.subplots()# 配置中文显示plt.rcParams['font.family'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号x1 = np.arange(0.0, 3.0, 0.01)x2 = np.arange(0.0, 4.0, 0.01)#产生x1，x2数据y1 = np.cos(2 * np.pi * x1) * np.exp(-x1)y2 = np.cos(2 * np.pi * x2)#产生数据y1，y2plt.subplot(2, 1, 1)# pyplot通过调用subplot或者add_subplot来增加子图，如p1 = plt.subplot(211) 或者 p1 = plt.subplot(2,1,1)， 表示创建一个2行，1列的图，p1为第一个子图，然后在p1上画曲线，设置标注标题图例等，就可以使用p1来调用相关的函数，可以直接使用pyplot画图，添加label，等。plt.plot(x1, y1)plt.title('子图1')#添加标题plt.ylabel('y1 值')#添加y轴名称plt.subplot(2, 1, 2)#添加子图plt.plot(x2, y2)plt.xlabel('数量')#添加标签plt.ylabel('y2 值')#添加y轴名称plot_url = pympl(fig,filename=r'tmp/subplot_1.html', show_link=False,resize=True) 案例2： 123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*-"""Created on Sun Nov 26 15:20:04 2017@author: Administrator"""import numpy as np#使用import导入模块numpyimport matplotlib.pyplot as plt#使用import导入模块matplotlib.pyplotimport plotly as py # 导入plotly库并命名为py# -------------pre defpympl = py.offline.plot_mpl# 配置中文显示fig, ax = plt.subplots()plt.rcParams['font.family'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号def f(t): return np.cos(2*np.pi*t)#产生f(t)函数t1 = np.arange(0.0, 5.0, 0.5)t2 = np.arange(0.0, 5.0, 0.01)#产生t1，t2数据plt.figure(1)plt.subplot(211)#添加子图plt.plot(t1, f(t1), 'bo', t2, f(t2), 'k')#画图plt.subplot(212)#添加子图plt.plot(np.cos(2*np.pi*t2), 'r--')plot_url = pympl(fig,filename=r'tmp/subplot_2.html', show_link=False,resize=True)]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plotly金融绘图]]></title>
    <url>%2F2019%2F06%2F02%2FPlotly%E9%87%91%E8%9E%8D%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[快速绘制k线图快速绘制OHLC(美国线)图 Pandas是金融领域中非常好用且高效的模块。1234567891011121314151617import plotly as py # 导入plotly库并命名为pyimport plotly.graph_objs as go# -------------pre defpyplt = py.offline.plotimport pandas as pddf = pd.read_csv(r'dat/appl.csv', index_col=['date'], parse_dates=['date'])trace = go.Ohlc( x=df.index, open=df.open, high=df.high, low=df.low, close=df.close,)data = [trace]pyplt(data, filename=r'tmp/first_ohlc.html') 上面最关键的代码是trace = go.Ohlc….,还可以用如下方式绘制：123456789101112import plotly as py # 导入plotly库并命名为pyimport plotly.figure_factory as ff # 导入plotly工具箱库中的图像工厂方法并命名为FF# -------------pre defpyplt = py.offline.plotimport pandas as pddf = pd.read_csv(r'dat/appl.csv', index_col=['date'], parse_dates=['date'])fig = ff.create_ohlc(df.open, df.high, df.low, df.close, dates=df.index)pyplt(fig, filename=r'tmp/first_ohlc_old.html') 快速绘制蜡烛图1234567891011121314151617181920212223242526272829303132333435363738394041import plotly as py # 导入plotly库并命名为pyimport plotly.graph_objs as go# -------------pre defpyplt = py.offline.plotimport pandas as pddf = pd.read_csv(r'dat/appl.csv', index_col=['date'], parse_dates=['date'])trace = go.Candlestick( x=df.index, open=df.open, high=df.high, low=df.low, close=df.close,)data = [trace]pyplt(data, filename=r'tmp/first_candlestick.html')``` 同理给出以前版本的蜡烛图绘制方法：```pythonimport plotly as py # 导入plotly库并命名为pyimport plotly.figure_factory as ff # 导入plotly工具箱库中的图像工厂方法并命名为FF# -------------pre defpyplt = py.offline.plotimport pandas as pddf = pd.read_csv(r'dat/appl.csv', index_col=['date'], parse_dates=['date'])fig = ff.create_candlestick(df.open, df.high, df.low, df.close, dates=df.index)pyplt(fig, filename=r'tmp/first_candlestick_old.html') go.Candlestick 和go.Ohlc函数用起来简单明了，但是绘图的结果中包含了所有的日期信息 k线图的优化过滤非交易时间 过滤非交易时间是X轴的操作，这个工作需要在布局管理中进行。12345678910111213141516171819202122232425262728293031323334353637383940import plotly as py # 导入plotly库并命名为pyimport plotly.graph_objs as goimport pandas as pdfig = go.Figure()# -------------pre defpyplt = py.offline.plotdf = pd.read_csv(r'dat/appl.csv', index_col=['date'], parse_dates=['date'])trace = go.Ohlc( x=df.index, open=df.open, high=df.high, low=df.low, close=df.close,)data = go.Data([trace])fig = go.Figure(data = data)fig['layout'].update( xaxis=go.XAxis( autorange=True, mirror='all', gridcolor='rgb(180, 180, 180)', showline=True, # 画出 X 轴那条线 showgrid=True, tickangle=-60, categoryorder="category ascending", type='category'), yaxis=go.YAxis( autorange=True, gridcolor='rgb(180, 180, 180)', ),)pyplt(fig, filename=r'tmp/ohlc_filter_time.html') 最关键的代码是categoryorder=”category ascending”, type=’category’。这两行的代码的意思是，吧X轴的元素看成分类的原素type=’category’，并对其进行升序排序（categoryorder=”category ascending”,）。既然元素的属性为类别，不是时间，也就是没有过滤非交易时间的问题了。 对于categoryorder参数，默认是“trace”，即以默认的df.index进行排序。可以是升序也可以是降序（categoryorder=”category descending”），甚至可以自定义顺序（array），这时需要额外的参数支持（categoryarray），用来传递自定义的index。对于蜡烛线的代码如下：123456789101112131415161718192021222324252627282930313233import plotly as py # 导入plotly库并命名为pyimport plotly.graph_objs as gofig = go.Figure()# -------------pre defpyplt = py.offline.plotimport pandas as pddf = pd.read_csv(r'dat/appl.csv', index_col=['date'], parse_dates=['date'])trace = go.Candlestick( x=df.index, open=df.open, high=df.high, low=df.low, close=df.close,)data = go.Data([trace])fig = go.Figure(data = data)fig['layout'] = dict( xaxis=dict( showline=True, # 画出 X 轴那条线 tickangle=-60, categoryorder="category ascending", type='category'))pyplt(fig, filename=r'tmp/candlestick_filter_time.html') 设置形状、颜色和注释1234567891011121314151617181920212223242526272829303132333435363738394041424344import plotly as pyimport plotly.graph_objs as goimport pandas as pdfig = go.Figure()# -------------pre defpyplt = py.offline.plotdf = pd.read_csv(r'dat/appl.csv', index_col=['date'], parse_dates=['date'])trace = go.Candlestick(x=df.index, open=df.open, high=df.high, low=df.low, close=df.close, increasing=dict(line=dict(color='#FF0000')),#上涨的颜色 decreasing=dict(line=dict(color='#0C05F9')) #下跌的颜色 )data = go.Data([trace])fig = go.Figure(data = data)fig['layout'] = &#123; 'xaxis': &#123; 'showline': True, # 画出 X 轴那条线 'tickangle': -60, 'categoryorder': "category ascending", 'type': 'category'&#125;, 'title': '苹果公司K线图', 'yaxis': &#123;'title': '股票价格'&#125;, 'shapes': [&#123; 'x0': '2016-08-22', 'x1': '2016-10-05', 'y0': 0, 'y1': 1, 'xref': 'x', 'yref': 'paper', 'line': &#123;'color': 'rgb(30,30,30)', 'width': 2&#125; &#125;], 'annotations': [&#123; 'x': '2016-09-12', 'y': 0.05, 'xref': 'x', 'yref': 'paper', 'showarrow': True, 'xanchor': 'left', 'text': '区间最低价' &#125;]&#125;pyplt(fig, filename=r'tmp/candlestick_style.html') 对于颜色设置，上涨设置为红色，下跌设置为蓝色，increasing=dict(line=dict(color=’#FF0000’)),decreasing=dict(line=dict(color=’#0C05F9’))xref(yref) 参数有2个值：paper 和 x（y），如果值为x，则x0、x1对应的值为坐标轴的绝对值，；如果值为paper，则x0、x1对应的值为坐标的相对值。本例中“y0=0，y1=1”表示shapes的Y轴起点在y0=0处、终点在y1=1处。对应OHLC图，其绘制方法是一样的：1234567891011121314151617181920212223242526272829303132333435363738394041424344import plotly as pyimport plotly.graph_objs as goimport pandas as pdfig = go.Figure()# -------------pre defpyplt = py.offline.plotdf = pd.read_csv(r'dat/appl.csv', index_col=['date'], parse_dates=['date'])trace = go.Ohlc(x=df.index, open=df.open, high=df.high, low=df.low, close=df.close, increasing=dict(line=dict(color='#FF0000')), decreasing=dict(line=dict(color='#0C05F9')) )data = go.Data([trace])fig = go.Figure(data = data)fig['layout'] = &#123; 'xaxis': &#123; 'showline': True, # 画出 X 轴那条线 'tickangle': -60, 'categoryorder': "category ascending", 'type': 'category'&#125;, 'title': '苹果公司K线图', 'yaxis': &#123;'title': '股票价格'&#125;, 'shapes': [&#123; 'x0': '2016-08-22', 'x1': '2016-10-05', 'y0': 0, 'y1': 1, 'xref': 'x', 'yref': 'paper', 'line': &#123;'color': 'rgb(30,30,30)', 'width': 2&#125; &#125;], 'annotations': [&#123; 'x': '2016-09-12', 'y': 0.05, 'xref': 'x', 'yref': 'paper', 'showarrow': True, 'xanchor': 'left', 'text': '区间最低价' &#125;]&#125;pyplt(fig, filename=r'tmp/ohlc_style.html') 添加技术指标 将k线图和5日均线图画在同一张图上。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import plotly as py # 导入plotly库并命名为pyimport plotly.graph_objs as goimport pandas as pdfig = go.Figure()# -------------pre defpyplt = py.offline.plotdf = pd.read_csv(r'dat/appl.csv', index_col=['date'], parse_dates=['date'])# K线图trace = go.Candlestick( x=df.index, open=df.open, high=df.high, low=df.low, close=df.close,)# 5日均线拟合直线add_line = go.Scatter( x=df.index, y=df.open, name= 'Open Vals', line=dict(color='black') )data = go.Data([trace,add_line])fig = go.Figure(data = data)fig['layout'].update( xaxis=go.XAxis( autorange=True, mirror='all', gridcolor='rgb(180, 180, 180)', showline=True, # 画出 X 轴那条线 showgrid=True, tickangle=-60, categoryorder="category ascending", type='category'), yaxis=go.YAxis( autorange=True, gridcolor='rgb(180, 180, 180)', ),)pyplt(fig, filename=r'tmp/ohlc_add_svg.html') 自定义数据的金融绘图123456789101112131415161718192021222324252627282930import plotly as pyimport plotly.graph_objs as gofrom datetime import datetime# -------------pre defpyplt = py.offline.plot# 添加数据open_data = [33.0, 33.3, 33.5, 33.0, 34.1]high_data = [33.1, 33.3, 33.6, 33.2, 34.8]low_data = [32.7, 32.7, 32.8, 32.6, 32.8]close_data = [33.0, 32.9, 33.3, 33.1, 33.1]dates = [datetime(year=2016, month=10, day=10), datetime(year=2016, month=11, day=10), datetime(year=2016, month=12, day=10), datetime(year=2017, month=1, day=10), datetime(year=2017, month=2, day=10)]# 创建ohlctrace = go.Candlestick(x=dates, #画蜡烛图，换成Ohlc就是画美国线 open=open_data, high=high_data, low=low_data, close=close_data)data = [trace]pyplt(data, filename=r'tmp/candlestick_custom_data.html') 高级金融绘图 高级金融绘图是用cufflinks进行绘制；123456789101112131415161718192021222324252627282930313233#%% md# 5.4 高级金融绘图#%% md## 5.4.1 入门案例#%%import cufflinks as cfcf.set_config_file(offline=True, world_readable=True)df=cf.datagen.ohlc()qf=cf.QuantFig(df,title='高级金融张图',legend='top',name='QF')qf.add_bollinger_bands()qf.iplot()#%% md## 5.4.2 综合案例#%%import cufflinks as cfcf.set_config_file(offline=True, world_readable=True)df=cf.datagen.ohlcv()qf=cf.QuantFig(df,title='高级金融张图',legend='top',name='QF')qf.add_bollinger_bands()qf.add_sma([10,20],width=2,color=['green','lightgreen'],legendgroup=True)qf.add_rsi(periods=20,color='java')qf.add_bollinger_bands(periods=20,boll_std=2,colors=['magenta','grey'],fill=True)qf.add_volume()qf.add_macd()qf.iplot()#%%]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>金融绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[plotly和Pandas的cufflinks封装]]></title>
    <url>%2F2019%2F06%2F02%2Fplotly%E5%92%8CPandas%E7%9A%84cufflinks%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装cufflinks1pip install categories cufflinks目前对Pandas的支持仅局限在Jupyter Notebook中，所以要打开Jupiter Notebook运行这些文件。cufflinks是一个简单易用的模块：（1） 获取cufflinks的源代码，https://gitub.com/santosjorge/cufflinks(2) cufflinks更多的案例，在网页中选择Chart Gallery链接。也可以下载文件cufflinks Tutorial - Chart Gallery.ipynb(3) 要获取cufflinks高级的案例代码，Pandas Like Visualization 链接,也可以下载文件cufflinks Tutorial - Pandas Like.ipynb 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#%% md## 4.2.2 快速入门#%%import plotly.plotly as pyimport cufflinks as cfimport pandas as pdcf.set_config_file(offline=True, theme='ggplot')N = 500x = np.linspace(0, 1, N)y = np.random.randn(N)df = pd.DataFrame(&#123;'x': x, 'y': y&#125;)df.set_index('x',inplace=True)df.iplot(kind='scatter', filename='tmp/cf_line.html')#%% md## 4.2.3 快速获取数据#%%import plotly.plotly as pyimport cufflinks as cfimport pandas as pdcf.set_config_file(offline=True, theme='polar')df = cf.datagen.scatter() # 生成散点图数据df.iplot(kind='scatter', mode='markers', x='x', y='y')#%% md## 4.2.4 自定义绘图#%%import plotly.plotly as pyimport cufflinks as cfimport pandas as pdcf.set_config_file(offline=True, world_readable=True)df = cf.datagen.lines(n_traces=3,columns=['one','two','three']) # 生成一个3列的DataFrame（默认5列）。colors = ['red', 'blue', 'black'] # 自定义每条线的颜色dashes = ['solid', 'dash', 'dashdot'] # 自定义每条线的Stylewidths = [2, 4, 6] # 自定义每条线的宽度plot_url = df.iplot(kind='scatter', mode='lines', colors=colors, dash=dashes,width=widths,xTitle='日期',yTitle='数量',title='自定义绘图')#%% md## 4.2.5 常见经典图形#%% md### 1） 柱状图#%%import plotly.plotly as pyimport cufflinks as cfcf.set_config_file(offline=True, world_readable=True, theme='ggplot')df = cf.datagen.bars()df.iplot(kind='bar', filename=r'tmp/cf_bar.html')#%% md### 2）柱状图（堆积）#%%import plotly.plotly as pyimport cufflinks as cfcf.set_config_file(offline=True, world_readable=True, theme='ggplot')df = cf.datagen.bars(n_categories=4,columns=['A', 'B', 'C', 'D'])df.iplot(kind='bar', barmode='stack', filename='cufflinks/stacked-bar-chart')#%% md### 3)散点图#%%import plotly.plotly as pyimport cufflinks as cfcf.set_config_file(offline=True, world_readable=True)df = cf.datagen.lines(2, columns=['中信证券','招商证券'])df.iplot(kind='scatter',mode='markers',size=10,symbol='x',colorscale='paired', xTitle='日期',yTitle='每股盈利增长率',title='散点图')#%% md### 4)价差图#%%import cufflinks as cfcf.set_config_file(offline=True, world_readable=True)df= cf.datagen.lines(2,columns=['万科A','中粮地产'])df.iplot(kind='spread',xTitle='日期',yTitle='收益率',title='价差图')#%% md### 5）直方图#%%import cufflinks as cfcf.set_config_file(offline=True, world_readable=True)df= cf.datagen.histogram(2)df.iplot(kind='histogram',opacity=.75,title='直方图')#%% md### 6) 时间序列子图#%%import cufflinks as cfcf.set_config_file(offline=True, world_readable=True, theme='pearl')df=cf.datagen.lines(4)df.iplot(subplots=True, shape=(4,1), shared_xaxes=True, fill=True)#%% md### 7) 3D散点图#%%import cufflinks as cfcf.set_config_file(offline=True, world_readable=True)df = cf.datagen.scatter3d(2,150)df.iplot(kind='scatter3d',x='x',y='y',z='z',size=15,categories='categories',text='text', title='3D散点图',colors=['blue','pink'],width=0.5,margin=(0,0,0,0), opacity=1)#%%df.iplot?#%%]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>cufflinks模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[plotly与Pandas]]></title>
    <url>%2F2019%2F06%2F02%2Fplotly%E4%B8%8EPandas%2F</url>
    <content type="text"><![CDATA[基本线形图 Plotly可以识别Pandas数据格式，所以数据是Pandas的DataFrame或Series结构，可以直接传递给Plotly，不用转换为list数据格式123456789101112131415161718192021222324import plotly as py # 导入plotly库并命名为pyimport plotly.graph_objs as goimport pandas as pdimport numpy as np# -------------pre defpyplt = py.offline.plotN = 500x = np.linspace(0, 1, N)y = np.random.randn(N)df = pd.DataFrame(&#123;'x': x, 'y': y&#125;)df.head()data = [ go.Scatter( x=df['x'], # x可以是 DataFrame 的某一列 y=df['y'] )]url = pyplt(data, filename='tmp/basic_line.html') 基本散点图1234567891011121314151617181920212223242526272829303132333435import plotly as py # 导入plotly库并命名为pyimport pandas as pd# -------------pre defpyplt = py.offline.plotdf_50 = pd.read_csv(r'dat/000016.csv', index_col=['date']) # 读取数据df_50.sort_index(inplace=True) # 排序df_50 = df_50.loc['2017-01-03':,:]df_300 = pd.read_csv(r'dat/000300.csv', index_col=['date'])df_300.sort_index(inplace=True) # 排序df_300 = df_300.loc['2017-01-01':]fig = &#123; 'data': [ &#123; 'x': df_50.index, 'y': df_50.volume, 'mode': 'markers', 'name': '上证50'&#125;, &#123; 'x': df_300.index, 'y': df_300.volume, 'mode': 'markers', 'name': '沪深300'&#125; ], 'layout': &#123; 'xaxis': &#123;'title': '时间', # 'type': 'log', &#125;, 'yaxis': &#123;'title': "成交量"&#125; &#125;&#125;url = pyplt(fig, filename='tmp/basic_scatter.html') 基本柱状图1234567891011121314151617181920212223import plotly as py # 导入plotly库并命名为pyimport plotly.graph_objs as goimport pandas as pdimport numpy as np# -------------pre defpyplt = py.offline.plotN = 40x = np.linspace(0, 1, N)y = np.random.randn(N)df = pd.DataFrame(&#123;'x': x, 'y': y&#125;)df.head()data = [ go.Bar( x=df['x'], # x可以是 DataFrame 的某一列 y=df['y'] )]url = pyplt(data, filename=r'tmp/basic_bar.html')]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Pandas基本图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ploty高级图形03]]></title>
    <url>%2F2019%2F05%2F31%2Fploty%E9%AB%98%E7%BA%A7%E5%9B%BE%E5%BD%A203%2F</url>
    <content type="text"><![CDATA[3.7 绘制SVG(可伸缩矢量图)矩形图的绘制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import plotly as pyimport plotly.graph_objs as go# ----------pre defpyplt = py.offline.plottrace0 = go.Scatter( x=[1.5, 4,1.5,4], y=[3.75, 3.75,2.2,2.2], text=['矩形', '矩形（填充）','矩形（相对于plot+填充）','矩形（相对于轴+填充）'], mode='text',)data = [trace0]layout = &#123; 'xaxis': &#123; 'range': [0, 8], 'showgrid': False, &#125;, 'yaxis': &#123; 'range': [0, 6.5] &#125;, 'shapes': [ # 普通的矩形 &#123; 'type': 'rect', 'x0': 1, 'y0': 4, 'x1': 2, 'y1': 6, 'line': &#123; 'color': 'rgba(128, 0, 128, 1)', &#125;, &#125;, # 填充颜色的矩形 &#123; 'type': 'rect', 'x0': 3, 'y0': 4, 'x1': 5, 'y1': 6, 'line': &#123; 'color': 'rgba(128, 0, 128, 1)', 'width': 2, &#125;, 'fillcolor': 'rgba(128, 0, 128, 0.7)', &#125;, # 相对于plot的矩形 + 填充颜色 &#123; 'type': 'rect', 'xref': 'paper', 'yref': 'paper', 'x0': 0.125, 'y0': 0, 'x1': 0.25, 'y1': 0.3, 'line': &#123; 'color': 'rgb(50, 171, 96)', 'width': 3, &#125;, 'fillcolor': 'rgba(50, 171, 96, 0.6)', &#125;, # 相对于轴的矩形 + 填充颜色 &#123; 'type': 'rect', 'xref': 'x', 'yref': 'y', 'x0': 3, 'y0': 0, 'x1': 5, 'y1': 2, 'line': &#123; 'color': 'rgb(55, 128, 191)', 'width': 3, &#125;, 'fillcolor': 'rgba(55, 128, 191, 0.6)', &#125;, ]&#125;fig = &#123; 'data': data, 'layout': layout,&#125;pyplt(fig, filename='tmp/SVG_rectangle.html') 参数type。参数值可以是circle(圆)、rect（矩形）、path（路径）、line（线），默认是line。本例使用的是rect fillcolor参数，设置填充的颜色，默认是rgba(0,0,0,0)(白色)矩形图应用：设置时间序列区域高亮显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import plotly as pyimport plotly.graph_objs as goimport pandas as pd# ----------pre defpyplt = py.offline.plotdf = pd.read_csv(r'dat/day01.csv', index_col=['date'], parse_dates=['date']) # 读取数据。df.sort_index(inplace=True) # 设置索引列从大到小排序df = df.iloc[-300:-100] # 选取其中的200行数据trace0 = go.Scatter(x=df.index, y=df['close'], mode='lines', name='temperature')data = [trace0]layout = &#123; # 我们通过创建矩形的方式来高亮某一个时间区间 'shapes': [ # 首先，我们高亮显示2月4日---&gt;3月6日. &#123; 'type': 'rect', # x参考系使用绝对坐标系（相对于轴） 'xref': 'x', # y参考系使用相对坐标系（相对于plot） 'yref': 'paper', 'x0': '2015-02-04', 'y0': 0, 'x1': '2015-03-06', 'y1': 1, 'fillcolor': '#d3d3d3', 'opacity': 0.2, 'line': &#123; 'width': 0, &#125; &#125;, # 其次，我们高亮显示区间5月20日---&gt;6月22日. &#123; 'type': 'rect', 'xref': 'x', 'yref': 'paper', 'x0': '2015-05-20', 'y0': 0, 'x1': '2015-06-22', 'y1': 1, 'fillcolor': '#d3d3d3', 'opacity': 0.2, 'line': &#123; 'width': 0, &#125; &#125; ]&#125;fig = &#123;'data': data, 'layout': layout&#125;pyplt(fig, filename='tmp/timestamp_highlight.html') 圆形图的绘制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import plotly as pyimport plotly.graph_objs as go# ----------pre defpyplt = py.offline.plottrace0 = go.Scatter( x=[1.5, 3.5], y=[0.75, 2.5], text=['无填充圆', '有填充圆'], mode='text',)data = [trace0]layout = &#123; 'xaxis': &#123; 'range': [0, 4.5], 'zeroline': False, &#125;, 'yaxis': &#123; 'range': [0, 4.5] &#125;, 'width': 800, 'height': 800, 'shapes': [ # 无填充圆 &#123; 'type': 'circle', 'xref': 'x', 'yref': 'y', 'x0': 1, 'y0': 1, 'x1': 3, 'y1': 3, 'line': &#123; 'color': 'rgba(50, 171, 96, 1)', &#125;, &#125;, # 有填充圆 &#123; 'type': 'circle', 'xref': 'x', 'yref': 'y', 'fillcolor': 'rgba(50, 171, 96, 0.7)', 'x0': 3, 'y0': 3, 'x1': 4, 'y1': 4, 'line': &#123; 'color': 'rgba(50, 171, 96, 1)', &#125;, &#125;, ]&#125;fig = &#123; 'data': data, 'layout': layout,&#125;pyplt(fig, filename='tmp/SVG_circle.html') 注意：本例中设置了参数 ‘width’: 800, ‘height’: 800,如果参数hight != width,则按照我们自己的方式画出来的圆是一个椭圆，默认是 ‘width’: 450, ‘height’: 750 圆形图应用：高亮显示散点图的聚集簇123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import plotly as pyimport plotly.graph_objs as goimport numpy as np# ----------pre defpyplt = py.offline.plotx0 = np.random.normal(2, 0.45, 300)y0 = np.random.normal(2, 0.45, 300)x1 = np.random.normal(6, 0.4, 200)y1 = np.random.normal(6, 0.4, 200)x2 = np.random.normal(4, 0.3, 200)y2 = np.random.normal(4, 0.3, 200)trace0 = go.Scatter( x=x0, y=y0, mode='markers',)trace1 = go.Scatter( x=x1, y=y1, mode='markers')trace2 = go.Scatter( x=x2, y=y2, mode='markers')trace3 = go.Scatter( x=x1, y=y0, mode='markers')layout = &#123; 'shapes': [ &#123; 'type': 'circle', 'xref': 'x', 'yref': 'y', 'x0': min(x0), 'y0': min(y0), 'x1': max(x0), 'y1': max(y0), 'opacity': 0.2, 'fillcolor': 'blue', 'line': &#123; 'color': 'blue', &#125;, &#125;, &#123; 'type': 'circle', 'xref': 'x', 'yref': 'y', 'x0': min(x1), 'y0': min(y1), 'x1': max(x1), 'y1': max(y1), 'opacity': 0.2, 'fillcolor': 'orange', 'line': &#123; 'color': 'orange', &#125;, &#125;, &#123; 'type': 'circle', 'xref': 'x', 'yref': 'y', 'x0': min(x2), 'y0': min(y2), 'x1': max(x2), 'y1': max(y2), 'opacity': 0.2, 'fillcolor': 'green', 'line': &#123; 'color': 'green', &#125;, &#125;, &#123; 'type': 'circle', 'xref': 'x', 'yref': 'y', 'x0': min(x1), 'y0': min(y0), 'x1': max(x1), 'y1': max(y0), 'opacity': 0.2, 'fillcolor': 'red', 'line': &#123; 'color': 'red', &#125;, &#125;, ], 'showlegend': False,&#125;data = [trace0, trace1, trace2, trace3]fig = &#123; 'data': data, 'layout': layout,&#125;pyplt(fig, filename='tmp/clusters.html')]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>plotly高级图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ploty高级图形02]]></title>
    <url>%2F2019%2F05%2F31%2Fploty%E9%AB%98%E7%BA%A7%E5%9B%BE%E5%BD%A202%2F</url>
    <content type="text"><![CDATA[多子图子坐标轴自定义1234567891011121314151617181920212223242526272829303132from plotly import toolsimport plotly as pyimport plotly.graph_objs as gopyplt = py.offline.plottrace1 = go.Scatter(x=[1, 2, 3], y=[4, 5, 6])trace2 = go.Scatter(x=[20, 30, 40], y=[50, 60, 70])trace3 = go.Scatter(x=[300, 400, 500], y=[600, 700, 800])trace4 = go.Scatter(x=[4000, 5000, 6000], y=[7000, 8000, 9000])fig = tools.make_subplots(rows=2, cols=2, subplot_titles=('Plot 1', 'Plot 2', 'Plot 3', 'Plot 4'))fig.append_trace(trace1, 1, 1)fig.append_trace(trace2, 1, 2)fig.append_trace(trace3, 2, 1)fig.append_trace(trace4, 2, 2)fig['layout']['xaxis1'].update(title='xaxis 1 title')fig['layout']['xaxis2'].update(title='xaxis 2 title', range=[10, 50])fig['layout']['xaxis3'].update(title='xaxis 3 title', showgrid=False)fig['layout']['xaxis4'].update(title='xaxis 4 title', type='log')fig['layout']['yaxis1'].update(title='yaxis 1 title')fig['layout']['yaxis2'].update(title='yaxis 2 title', range=[40, 80])fig['layout']['yaxis3'].update(title='yaxis 3 title', showgrid=False)fig['layout']['yaxis4'].update(title='yaxis 4 title')fig['layout'].update(title='Customizing Subplot Axes')pyplt(fig, filename='tmp/subplot_custom_axes.html') 在plotly中对已经定义好的绘图进行自定义，需要修改figure中的Layout。本例的代码只定义了坐标轴的显示范围，坐标轴类型和是否显示网格，对于其他的画面布局，也可以通过这种方式进行定义。 嵌入式子图最关键的参数是domain1234567891011121314151617181920212223242526import plotly as pyimport plotly.graph_objs as gopyplt = py.offline.plottrace1 = go.Scatter( x=[1, 2, 3], y=[4, 3, 2])trace2 = go.Scatter( x=[20, 30, 40], y=[30, 40, 50], xaxis='x2', yaxis='y2')data = [trace1, trace2]layout = go.Layout( xaxis2=dict( domain=[0.6, 0.95], anchor='y2' ), yaxis2=dict( domain=[0.6, 0.95], anchor='x2' ))fig = go.Figure(data=data, layout=layout)pyplt(fig, filename='tmp/subplot_insert.html') 混合图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110from plotly.graph_objs import *import plotly as pyimport plotly.graph_objs as gopyplt = py.offline.plotimport pandas as pd# read in volcano database datadf = pd.read_excel(r'dat/volcano_db.xlsx')# frequency of Countryfreq = dffreq = freq.Country.value_counts().reset_index().rename(columns=&#123;'index': 'x'&#125;)# plot(1) top 10 countries by total volcanoeslocations = go.Bar(x=freq['x'][0:10],y=freq['Country'][0:10], marker=dict(color='#CF1020'))# read in 3d volcano surface datadf_v = pd.read_excel(r'dat/volcano.xlsx')# plot(2) 3d surface of volcanothreed = Surface(z=df_v.values.tolist(), colorscale='Reds', showscale=False)# plot(3) scattergeo map of volcano locationstrace3 = &#123; "geo": "geo3", "lon": df['Longitude'], "lat": df['Latitude'], "hoverinfo": 'text', "marker": &#123; "size": 4, "opacity": 0.8, "color": '#CF1020', "colorscale": 'Viridis' &#125;, "mode": "markers", "type": "scattergeo"&#125;data = go.Data([locations, threed, trace3])# control the subplot below using domain in 'geo', 'scene', and 'axis'layout = &#123; "plot_bgcolor": 'black', "paper_bgcolor": 'black', "titlefont": &#123; "size": 20, "family": "Raleway" &#125;, "font": &#123; "color": 'white' &#125;, "dragmode": "zoom", "geo3": &#123; "domain": &#123; "x": [0, 0.55], "y": [0, 0.9] &#125;, "lakecolor": "rgba(127,205,255,1)", "oceancolor": "rgb(6,66,115)", "landcolor": 'white', "projection": &#123;"type": "orthographic"&#125;, "scope": "world", "showlakes": True, "showocean": True, "showland": True, "bgcolor": 'black' &#125;, "margin": &#123; "r": 10, "t": 25, "b": 40, "l": 60 &#125;, "scene": &#123;"domain": &#123; "x": [0.5, 1], "y": [0, 0.55] &#125;, "xaxis": &#123;"gridcolor": 'white'&#125;, "yaxis": &#123;"gridcolor": 'white'&#125;, "zaxis": &#123;"gridcolor": 'white'&#125; &#125;, "showlegend": False, "title": "&lt;br&gt;Volcano Database", "xaxis": &#123; "anchor": "y", "domain": [0.6, 0.95] &#125;, "yaxis": &#123; "anchor": "x", "domain": [0.65, 0.95], "showgrid": False &#125;&#125;annotations = &#123; "text": "Source: NOAA", "showarrow": False, "xref": "paper", "yref": "paper", "x": 0, "y": 0&#125;layout['annotations'] = [annotations]fig = go.Figure(data=data, layout=layout)pyplt(fig, filename = "tmp/Mixed Subplots Volcano.html") 3.7 绘制SVG(可伸缩矢量图)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import plotly as pyimport plotly.graph_objs as go# ----------pre defpyplt = py.offline.plottrace0 = go.Scatter( x=[1.2, 3.5, 5,0.5,7], y=[1, 1.8, 1.2,0.5,0.6], text=['垂直线(破折号)', '水平线（点+破折号）', '对角线（点）','对角线（相对于plot）','对角线（相对于轴）'], mode='text',)data = [trace0]layout = &#123; 'xaxis': &#123; 'range': [0, 8] &#125;, 'yaxis': &#123; 'range': [0, 2.5] &#125;, 'shapes': [ # 画垂直线 &#123; 'type': 'line', 'x0': 1, 'y0': 0, 'x1': 1, 'y1': 2, 'line': &#123; 'color': 'rgb(55, 128, 191)', 'width': 3, 'dash':'dash', &#125;, &#125;, # 水平线 &#123; 'type': 'line', 'x0': 2, 'y0': 2, 'x1': 5, 'y1': 2, 'line': &#123; 'color': 'rgb(50, 171, 96)', 'width': 4, 'dash': 'dashdot', &#125;, &#125;, # 对角线 &#123; 'type': 'line', 'x0': 4, 'y0': 0, 'x1': 6, 'y1': 2, 'line': &#123; 'color': 'rgb(128, 0, 128)', 'width': 4, 'dash': 'dot', &#125;, &#125;, # 相对于轴绘图 &#123; 'type': 'line', 'xref': 'x', 'yref': 'y', 'x0': 4, 'y0': 0, 'x1': 8, 'y1': 1, 'line': &#123; 'color': 'rgb(55, 128, 191)', 'width': 3, &#125;, &#125;, # 相对于plot绘图 &#123; 'type': 'line', 'xref': 'paper', 'yref': 'paper', 'x0': 0, 'y0': 0, 'x1': 0.5, 'y1': 0.5, 'line': &#123; 'color': 'rgb(50, 171, 96)', 'width': 3, &#125;, &#125;, ]&#125;fig = &#123; 'data': data, 'layout': layout,&#125;pyplt(fig, filename='tmp/SVG_line.html') 前面的图形都是通过go.Scatter 等函数绘制的，绘制SVG是在layout中进行设置的。本例中： dash 参数的使用，用于设置线性图结果的呈现方式，可选择值有solid（线条），dot（点），longdash（长破折号），dashdot（点+破折号）和longdashdot（长点+破折号），默认是solid xref（yref）参数的使用，该参数有两个值：paper和x(y).如果值为x，则x0，x1对应的值为坐标轴的绝对值，比如“x0=0,x1=4”表示线的起点为0，终点在4；如果值为paper，则x0、x1对应的值为坐标轴的相对值，本例中“x0=0，x1=0.5”表示线的起点x0在0处，线的终点x1在0.5*8=4处线形图的应用：创建图形的切线代码的功能通过人工的方法找出，f(x)= sin(x^2)+1在区间[1,3]之间的几个极值点。然后根据这几个极值点绘制水平线123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263## 代码SVG_tangent_line.pyimport plotly as pyimport plotly.graph_objs as goimport numpy as np# ----------pre defpyplt = py.offline.plotx0 = np.linspace(1, 3, 200)y0 = x0 * np.sin(np.power(x0, 2)) + 1trace0 = go.Scatter( x=x0, y=y0,)data = [trace0]layout = &#123; 'title': "f(x)=sin(x^2)+1", 'shapes': [ &#123; 'type': 'line', 'x0': 1, 'y0': 2.30756, 'x1': 1.75, 'y1': 2.30756, 'opacity': 0.7, 'line': &#123; 'color': 'red', 'width': 2.5, &#125;, &#125;, &#123; 'type': 'line', 'x0': 2.5, 'y0': 3.80796, 'x1': 3.05, 'y1': 3.80796, 'opacity': 0.7, 'line': &#123; 'color': 'red', 'width': 2.5, &#125;, &#125;, &#123; 'type': 'line', 'x0': 1.90, 'y0': -1.1827, 'x1': 2.50, 'y1': -1.1827, 'opacity': 0.7, 'line': &#123; 'color': 'red', 'width': 2.5, &#125;, &#125;, ]&#125;fig = &#123; 'data': data, 'layout': layout,&#125;pyplt(fig, filename='tmp/tangent-line.html')]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>plotly高级图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ploty高级图形01]]></title>
    <url>%2F2019%2F05%2F28%2Fploty%E9%AB%98%E7%BA%A7%E5%9B%BE%E5%BD%A201%2F</url>
    <content type="text"><![CDATA[时间序列使用方法1234567891011121314151617import plotly as pyimport plotly.graph_objs as gofrom datetime import datetime#----pre defpyplt = py.offline.plotx_datetime = [datetime(year=2013,month=10,day=4),datetime(year=2013,month=11,day=5),datetime(year=2013,month=12,day=6)]x_string = ['2013-10-04','2013-11-05','2013-12-06']#时间格式的字符串trace_time = go.Scatter(x=x_datetime,y=[1,3,6],name = 'trace_datetime')trace_string = go.Scatter(x=x_string,y=[2,4,7],name='trace_string')data = [trace_time,trace_string]pyplt(data,filename='timeSeries.html') 从代码可以看出，只要传入的x是日期或时间格式的字符串，plotly就会自动识别为时间格式。 时间范围约束 有时候我们只想展示部分时间范围内的绘图结果，这时通过传递一个range参数即可实现这个功能123456789101112131415161718192021222324252627282930import plotly as pyimport plotly.graph_objs as gofrom datetime import datetime#----pre defpyplt = py.offline.plotx_datetime = [datetime(year=2013,month=10,day=4),datetime(year=2013,month=11,day=5),datetime(year=2013,month=12,day=6)]def to_unix_time(dt): '''' :param dt:datetime 类型的时间戳 ：return:dt相对于utc起始时间差别的毫秒数 ''' epoch = datetime.utcfromtimestamp(0) #获取0时刻对应的utc（世界标准时间） return (dt - epoch).total_seconds() * 1000 #计算传入时间相对于utc起始时间的毫秒数data = [go.Scatter( x = x_datetime, y = [1,3,6])]layout = go.Layout(xaxis = dict( range = [to_unix_time(datetime(2013,10,17)), to_unix_time(datetime(2013,11,20))]))fig = go.Figure(data=data,layout=layout)pyplt(data,filename='timeSeries.html') 主要是在x轴的布局上限制x的取值范围。 滑动选择控件 滑块与选择器主要是通过Layout布局函数来实现的。对于选择器，主要是在xais.rangeselector.buttons中定义一些参数，代码如下： 1234567891011xaxis = dict( rangeselector = dict( buttons=list([ dict(count = 1, label = '1m', step = 'month' stepmode = 'backward' ), ]) )) (1) xaxis 表示对x轴进行定义：rangeselector表示对x轴的选择器进行定义；button表示选择器的按钮，是一个列表形式，每个列表元素都是一个选择器按钮。(2) “count = 1,step = ‘month’ “表示这个选择器覆盖的时间长度是“1xmonth”，即一个月，“label=‘1m’”表示标签为1m(3) stepmode 有以下两种使用方法 当stepmode=’backward’时，表示从后往前推进countxstep时间，列如，当count=1，step=‘year’时，表示时间范围将近一年。 当stepmode = ‘todate’时，一般只有一种方用法，就是计算今年以来的时间。例如，当count=1，step=‘year’时，表示范围从最后日期到最后日期所在的年初，而不是一年。 表格123456789101112131415161718192021import plotly as pyimport plotly.figure_factory as FFimport pandas as pd#----pre defpyplt = py.offline.plotdata_matrix = [['国家','年份','人口'], ['中国',2000, 1267430000], ['美国',2000, 282200000], ['加拿大',2000,27790000], ['中国', 2000, 1267430000], ['美国', 2000, 282200000], ['加拿大', 2000, 27790000], ['加拿大',2000,27790000], ['中国', 2000, 1267430000], ['美国', 2000, 282200000], ['加拿大', 2000, 27790000] ]table = FF.create_table(data_matrix)pyplt(table,filename='simple_table',show_link=False) 代码用到了figure_factory类，这个类存储了除之前的基础绘图方法的一些高级绘图方法。 添加链接1234data_matrix = [ ['user','Language','chart Type','#of Views'], ['&lt;a href="https://plot.ly/~empet/folder/home"&gt;empet&lt;/a&gt;',...... ]] 运用HTML语言中 标签的herf属性即可：’empet‘ 使用Pandas 数据分析用Pandas，1234567import pandas as pddf = pd.read_csv(r'day01.csv',index_col=[0])df_sample = df[100:120]table = FF.create_table(df_sample,index=True,index_title='Date')pyplt(table,filename='simple_table.html') Pandas的数据结构DataFrame是一种表格结构。 改变大小与颜色123456789colorscale = [[0,'#4d004c'],[.5, '#f2e5ff'],[1,'#ffffff']]fontcolor = ['#FCFCFC','#00EE00','#FF3030']table = FF.create_table(df_sample,index=True,colorscale=colorscale,font_color = fontcolor)table.layout.width=1000#设置文本大小for i in range(len(table.layout.annotations)): table.layout.annotations[i].font.size = 10 + (i % 50)*0.2 (1) colorscale参数是一个列表，是[[0,’#4d004c’],[.5, ‘#f2e5ff’],[1,’#ffffff’]]表示表头的颜色是#4d004c; [.5, ‘#f2e5ff’] 除表头外，表格的奇数行的背景颜色是’#f2e5ff’，同理[1,’#ffffff’]表示偶数行的背景色是’#ffffff’(2) fontcolors参数时一个列表，它既可以是一个元素的列表，表示所有表格的文字使用一种颜色（默认是[‘#000000’]）,也可以是三个元素的列表，分别宝石表头，奇数列，偶数列的文字颜色，甚至可以是一个与表格行数相同的列表。可以为每一行自定义一个颜色。(3) table.layout.width=1000 把表格的宽度设置为1000 表格与图 将表格与图展示在一张图上。1234567891011121314import plotly.figure_factory as FF #创建表格 figure = FF.create_table(table_data, height_constant = 60) #吧图添加到figure中 figure['data'].extend(go.Data([trace,trace1]))#对两幅图进行布局管理figure.layout.xaxis.update(&#123;'domain':[[0,.5]&#125;)figure.layout.xaxis2.update(&#123;'domain':[0.6, 1.]&#125;)#设置第二幅图的y轴与x的对应。把字典figure.layout.yaxis2由空值变为&#123;‘anchor’:'x2','title':'分值'&#125;，其中&#123;‘anchor’:'x2'&#125;的意思是yaxis2坐标轴是与xaxis2坐标轴对应的。figure.layout.yaxis2,update(&#123;‘anchor’:'x2'&#125;) figure.layout.yaxis2,update(&#123;'title':'分值'&#125;) #设置figure的边界与标题figure.layout.margin.update(&#123;'t':50, 'b':100&#125;)#距离顶部50个单位，距离底部100个单位figure.layout.update（‘title’:'xxxxxxxx'）#标题 多个坐标轴 一幅图中多个图表的数据可能相差很大，所以要以不同的坐标标定。 双坐标轴123456789layout = go.Layout( title = 'Y 轴双轴示例'， yaxis = dict(title = 'yaxis 标题')， yaxis2 = dict(title = 'yaxis 标题',titlefont = dict(color = 'rgb(148, 103, 189)'), tickfont = dict(color = 'rgb(148, 103, 189)'), overlaying = 'y',side = 'right'), ) 关键的代码： titlefont用于设置标题格式，这里谁知yaxis2的标题颜色 tickfont 用于设置刻度格式，这里谁知yaxis2的标题颜色 overlaying是覆盖的意思，y表示覆盖y轴。 side的参数为top，bottom，left，right中的一种，表示坐标轴的位置，right表示右坐标轴，即yaxis2为右坐标轴。 多坐标轴 多坐标轴跟双坐标类似，在布局上多几个坐标轴的参数。12345678910111213141516171819202122232425262728293031 layout = go.Layout( title = 'Y 轴双轴示例'， yaxis = dict(title = 'yaxis 标题')， yaxis2 = dict(title = 'yaxis 标题',titlefont = dict(color = 'rgb(148, 103, 189)'), tickfont = dict(color = 'rgb(148, 103, 189)'), overlaying = 'y', side = 'right', anchor = ‘free’, position = 0.85 ), )``` 比较重要的是下面几行： overlaying = 'y', side = 'right', anchor = ‘free’,表示要绑定的坐标轴，如果为free，则其坐标轴由position的值指定， position = 0.85 #表示字啊0.85这个位置上是yaxis2所在的位置。## 多子图### 双子图方法一：```pythonfrom plotly import toolsfig = tools.make_subplots(row =2,cols=1)fig.append_trace(trace1,1,1)fig.append_trace(trace2,2,1)fig['layout'].update(height=600, width=600, title='i &lt; 3 subplots') 方法二： 用domain参数； 1234567891011layout = go.Layout( xaxis = dict( domain=[0,0.7] ), xaxis2=dict( domain = [0.8, 1] ), yaxis2=dict( anchor='x2' )) 多子图方法一： 123456789#用make_subplotfrom plotly import toolsfig = tools.make_subplots(row =2,cols=2，subplot_titles = ('Plot1', 'Plot2', 'Plot3', 'Plot4'))fig.append_trace(trace1, 1, 1)fig.append_trace(trace2, 1, 2)fig.append_trace(trace3, 2, 1)fig.append_trace(trace4, 2, 2) 方法二： 123456789101112131415161718192021222324252627282930layout = go.Layout( xaxis = dict( domain=[0,0.45] ), yaxis = dict( domain=[0,0.45] ), xaxis2=dict( domain = [0.55, 1] ), xaxis3=dict( domain=[0,0.45] anchor='y3' ) xaxis4=dict( domain=[0.55,1] anchor='y4' ) yaxis2 = dict( domain=[0,0.45] anchor='x2' ), yaxis3 = dict( domain=[0.55,1] ), yaxis4 = dict( domain=[0.55,1] anchor='x4' ),) 分割视图区间想为每个子图定义自己的大小，就涉及视图区间的分配问题，make_subplots方法为解决这个问题封装了一个参数specs，这个参数的简单使用： 123456789fig = tools.make_subplots(rows=2, cols=2, specs=[[&#123;&#125;, &#123;&#125;], [&#123;'colspan': 2&#125;, None]], subplot_titles=('First Subplot','Second Subplot', 'Third Subplot'))fig.append_trace(trace0, 1, 1)fig.append_trace(trace1, 1, 2)fig.append_trace(trace2, 2, 1)fig['layout'].update(showlegend=False, title='Specs with Subplot Title') spes参数定义了如何分配视图区间，本案例中的specs=[[{}, {}], [{‘colspan’: 2, None]}，表示第一行的两个子图平均分配区间，第二行的第一个子图占据2列的区间，更复杂的如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869fig = tools.make_subplots(rows=5, cols=2, specs=[[&#123;&#125;, &#123;'rowspan': 2&#125;], [&#123;&#125;, None], [&#123;'rowspan': 2, 'colspan': 2&#125;, None], [None, None], [&#123;&#125;, &#123;&#125;]], print_grid=True)fig.append_trace(trace1, 1, 1)fig.append_trace(trace2, 1, 2)fig.append_trace(trace3, 2, 1)fig.append_trace(trace4, 3, 1)fig.append_trace(trace5, 5, 1)fig.append_trace(trace6, 5, 2)fig['layout'].update(height=600, width=1000, title='specs examples')``` 把5*2的视图区间分配给6个子图。### 子图共享坐标轴方法一：```pythontrace1 = go.Scatter( x=[1, 2, 3], y=[2, 3, 4])trace2 = go.Scatter( x=[20, 30, 40], y=[5, 5, 5], xaxis='x2', yaxis='y')trace3 = go.Scatter( x=[2, 3, 4], y=[600, 700, 800], xaxis='x', yaxis='y3')trace4 = go.Scatter( x=[4000, 5000, 6000], y=[7000, 8000, 9000], xaxis='x4', yaxis='y4')data = [trace1, trace2, trace3, trace4]layout = go.Layout( xaxis=dict( domain=[0, 0.45] ), yaxis=dict( domain=[0, 0.45] ), xaxis2=dict( domain=[0.55, 1] ), xaxis4=dict( domain=[0.55, 1], anchor='y4' ), yaxis3=dict( domain=[0.55, 1] ), yaxis4=dict( domain=[0.55, 1], anchor='x4' ))fig = go.Figure(data=data, layout=layout)pyplt(fig, filename='tmp/subplot_shared_axes.html') 方法二：123456789101112131415161718192021222324252627282930313233from plotly import toolsimport plotly as pyimport plotly.graph_objs as gopyplt = py.offline.plottrace0 = go.Scatter( x=[1, 2, 3], y=[2, 3, 4])trace1 = go.Scatter( x=[20, 30, 40], y=[5, 5, 5],)trace2 = go.Scatter( x=[2, 3, 4], y=[600, 700, 800],)trace3 = go.Scatter( x=[4000, 5000, 6000], y=[7000, 8000, 9000],)fig = tools.make_subplots(rows=2, cols=2, shared_yaxes=True)fig.append_trace(trace0, 1, 1)fig.append_trace(trace1, 1, 2)fig.append_trace(trace2, 2, 1)fig.append_trace(trace3, 2, 2)fig['layout'].update(height=600, width=600, title='Multiple Subplots with Shared Y-Axes')pyplt(fig, filename='tmp/subplot_share_yaxes.html') 也可以设置两个坐标都共享：123456789101112131415161718192021222324252627from plotly import toolsimport plotly as pyimport plotly.graph_objs as gopyplt = py.offline.plottrace1 = go.Scatter( x=[0, 1, 2], y=[10, 11, 12])trace2 = go.Scatter( x=[2, 3, 4], y=[100, 110, 120],)trace3 = go.Scatter( x=[3, 4, 5], y=[1000, 1100, 1200],)fig = tools.make_subplots(rows=3, cols=1, specs=[[&#123;&#125;], [&#123;&#125;], [&#123;&#125;]], shared_xaxes=True, shared_yaxes=True, vertical_spacing=0.001)fig.append_trace(trace1, 3, 1)fig.append_trace(trace2, 2, 1)fig.append_trace(trace3, 1, 1)fig['layout'].update(height=600, width=600, title='Stacked Subplots with Shared X-Axes')pyplt(fig, filename='tmp/subplots_shared_xyaxes.html')]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>plotly高级图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python对象概览]]></title>
    <url>%2F2019%2F05%2F28%2FPython%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[plotly的对象除各种类型的图表外，还包括数据库连接和数据分析工具plotly的绘图对象包括以下类型 2D平面图表 3D立体图表 Maps，地图类型的图表 WebGL格式图表 Layout，画面布局函数 Axis，坐标工具，包括2D/3D平面坐标，立体坐标和极坐标（AngularAxis） Annotation，图表注释工具。 Error，误差调整工具，包括x、y、z三种坐标的误差修正 Figure，图形整合工具 Font，字体工具 Legend，图例工具 Margin，图表边缘间距工具 Marker，标记工具 金融行业通用的OHLC数据格式工具 Array，数据坐标列表 Data，图表数据整合工具 Stream，实时图表数据流工具 Scene，场景工具 2D平面绘图对象 Angularaxis，极坐标图表 Area，区域图 Bar，条形图 Box，盒形图 Candlestick与OHLC，金融股票行业常用的K线图与OHLC曲线图 ColorBar，彩条图 Contour，轮廓图（等高线图） Line，曲线图 Heatmap，热点图 Histogram，直方图 Histogram2d，2D平面直方图 Histogram2dContour，二维轮廓直方图 Pie，饼图 Scatter，坐标分布图（包括线形图，散点图）3D立体绘图对象 Scatter3D，3D立体散点图 Surface，表面图 Mesh3D，3D立体网格图 Poincloud，点云图Maps地图 ScatterGeo，基于GEO地图模式的散点图（包括线形图） Choropleth，立体等值线图 Scattermapbox，基于地图的散点图WebGL格式图形 ScatterGL，WebGL格式散点图（包括线形图）图表辅助工具 Annotation，图表注释工具。 Axis，坐标工具，包括2D/3D平面坐标，立体坐标和极坐标（AngularAxis） RadialAxis，纵横比调整工具 Scatterternary，散点三元图 Scene，场景工具 XBins、YBins：x轴，y轴辅助参数Layout画面布局函数 3D Axes，三维坐标（x轴，y轴，z轴） Axes，平面坐标（x轴，y轴） File Settings，文件设置 Horizontal Legends，水平标记 Images，插入图片，一般作为背景或地图数据 Inset Plots，插入图形 LaTeX，专业排版数据 Legends，图例设置 Logos，绘制格式标志 Multiple Axes，多轴设置 Setting Graph Size，设置图形的大小 Setting the Title，Legend Entries，and Axis Title，设置标题，图例调补和轴标题 Subplots，子图设置， Text and Annotations，文本和注释 Text and Font Styling ，文本和字体样式使用help命令可以查看Layout函数的参数与属性12import plotly.graph_objs as pygoprint(help(pygo.Layout))]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>plotly对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[plotly的动态可视化绘图05]]></title>
    <url>%2F2019%2F05%2F27%2Fplotly%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BB%98%E5%9B%BE05%2F</url>
    <content type="text"><![CDATA[面积图 面积图就是在曲线的下方有所填充。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import plotly as pyimport plotly.graph_objs as goimport numpy as nppyplt = py.offline.plots1 = np.random.RandomState(8) #定义局部种子s2 = np.random.RandomState(9) #定义局部rd1 = s1.rand(100)/10 - 0.02rd2 = s1.rand(100)/10 -0.002initial1 = 100000initial2 = 100000total1 = []total2 = []for i in range(len(rd1)): initial1 = initial1*rd1[i] +initial1 initial2 = initial2*rd2[i] + initial2 total1.append(initial1) total2.append(initial2) trace1 = go.Scatter( y = total1, fill = None, mode = 'lines', #none 无边界线 name = "策略1")trace2 = go.Scatter( y = total2, fill = 'tonexty', mode = 'lines', #none 无边界线 name = "策略2")data = [trace1, trace2]layout = dict( title = '策略净值曲线', xaxis = dict(title = '交易天数'), yaxis = dict(title = '净值'),)fig = dict(data = data, layout =layout)pyplt(fig,filename='basic_areal.html') 主要参数：fill，第一条线没有填充，None，第二条线的填充为tonexty. 直方图 用plotly绘制直方图用到graph_objs包中的Histogram函数。将数据赋值给函数中的变量x，即x=data，就可绘制直方图，若将数据赋值给y，则绘制水平直方图。histnorm是Histogram函数的另一个属性。用Numpy生成随机数。123456789101112131415 import plotly as pyimport plotly.graph_objs as goimport numpy as nppyplt = py.offline.plots1 = np.random.RandomState(1)x = s1.randn(1000)data = [go.Histogram( x=x, histnorm = 'probability')]pyplt(data,filename="basic_histogrm.html") 重叠直方图 将layout中设置barmode属性，将其改为‘overlay’,1layout = go.Layout(barmode = 'overlay') 层叠直方图将layout中设置barmode属性，将其改为‘stack’, 1layout = go.Layout(barmode = 'stack') 累计直方图 累计直方图是直方图的累积形式，即第n+1个区间的展示数目是第N-1个区间的展示数目与第n个区间中实际样本数目之和，通过设置Histogram函数中的cumulative属性实现，即cumulative = dict(enable = True)1234trace1 = [go.Histogram( x = x1 cumulative = dict(enable=True) )] 直方图参数解读 histnorm:设置纵坐标显示格式，可选的参数有“”，percent，probability，density histfunc：指定分组函数，可选的参数有count，sum，avg，min，max orientation：设置图形放向，有v和h两个参数，v表示垂直，h表示水平 cumulative：累计直方图参数，有enableed，directio和currentbin三个关键字。 autobinx：布尔型，是否自动划分区间 nbinsx：整形，最大显示区间数目 xbins：设置划分区间属性 饼图 Pie函数可绘制饼图1234567891011121314151617import plotly as pyimport plotly.graph_objs as goimport numpy as nppyplt = py.offline.plotlabels = ['股票','债券','现金','衍生品','其他']values = [33.7, 20.33, 9.9, 8.6, 27.47]trace = [go.Pie(labels = labels, values=values) ]layout = go.Layout( title = '基金资产配置比例图',)fig = go.Figure(data = trace, layout = layout)pyplt(fig,filename='basic_pie_chart.html') 环形饼图 绘制环形饼图，只需要在Pie函数中设置控制环形中心空白大小的hole属性即可实现。Pie函数中的hoverinfo属性用于控制当用户将鼠标指针放到环形图上显示的内容，设置为“label+percent”表示显示标签加数据所占的比例。123456trace = go.Pie( labels = labels, values = values, hole = 0.7, hoverinfo = "label+percent")])]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>plotly基础图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[plotly的动态可视化绘图04]]></title>
    <url>%2F2019%2F05%2F26%2Fplotly%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BB%98%E5%9B%BE04%2F</url>
    <content type="text"><![CDATA[柱状图示例代码：1234567891011121314151617181920import plotly as pyimport plotly.graph_objs as gopyplt = py.offline.plot#Tracetrace_basic = [go.Bar( x = ['Variable_1','Variable_2','Variable_3','Variable_4','Variable_5'], y = [1,2,3,2,4],)]#画柱状图#Layoutlayout_basic = go.Layout( title = 'The Graph Title', xaxis = go.XAxis(range = [-0.5,4.5], domain = [0,1]))#Figurefigure_basic = go.Figure(data = trace_basic, layout = layout_basic)# Plotpyplt(figure_basic,filename='Basic_BarChart.html') 代码go.Bar是画柱状图的函数，x是柱状图的名称，y是柱状图的值，layout是布局，range = [-0.5,4.5]代表y值的大小，大于-0.5，小于5；domain默认为[0,1] 柱状簇 将多个同类型的柱状图的数据叠加在一起即为柱状簇。 12345678910111213141516171819202122232425262728293031323334import plotly as pyimport plotly.graph_objs as gopyplt = py.offline.plot#Tracetrace0 = go.Bar( x = ["上海物贸","广东明珠","五矿发展"], y = [4.12, 5.32, 0.60], name = "201609")trace1 = go.Bar( x = ["上海物贸","广东明珠","五矿发展"], y = [3.65, 6.14, 0.58], name = "201612")trace2 = go.Bar( x = ["上海物贸","广东明珠","五矿发展"], y = [2.15, 1.35, 0.19], name = "201703")trace = [trace0,trace1,trace2]#Layoutlayout_basic = go.Layout( title = '国际贸易板块净资产收益率对比', #xaxis = go.XAxis(range = [-0.5,5]))#Figurefigure_basic = go.Figure(data = trace, layout = layout_basic)# Plotpyplt(figure_basic,filename='Basic_BarChart.html') 瀑布式柱状图 悬浮的式效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import plotly as pyimport plotly.graph_objs as gopyplt = py.offline.plotx_data = ['流动负债','非流动负债','负债','所有者权益','总资产']y_data = [56000000, 65000000,65000000,81000000,81000000]text = ['57,999,848万元','8,899,916万元','66,899,764万元','16,167,657万元','83,067,421万元']#Basetrace0 = go.Bar( x = x_data, y = [0,57999848,0,66899764,0], marker = dict( color = 'rgb(255,255,255)', ))#Tracetrace1 = go.Bar( x=x_data, y=[57999848, 889916, 66899764, 16167657, 83067421], marker=dict( color='rgb(55,128,191,0.7)', line = dict( color = 'rgba(55,128,191,1.0)', width = 2, ) ) )data = [trace0,trace1]layout = go.Layout( title = '万科A资产负债结构图', barmode = 'stack', showlegend = False)annotations = []for i in range(0,5): annotations.append(dict(x = x_data[i], y = y_data[i],text=text[i], font=dict(family='Arial', size = 14, color = 'rgb(245,246,249,1)'), showarrow = False)) layout['annotations'] = annotations#Figurefigure_basic = go.Figure(data = data, layout = layout)# Plotpyplt(figure_basic,filename='Basic_BarChart.html',image='png') trace0 中的y，表示第1,3,5根柱状图从0开始显示，第二根从57999848开始显示，第4根从66899764开始显示，将trace0所示的柱形设置为白色rgb(255,255,255) 图形样式设置 样式的设置主要是marker变量的设置。 123456789marker = dict( color = ['rgb....','rgb...'] line = dict( color = 'rgb...', width = 2, ) ) 水平条图形 水平条与柱状图类似，只需要在Bar函数中设置orientation=‘h’，x，y的数据交换。 12345go.Bar( x = [29.4, 34.62, 30.16], y = ['万科','国农','世纪']， orientation = 'h')]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>plotly基础图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[plotly的动态可视化绘图03]]></title>
    <url>%2F2019%2F05%2F25%2Fplotly%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BB%98%E5%9B%BE03%2F</url>
    <content type="text"><![CDATA[气泡图1、 基本绘制方法123456789101112131415161718192021import plotly as pyimport plotly.graph_objs as go#----pre defpyplt = py.offline.plot#-------------codetrace0 = go.Scatter( x = [1,2,3,4], y = [10,11,12,13], mode = 'markers', marker = dict( size = [40,60,80,100],#定义每个点的大小 ) )data = [trace0]pyplt(data, filename="bubble_basice_demo.html") 2、 样式的设置1234567891011121314trace0 = go.Scatter( x = [1,2,3,4], y = [10,11,12,13], mode = 'markers', text = ['A&lt;br&gt;size:40','B&lt;br&gt;size:60','C&lt;br&gt;size:80','D&lt;br&gt;size:100'], marker = dict( color = [120, 125, 130, 135], opacity = [1, 0.8, 0.6, 0.4], size = [40,60,80,100], showscale = True, ) ) text指定每一个对应的悬浮文字（ 表示换行），color指定每个点的颜色，opacity指定每个点的透明度，size指定每个点的大小，showscale = Ture 表示显示右边的颜色条的大小。 3、 缩放设置 调节气泡尺寸大小可以通过sizeref参数进行设置，当sizeref值大于1时，将减小气泡的大小，当小于1时，将增大气泡大小。123456789101112131415161718192021222324252627282930313233343536373839404142trace0 = go.Scatter( x = [1,2,3,4], y = [10,11,12,13], mode = 'markers', name = 'default', text = ['A&lt;/br&gt;size:40&lt;/br&gt;default','B&lt;/br&gt;size:60&lt;/br&gt;default','C&lt;/br&gt;size:80&lt;/br&gt;default','D&lt;/br&gt;size:100&lt;/br&gt;default'], marker = dict( size = [400,600,800,1000], sizemode = 'area', ) )trace1 = go.Scatter( x=[1, 2, 3, 4], y=[14, 15, 16, 17], mode='markers', name='default', text=['A&lt;/br&gt;size:40&lt;/br&gt;sizeref:0.2', 'B&lt;/br&gt;size:60&lt;/br&gt;sizeref:0.2', 'C&lt;/br&gt;size:80&lt;/br&gt;sizeref:0.2', 'D&lt;/br&gt;size:100&lt;/br&gt;sizeref:0.2'], marker=dict( size=[400, 600, 800, 1000], sizeref = 0.2, sizemode='area', ))trace2 = go.Scatter( x=[1, 2, 3, 4], y=[20, 21, 22, 23], mode='markers', name='default', text=['A&lt;/br&gt;size:40&lt;/br&gt;sizeref:2', 'B&lt;/br&gt;size:60&lt;/br&gt;sizeref:2', 'C&lt;/br&gt;size:80&lt;/br&gt;sizeref:2', 'D&lt;/br&gt;size:100&lt;/br&gt;sizeref:2'], marker=dict( size=[400, 600, 800, 1000], sizeref = 2, sizemode='area', )) sizeref=2表示将气泡大小设置为原来的1/2,；参数sizemode有diameter和area两个值，diameter表示按直径缩放，area表示按面积缩放 参数解读 ：详情参考：https://plot.ly/python/reference/#scatter-marker-sizeref text：列表，元素为相应节点的悬浮文字内容 marker：数据节点参数，包括大小，颜色，格式等 size：列表，元素为相应节点的悬浮文字内容 sizeref：缩放比例，如设置为2，则缩小为原来的1/2 sizemode：缩放的标准，默认以diameter（直径缩放），也可以area（面积缩放）。 color：列表，元素为相应节点的颜色 showscale：默认为FALSE，不显示右侧的颜色条，TRUE显示 opacity：列表，元素为0~1之间的数，表示相应节点的透明度 线形图1、 基本案例1234567891011121314151617181920212223import plotly as pyimport plotly.graph_objs as goimport pandas as pdpyplt = py.offline.plotprofit_rate = [-0.001,-0.013,0.004,0.002,0.003,-0.001,-0.009,0.0,0.007,-0.005,0.0,0.001,-0.006,-0.006,-0.009,-0.013,0.005,0.007,0.004,-0.006,-0.009,-0.004,0.015,0.007,0.001,0.003,-0.009,-0.005,0.001,-0.008,-0.016,0.002,-0.013,-0.009,-0.014,0.009,-0.003,0.002,-0.001,0.011,0.004]date = pd.date_range(start = '3/1/2017', end = '4/30/2017')trace = [go.Scatter( x =date, y = profit_rate)]layout = dict( title = '浦发银行20170301-20170428涨跌幅变化', xaxis =dict(title = 'Date'), yaxis = dict(title = 'profit_rate'))fig = dict(data = trace, layout = layout)pyplt(fig, filename='basic-line.html') 数据缺口与连接 数据集往往并不完美，可能有缺失的数据，在plotly中可以通过设置Scatter函数中的connectgaps属性来显示这些数据缺口或对缺口进行连接。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import plotly as pyimport plotly.graph_objs as goimport pandas as pdpyplt = py.offline.plotmonth = ['January', 'February','March','April','May','June','July','August','September','October','November','December'] #x轴坐标high_2000 = [32.5,37.6,49.9,53.0,None,75.4,76.5,76.6,70.7,60.6,45.1,29.3]low_2000 = [13.8,22.3,32.5,37.2,None,56.1,57.7,58.3,51.2,42.8,31.6,15.9]high_2007 = [36.5,26.6,43.6,52.3,None,81.4,80.5,82.2,76.0,67.3,46.1,35.0]low_2007 = [23.6,14.0,27.0,36.8,None,57.7,58.9,61.2,53.3,48.5,31.0,23.6]high_2014 = [28.8,28.5,37.0,56.3,None,79.7,78.5,77.8,74.1,62.6,45.3,39.9]low_2014 = [12.7,14.3,18.6,35.5,None,58.0,60.0,58.6,51.7,45.2,32.2,29.1]trace0 = go.Scatter( x =month, y = high_2014, name = 'High 2014', line = dict( color = ('rgb(205, 12, 24)'), width = 4 ) , connectgaps = True )trace1 = go.Scatter( x=month, y=low_2014, name='low_2014 2014', line=dict( color=('rgb(22, 96, 167)'), width=4 ), connectgaps=False)trace2 = go.Scatter( x=month, y=high_2007, name='high_2007 ', line=dict( color=('rgb(205, 12, 24)'), width=4, dash = 'dash' #虚线（断线），dot虚线（点），dashdot ), connectgaps=False)trace3 = go.Scatter( x=month, y=low_2007, name='low_2007', line=dict( color=('rgb(22, 96, 167)'), width=4, dash = 'dash' ), connectgaps=False)trace4 = go.Scatter( x=month, y=high_2000, name='high_2000', line=dict( color=('rgb(205, 12, 24)'), width=4, dash = 'dot' ), connectgaps=False)trace5 = go.Scatter( x=month, y=low_2000, name='low_2000', line=dict( color=('rgb(22, 96, 167)'), width=4, dash = 'dot' ), connectgaps=False)data = [trace0, trace1, trace2, trace3, trace4,trace5]layout = dict( title = 'Average High and Low Temperatures in New York', xaxis =dict(title = 'Month'), yaxis = dict(title = 'Temperature(degrees F)'))fig = dict(data = data, layout = layout)pyplt(fig, filename='styled-line.html') 数据中缺失的数据设置为None。在Scatter函数中，设置connectgaps属性为False，表示不连接，显示接口，Ture表示为连接。Scatter函数中的line属性用于对线形图形的样式控制；color控制颜色，width设置宽度；dash用于设置类型，dash表示有短线组成的虚线，dot表示由点组成的虚线，dashdot表示由点和短线组成的虚线。 数据插值 调整Scatter函数line属性中的shape值可以对插值的方法进行控制，完成数据点的插值设置。插值的方法就是根据已有的零散数据点，找到一条满足一定条件的曲线，使之经过全部的数据点。plotly提供6种插值的方法。分别是‘linear’，‘spline’，‘hv’，‘vh’，‘hvh’，‘vhv’。如：shape：‘spline’12345678910111213trace5 = go.Scatter( x=month, y=low_2000, name='low_2000', line=dict( color=('rgb(22, 96, 167)'), width=4, shape = 'linear' #直线连接 ), connectgaps=False) 填充线形图 要绘制恒宝股份在一段时间内的最高价与最低价，每条可见线对应股票的开盘价，线条的上影线对应当天的最高价，线条的下影线对应当天的最低价。要绘制这样的图，先把其拆分为两部分，一部分是对3条可见线的绘制，另一部分是对三条填充线进行绘制。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#完成了对三条填充线进行绘制x = x + x_rev,#（x只给了10个数据）是从0到10，再从10到1的逆序y = y1_upper+y1_lower, # 从第一天的最高价到第10天的最高价，再从第10天到第1天的最高价的序列fill = 'tozerox',fillcolor = 'raba(0,0,205,0.2)',line = go.Line(color = 'transparent')#color属性为 'transparent'，对线条进行隐藏#其中y1_lower = y1_lower[ : : -1] 逆序，x_rev = x[::-1]#设置数据轨迹trace1 = go.Scatter( x = x + x_rev,#（x只给了10个数据）是从0到10，再从10到1的逆序 y = y1_upper+y1_lower, # 从第一天的最高价到第10天的最高价，再从第10天到第1天的最高价的序列 fill = 'tozerox', fillcolor = 'raba(0,0,205,0.2)', line = go.Line(color = 'transparent')#color属性为 'transparent'，对线条进行隐藏 showlegend = False,#布尔变量，用于切换图标显示 name = '恒宝股份')trace2 = go.Scatter( x = x, y = y1, line = go.Line(color = 'reb(0,0,205)') mode = 'line', name = '恒宝股份')#布局layout = go.Layout( paper_bgcolor = 'rgb(255,255,255)', plot_bgcolor = 'rgb(229,229,229)', xaxis = go.XAxis( gridcolor = 'rgb(255,255,255)', range = [1,10], showgrid = Ture, showline = False, showticklabels = TRUE, tickcolor = 'rgb(127,127,127)', ticks = 'outside', zeroline = False ), yaxis = go.YAxis( gridcolor = 'rgb(255,255,255)', showgrid = Ture, showline = False, showticklabels = TRUE,#显示坐标标记 tickcolor = 'rgb(127,127,127)', ticks = 'outside', zeroline = False ))]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>plotly基础图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[plotly的动态可视化绘图02]]></title>
    <url>%2F2019%2F05%2F24%2Fplotly%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BB%98%E5%9B%BE02%2F</url>
    <content type="text"><![CDATA[散点图 plotly没有独立的线形图函数，而是把线形图与散点图全部用Scatter函数实现。 散点图和线图的混合1234567891011121314151617181920212223242526272829303132333435363738394041import plotly as pyimport plotly.graph_objs as go#--------pre defpyplt = py.offline.plot#-------code# Create random data with numpyimport numpy as npN = 100random_x = np.linspace(0,1,N)random_y0 = np.random.randn(N) + 5random_y1 = np.random.randn(N)random_y2 = np.random.randn(N) - 5#Create tracestrace0 = go.Scatter( x = random_x, y = random_y0, mode = 'markers', #纯散点图的绘制 name = 'markers' #曲线名称)trace1 = go.Scatter( x=random_x, y=random_y1, mode='lines+markers', # 散点+线 图的绘制 name='lines+markers' # 曲线名称 )trace2 = go.Scatter( x=random_x, y=random_y2, mode='lines', # 线 图的绘制 name='lines' # 曲线名称)data = [trace0, trace1,trace2]pyplt(data,filename='scatter_basic_demo.html') markers、lines、lines+markers三个图形的输出格式不同，是因为Scatter函数中的mode参数不同， 样式的设置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import plotly as pyimport plotly.graph_objs as go# --------pre defpyplt = py.offline.plot# -------code# Create random data with numpyimport numpy as npN = 500x = np.linspace(0, 1, N)random_y0 = np.random.randn(N) + 5random_y1 = np.random.randn(N)random_y2 = np.random.randn(N) - 5# Create tracestrace0 = go.Scatter( x=np.random.randn(N), y=np.random.randn(N)+2, mode='markers+lines', # 纯散点图的绘制 name='above', # 曲线名称 marker = dict( size = 10,#设置点的宽度 color = 'rgba(152, 0, 0, .8)',#设置点的颜色 line = dict( width = 2, #设置线条的宽度 color = 'rgb(0, 0, 0)' #设置线条的颜色 ) ) )trace1 = go.Scatter( x=np.random.randn(N), y=np.random.randn(N) - 2, mode='markers', # 散点+线 图的绘制 name='Below', # 曲线名称 marker = dict( size = 10,#设置点的宽度 color = 'rgba(255, 182, 193, .9)',#设置点的颜色 line = dict( width = 2, #设置线条的宽度 ) ))data = [trace0, trace1]layout = dict( title = 'Styled Scatter', yaxis = dict(zeroline = True), xaxis = dict(zeroline = False))fig = dict(data=data, layout = layout)pyplt(fig, filename='scatter_basic_demo.html') 使用Scatter函数可以绘制线形图与散点图，主要参数如下; connectgaps:布尔变量，用于连接缺失数据 dx、dy:x、y坐标的步进值，默认值是1= error_x,error_y:x,y出错信息 fillcolor：填充模式 hoverfinfo：当用户与图形互动时，鼠标指针显示的参数，包括x，y，z坐标数据，以及text（文字信息），name（图形名称）等参数的组合，可使用+，all，none和skip（忽略）作为组合连接符号，默认是all（全部消失） hoveron：当用户与图形互动时，鼠标指针显示的模式，包括points（点图），fills（填充图）和points+fills三种模式 ids：在动画图表中数据点和图形key键的列表参数。 legendgroup：图例参数，默认是空字符串 line：线条参数，包括大小，颜色，格式等 marker：数据节点参数，包括大小，颜色，格式等 mode ： 图形格式，包括lines，marker，text，使用+或none等符号进行模式组合 name：名称参数 opacity：透明度参数，范围是0~1 rsrc，xsrc，ysrc，tsrc，idssrc，textsrc，textpositionsrc：字符串源数列表 r、t：仅用与极坐标图，r用于设置径向坐标（半径），t用于设置角坐标 showlegend：布尔变量，用于切换图标显示 stream：数据流，用于实时显示数据图表 textfont：文本字体参数，包括字体名称，颜色，大小等 textposition：“文本”元素的位置参数，包括top left（） text:文本数据 type：数据显示模式 constant，percent，sqrt，array（数组） x0,y0:坐标起点坐标 xaxis，yaxis：x，y坐标参数 xcalendar，ycalender：坐标时间参数的格式，默认是公历。 x，y：设置坐标x，y轴的坐标数据]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>plotly基础图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[plotly的动态可视化绘图01]]></title>
    <url>%2F2019%2F05%2F23%2Fplotly%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BB%98%E5%9B%BE01%2F</url>
    <content type="text"><![CDATA[plotly安装12pip install plotypip install ploty --upgrade #更新plotly 查看帮助 12import plotly help(plotly.offline.plot) 离线绘图函数123456789101112131415161718import plotly as pyfrom plotly.graph_objs import Scatter, Layout, Datapy.offline.init_notebook_mode() #该条语句是在Jupyter Notebook（此前被称为 IPython notebook）中绘图trace0 = Scatter( #确定坐标 x，y x = [1,2,3,4,], y = [10,15,12,17])trace1 = Scatter( x = [1,2,3,4,], y = [16,5,11,9])data = Data([trace0, trace1])#两条线#py.offline.iplot(data, filename='first_offline_start') IPlot是在Notebook中绘图的函数py.offline.plot(data, filename='first_offline_start')#py.offline.plot(data, filename='first_offline_start',image='png')#保存画出的png图片 参数解释： def plot(figure_or_data, show_link=False, link_text=’Export to plot.ly’, validate=True, output_type=’file’, include_plotlyjs=True, filename=’temp-plot.html’, auto_open=True, image=None, image_filename=’plot_image’, image_width=800, image_height=600, config=None, include_mathjax=False, auto_play=True, animation_opts=None): py.plot是绘制图形的主函数，主要参数如下： figure_or_data：绘图的数据 show_link:默认为False，显示右下角的链接 link_text:右下角显示的文字，默认为Export to plotly.ly validate:确保所有关键字是有效的。但是当需要额外、非必须的关键字或plo.js版本比graph_reference.json版本旧时，会忽略这部分内容。 filename：设置绘图结果的存储路径。 image_filename：保存绘制的图片(.png ) 格式 模块解释 plotly模块库里的graph_obj（图像对象）子模块的Scatter（数据布局）对象定义，跟函数和对象一样是字典格式。 Data函数，把代表两条曲线的变量定义为一组图形数据，一列表的格式[]。 基本绘图流程 添加图规数据（add_trace）,使用的是Scatter等函数命令 设置画面布局，使用layout命令 集成图形，布局数据，命令有Data，Figure。 绘制图形的输出，命令是offline.plot,自定义的短命令是pyplt。]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>plotly模块开始</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Altium Designer学习笔记01]]></title>
    <url>%2F2019%2F05%2F18%2FAltium-Designer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%2F</url>
    <content type="text"><![CDATA[Altium Designer15的安装1、 安装包在百度网盘中Altium Designer文件夹下安装教程参考：https://wenku.baidu.com/view/63535606b9d528ea81c7799e.html https://wenku.baidu.com/view/60bd5b9c6c175f0e7cd137bb.html 2、 基本快捷键 shift+S :切换单层显示和多层显示 L ： 调出底层的器件 shift+ctrl+单击 ： 高亮光标所在的已连接网络 视频教程：b站上有基础的教程很完整可以参考。]]></content>
      <categories>
        <category>画PCB板学习</category>
      </categories>
      <tags>
        <tag>Altium Designer15</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python出错ModuleNotFoundError: No module named 'sklearn.cross_validation']]></title>
    <url>%2F2019%2F04%2F28%2Fpython%E5%87%BA%E9%94%99ModuleNotFoundError-No-module-named-sklearn-cross-validation%2F</url>
    <content type="text"><![CDATA[12from sklearn.cross_validation import KFoldfrom sklearn.cross_validation import train_test_split sklearn更新后在执行以上代码时可能会出现这样的问题：1ModuleNotFoundError: No module named 'sklearn.cross_validation' 此时可以考虑使用以下方法导入库：12from sklearn.model_selection import KFoldfrom sklearn.model_selection import train_test_split 此时就不会报错了。]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码库常见错误]]></title>
    <url>%2F2019%2F04%2F14%2F%E4%BB%A3%E7%A0%81%E5%BA%93%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[Git新建分支出现fatal: Not a valid object name: ‘master’错误 原因是没有提交一个对象，要先commit之后才会真正建立master分支，此时才可以建立其它分支。 123456git add c++git commot -m "提交c++"#然后创建分支git branch wapgit branch -a #查看分支 出现error: The following untracked working tree files would be overwritten by checkout pull代码出现error: The following untracked working tree files would be overwritten by checkout $ git clean -d -fx “” Git使用之(pathspec master did not match any file(s) known to git) 不能查看分支git checkout master提示如下错误:error: pathspec ‘master’ did not match any file(s) known to git 解决1.首先我们看一下分支情况:git branch -a2.如果没有看到你想要的分支,先获取所有分支:git fetch 需要注意的是: 和push不同, fetch会自动获取远程 `新加入’ 的分支. 执行git push出现”Everything up-to-date”在github上git clone一个项目，在里面创建一个目录，然后git push的时候，出现报错”Everything up-to-date” 原因：1）没有git add .2）没有git commit -m “提交信息”如果上面两个步骤都成功执行，还出现这个错误是因为创建的目录下是空的，目录下必须有文件才能git push上传成功。在github上创建文件的时候，在新文件名后加/符号就是文件夹，但是这种方式只支持英文名目录，中文名目录不支持。 对于在git上面拉代码报”error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054”解决方法主要原因是安全设置的问题：首先执行git config http.sslVerify “false” 若出现下列错误git config http.sslVerify “false” fatal: not in a git directory再继续执行 git config –globle http.sslVerify “false” 问题解决]]></content>
      <categories>
        <category>代码托管</category>
      </categories>
      <tags>
        <tag>github代码库错误总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建自己的github代码库]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84github%E4%BB%A3%E7%A0%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[我的代码库 网址： https://github.com/coder-zhanglei/zhanglei.github.io.git 参考的博客： https://www.cnblogs.com/zhixi/p/9584624.html 准备工作1、 在github上创建自己账号，建立自己的代码库，已完成2、 安装git软件，下载地址：https://windows.github.com/ 或 https://git-scm.com/download/win注：安装好git后右键就有Git Bash Here可以打开git上传下载文件的框 基本配置1、 添加本地目录到远程仓库 在你的本地文件目录下右击，就会出现Git Bash选项，点击进入。2、 设置用户名和邮箱地址。这两个值是作为上传时记录的值。输入命令： 1234 git config --global user.name "用户名" git config --global user.email "邮箱"#设置好后可以用命令查看当前的设置：git config --global user.name 下载和上传远程仓库的文件1、 首先初始化本地仓库 1git init 注：会生成.git的隐藏文件。没有生成就是没初始化成功 2、 连接远程仓库 12git remote add origin "https://github.com/GitHub用户名/代码仓库名称.git"git remote add origin https://github.com/coder-zhanglei/zhanglei.github.io.git 可以通过git remote -v 查看本地链接到的远程仓库1git remote -v 若分支设置错误，可以查看后切换分支【git remote rm origin】 删除现有远程仓库【git remote add origin url】添加新远程仓库 12git remote rm origingit remote add origin url 下载1、 从远程仓库拉取所有更新（每次上传项目都要操作） 1git pull origin master 注意：此处极易报错！ 因为远程代码仓库和本地代码仓库合并后，可能会有冲突，如有报错，使用git status查看状态 pull，因为两个仓库不同，发现refusing to merge unrelated histories，无法pull 因为他们是两个不同的项目，要把两个不同的项目合并，git需要添加一句代码，在git pull，这句代码是在git 2.9.2版本发生的，最新的版本需要添加–allow-unrelated-historiesgit pull origin master –allow-unrelated-histories 注：在 git pull origin master –allow-unrelated-histories此步操作时，.gitignore文件错误冲突并没有解决，只是强制合并忽略掉了 创建分支，上传文件 因为git是分布式管理，所以尽量不要在master主分支上作开发，例如自己有一个项目，在外面开发时，可以使用分支1，在家开发时可以使用分支2，如果有其他人参入 ，分别 使用分支3，4，5每次提交本地代码时候，先合并远程master主分支到本地，再提交 1、 创建本地分支 1git branch 分支名 2、 切换本地分支1git checkout 分支名 3、 本地分支提交 123git add .git commit -m ‘dev'git push -u origin dev 4、 合并本地分支到master 12345678910111213 git checkout master git pull origin master git merge origin/master //合并分支 git status On branch masterYour branch is ahead of 'origin/master' by 12 commits. (use "git push" to publish your local commits)nothing to commit, working tree clean #上面的意思就是你有12个commit，需要push到远程master上 #执行下面命令即可 git push origin master 上传指令的区别$ git push origin 上面命令表示，将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。$ git push 如果当前分支与多个主机存在追踪关系，那么这个时候-u选项会指定一个默认主机，这样后面就可以不加任何参数使用git push。$ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。 仓库的管理 删除仓库，参考博客：https://blog.csdn.net/weixin_42152081/article/details/80635777 分支的管理 ：参考博客：https://blog.csdn.net/wankui/article/details/53328369 一.删除已有仓库 如果我们想要删除Github中没有用的仓库，应该如何去做呢？ 进入到我们需要删除的仓库里面，找到“settings”即仓库设置： 然后，在仓库设置里拉到最底部，找到“Danger Zone”即危险区域： 点击“Delete this repository”这样就可以删除该仓库了。 二.删除Github中的某个文件或文件夹 1.本地仓库和远程仓库同时删除 例如要删除如图所示的_config.yml和index.md两个文件： 我们先在本地把两个文件删除，然后执行以下命令： 123git add * //把本地仓库的文件上传到缓存。git commit -m 'del' //把第一步上传到缓存的东西上传到本地仓库，其中'del'是操作标识，内容随便填，方便用户观看。git push origin master //把本地仓库的文件上传到远程仓库。 这样，再打开远程仓库就可以看到两个文件已经被删除了： 列几个常用的git命令git init 项目初始化git clone 拉取项目git add . 添加到暂存区git commit -m 添加commit信息git push 将本地分支推送到服务器上去git pull origin master 本地与服务器端同步 git log 查看日志git status 查看当前状态git tag 查看版本号git diff 查看尚未提交的更新 git fetch：相当于是从远程获取最新版本到本地，不会自动mergeGit log -p master..origin/master 比较本地的master分支和origin/master分支的差别查看对比一下 ，具体效果这里就不贴了，各位可以自行测试git merge origin/master 进行合并 需要注意的是: 和push不同, fetch会自动获取远程`新加入’的分支.]]></content>
      <categories>
        <category>代码托管</category>
      </categories>
      <tags>
        <tag>创建自己的代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github和gitlab]]></title>
    <url>%2F2019%2F04%2F12%2Fgithub%E5%92%8Cgitlab%2F</url>
    <content type="text"><![CDATA[github和gitlab的相同点 二者都是基于web的Git仓库，在很大程度上GitLab是仿照GitHub来做的，它们都提供了分享开源项目的平台，为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。GitHub同时提供公共仓库和私有仓库，但如果要使用私有仓库，是需要付费的。而GitLab解决了这个问题，你可以在上面创建私人的免费仓库。 github和gitlab的不相同点 GitHub同时提供公共仓库和私有仓库，但如果要使用私有仓库，是需要付费的。而GitLab解决了这个问题，你可以在上面创建私人的免费仓库。GitLab让开发团队对他们的代码仓库拥有更多的控制，相比于GitHub，它有不少的特色： 允许免费设置仓库权限； 允许用户选择分享一个project的部分代码 允许用户设置project的获取权限，进一步的提升安全性；可以设置获取到团队整体的改进进度；通过innersourcing让不在权限范围内的人访问不到该资源。 从代码私有性方面来看，有时公司并不希望员工获取到全部的代码，这个时候GitLab无疑是更好的选择。但对于开源项目而言，GitHub依然是代码托管的首选。]]></content>
      <categories>
        <category>代码托管</category>
      </categories>
      <tags>
        <tag>github和gitlab的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的安装]]></title>
    <url>%2F2019%2F04%2F11%2Fpython%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Python的下载Python 下载链接：https://www.python.org/downloads/注：点击下载链接后跳转页面，在页面的files标题下选择下载的版本 Linux或unix下Python 下载链接：https://www.python.org/ftp/python/ 安装Anaconda anaconda是一个针对科学设计的多合一安装包：包括Python本体，标准库以及许多实用的第三方库。下载链接：https://repo.continuum.io/archive/ anaconda将所有文件都安装到属于它自己的目录中。不需要特殊的权限来执行安装]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python并发和网络]]></title>
    <url>%2F2019%2F04%2F10%2Fpython%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[进程和线程 使用线程来解决I/O限制问题 使用进程、网络或事件来处理cpu问题标准库中有一个Queue函数。 multiprocessing包 multiprocessing包是Python中的多进程管理包。与threading.Thread类似，它可以利用multiprocessing.Process对象来创建一个进程。该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有start(), run(), join()的方法。此外multiprocessing包中也有Lock/Event/Semaphore/Condition类 (这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。但在使用这些共享API的时候，我们要注意以下几点: 在UNIX平台上，当某个进程终结之后，该进程需要被其父进程调用wait，否则进程成为僵尸进程(Zombie)。所以，有必要对每个Process对象调用join()方法 (实际上等同于wait)。对于多线程来说，由于只有一个进程，所以不存在此必要性。 multiprocessing提供了threading包中没有的IPC(比如Pipe和Queue)，效率上更高。应优先考虑Pipe和Queue，避免使用Lock/Event/Semaphore/Condition等同步方式 (因为它们占据的不是用户进程的资源)。 多进程应该避免共享资源。在多线程中，我们可以比较容易地共享资源，比如使用全局变量或者传递参数。在多进程情况下，由于每个进程有自己独立的内存空间，以上方法并不合适。此时我们可以通过共享内存和Manager的方法来共享资源。但这样做提高了程序的复杂度，并因为同步的需要而降低了程序的效率。 Process.PID中保存有PID，如果进程还没有start()，则PID为None。window系统下，需要注意的是要想启动一个子进程，必须加上那句if _ _ name _ _ == “main”，进程相关的要写在这句下面。 简单创建多进程 有两种使用方法，直接传入要运行的方法或从Process继承并覆盖run()： 12345678910111213141516171819202122232425262728293031from multiprocessing import Processimport threadingimport timedef foo(i): print 'say hi', iif __name__ == '__main__': for i in range(10): p = Process(target=foo, args=(i,)) p.start()# 方法二from multiprocessing import Processimport timeclass MyProcess(Process): def __init__(self, arg): super(MyProcess, self).__init__() self.arg = arg def run(self): print 'say hi', self.arg time.sleep(1) if __name__ == '__main__': for i in range(10): p = MyProcess(i) p.start() Process类 构造方法： def _ _ init _ _ (self, group=None, target=None, name=None, args=(), kwargs={}): group: 线程组，目前还没有实现，库引用中提示必须是None； target: 要执行的方法； name: 进程名； args/kwargs: 要传入方法的参数。 注：一般是用 target和args/kwargs 实例方法： is_alive()：返回进程是否在运行。 join ( [ timeout ] )：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。 start()：进程准备就绪，等待CPU调度 run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。 terminate()：不管任务是否完成，立即停止工作进程 属性： authkey daemon：和线程的setDeamon功能一样 exitcode(进程在运行时为None、如果为–N，表示被信号N结束） name：进程名字。 pid：进程号。daemon属性： 如果某个子线程的daemon属性为False，主线程结束时会检测该子线程是否结束，如果该子线程还在运行，则主线程会等待它完成后再退出； 如果某个子线程的daemon属性为True，主线程运行结束时不对这个子线程进行检查而直接退出，同时所有daemon值为True的子线程将随主线程一起结束，而不论是否运行完成。 属性daemon的值默认为False，如果需要修改，必须在调用start()方法启动线程之前进行设置。另外要注意的是，上面的描述并不适用于IDLE环境中的交互模式或脚本运行模式，因为在该环境中的主线程只有在退出Python IDLE时才终止。 Pool类 进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。进程池设置最好等于CPU核心数量 构造方法： def Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None): Pool( [ processes[, initializer[, initargs[, maxtasksperchild[, context] ]]]]) processes ：使用的工作进程的数量，如果processes是None那么使用 os.cpu_count()返回的数量。 initializer： 如果initializer是None，那么每一个工作进程在开始的时候会调用initializer(*initargs)。 maxtasksperchild：工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来替代原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。 context: 用在制定工作进程启动时的上下文，一般使用 multiprocessing.Pool() 或者一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context实例方法： apply(func[, args[, kwds]])：同步进程池 apply_async(func[, args[, kwds[, callback[, error_callback]]]]) ：异步进程池 close() ： 关闭进程池，阻止更多的任务提交到pool，待任务完成后，工作进程会退出。 terminate() ： 结束工作进程，不在处理未完成的任务 join() : wait工作线程的退出，在调用join()前，必须调用close() or terminate()。这样是因为被终止的进程需要被父进程调用wait（join等价与wait），否则进程会成为僵尸进程。pool.join()必须使用在 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 #例子一（异步进程池）：#pool.close()或者pool.terminate()之后。其中close()跟terminate()的区别在于close()会等待池中的worker进程执行结束再关闭pool,而terminate()则是直接关闭。# coding:utf-8from multiprocessing import Poolimport timedef Foo(i): time.sleep(2) return i + 100def Bar(arg): print argif __name__ == '__main__': t_start=time.time() pool = Pool(5) for i in range(10): pool.apply_async(func=Foo, args=(i,), callback=Bar)#维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去 pool.close() pool.join() # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。 pool.terminate() t_end=time.time() t=t_end-t_start print 'the program time is :%s' %t ###例子二（同步进程池）： # -*- coding:utf-8 -*-from multiprocessing import Process, Poolimport timedef Foo(i): time.sleep(1) print i + 100if __name__ == '__main__': t_start=time.time() pool = Pool(5) for i in range(10): pool.apply(Foo, (i,)) pool.close() pool.join() # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。 t_end=time.time() t=t_end-t_start print 'the program time is :%s' %t ##例子三：异步进程池使用get()方法获得进程执行结果值（错误使用get（）方法获取结果）def Bar(arg): return argif __name__ == '__main__': t_start=time.time() pool = Pool(5) for i in range(10): res = pool.apply_async(func=Foo, args=(i,), callback=Bar)#维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去 print res.get() ###错误使用get pool.close() pool.join() # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。 pool.terminate() t_end=time.time() t=t_end-t_start print 'the program time is :%s' %t ###例子四（正确使用get（）方法获取结果） # coding:utf-8from multiprocessing import Poolimport timedef Foo(i): time.sleep(2) return i + 100def Bar(arg): return argif __name__ == '__main__': res_list=[] t_start=time.time() pool = Pool(5) for i in range(10): res = pool.apply_async(func=Foo, args=(i,), callback=Bar) res_list.append(res) ##正确使用get pool.close() pool.join() for res in res_list: print res.get() t_end=time.time() t=t_end-t_start print 'the program time is :%s' %t 进程数据共享 方法一（使用Array）：Array(‘i’, range(10))中的‘i’参数C语言中的类型：‘c’: ctypes.c_char ‘u’: ctypes.c_wchar ‘b’: ctypes.c_byte ‘B’: ctypes.c_ubyte‘h’: ctypes.c_short ‘H’: ctypes.c_ushort ‘i’: ctypes.c_int ‘I’: ctypes.c_uint‘l’: ctypes.c_long, ‘L’: ctypes.c_ulong ‘f’: ctypes.c_float ‘d’: ctypes.c_double1234567891011121314from multiprocessing import Process, Arraydef f(a): for i in range(len(a)): a[i] = -a[i]if __name__ == '__main__': arr = Array('i', range(10)) p = Process(target=f, args=(arr,)) p.start() p.join() print(arr[:]) 方法二（使用Manager）：Manager()返回的manager提供list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array类型的支持。 12345678910111213141516171819from multiprocessing import Process, Managerdef f(d, l): d[1] = '1' d['2'] = 2 d[0.25] = None l.reverse()if __name__ == '__main__': with Manager() as manager: d = manager.dict() l = manager.list(range(10)) p = Process(target=f, args=(d, l)) p.start() p.join() print(d) print(l) 网络 IP:本机IP地址一直是：127.0.0.1 ，名称一直为localhost 套接字 Python套接字编程教程（ https://docs.python.org/3/howto/sockets.html ） udp-服务器代码：服务器必须用socket包的两个方法来建立网络连接12345678910111213141516from datetime import datetimeimport socketserver_address = ('localhost', 6789)max_size = 4096 print 'starting the server at',datetime.now()print 'waiting for a client to call'server = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #创建一个套接字，SOCK_DGRAM表示发送的数据报，表示用UDPserver.bind(server_address) #绑定套接字data,client = server.recvfrom(max_size) #接收数据print ('At',datetime.now(), client, 'said', data)server.sendto(b'Are you talking to me?',client) #发送数据server.close() UDP-client代码：123456789101112131415from datetime import datetimeimport socketserver_address = ('localhost', 6789)max_size = 4096 print 'starting the client at',datetime.now()client = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #创建一个套接字，SOCK_DGRAM表示发送的数据报，表示用UDPclient.sendto(b'hey?',server_address) #发送数据data,server = client.recvfrom(max_size) #接收数据print ('At',datetime.now(), server, 'said', data) client.close() TCP-server代码：12345678910111213141516171819202122from datetime import datetimeimport socketserver_address = ('localhost', 6789)max_size = 1000 print 'starting the server at',datetime.now()print 'waiting for a client to call'server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建一个套接字，SOCK_STREAM表示发送的数据报，表示用UDPserver.bind(server_address) #绑定套接字server.listen(5) #监听client, addr = server.accept() #接收客户端连接data = client.recv(max_size)print ('At',datetime.now(), client, 'said', data)client.sendall(b'Are you talking to me?') #发送数据server.close()client.close() TCP-client代码：1234567891011121314from datetime import datetimeimport socketaddress = ('localhost', 6789)max_size = 1000 print 'starting the client at',datetime.now()client = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建一个套接字，SOCK_STREAM表示发送的数据报，表示用UDPclient.connect(address)client.sendall(b'hey')data = client.recv(max_size)print ('At',datetime.now(), 'someone said', data) client.close() 远程处理远程调用 RPC是一种非常流行的技术，有很多种实现方式。标准库中包含一种RPC实现，xmlrpc，使用XML作为传输格式。在服务器上定义并注册函数，。客户端使用类似导入方式来调用它们。xmlr_server.py 12345678910from xmlrpc.server import SimpleXMLRPCServer"""在服务器上提供了double()函数，注册函数后，才能通过RPC调用"""def double(num): return num*2server = simpleXMLRPCServer(("localhost",6789))server.register_function(double,"double")#注册函数server.serve_forever() xmlr_client.py 12345678910from xmlrpc.client"""客户端通过ServerProxy()和服务器连接。接着会调用proxy.double()"""proxy = xmlrpc.client.ServerProxy("http://localhost:6789/")num = 7result = proxy.double(num)print('Double %s is %s ' %(num,result)) 使用msgpack-rpc-python 安装：pip install msgpack-rpc-python server代码：msgpack_server.py 12345678910from msgpackrpc import Server, Addressclass Services(): def double(self, num): return num *2server = Server(Services())server.listen(Address('localhost',6789))server.start() client代码 :msgpack_client.py 123456from msgpackrpc import Client, Addressclient = Client(Address('localhost',6789))num = 8result = client.call('double',num)print("Double %s is %s " %(num, result)) 使用fabricfabric包可以运行远程或者本地命令、上传或下载文件、用sudo权限运行命令。 pip2 install fabric fab1.py123def iso(): from datetime import date print(date.today().isoformat()) 输入以下命令执行：fab -f fabl.py -H localhost iso 其中：-f fab1.py选项指定使用fabric文件执行fab1.py。-H localhosh选项指定运行本地的命令，最后的iso是fab文件中要运行的函数名。]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python真正的开发者]]></title>
    <url>%2F2019%2F04%2F08%2FPython%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%2F</url>
    <content type="text"><![CDATA[寻找Python代码 Python标准库：http://docs.python.org/3/library/ python包索引(PyPi)：https://pypi.python.org/pypi 安装包安装包的方法 用pip，如：pip install flask 用操作系统自带的包管理工具 源代码安装:python install setup.py 调试代码用pdb进行调试1、 语句123456789Python -m pdb capitals.py (Pdb) c #输入c（继续），程序会一直运行下去，直到正常结束或者出现错误(Pdb) s #单步执行，一行一行的执行Python代码，会进入函数内部(Pdb) n #也是单步执行，但是不会进入函数内部(Pdb) l #列表，查看之后的几行 -&gt; # 指示当前行(Pdb) b 6 #在第6行设置一段点(Pdb) p line #打印line的值 (Pdb) l 1 #l会显示代码行，1表示起始行。从第一行开始 记录错误日志 logging模块包含以下内容： 你想保存到日志中的消息 不同优先级以及对应的函数：debug()、info()、warn()、error()、critical(). 一个或多个logger对象，主要通过它们使用模块 把消息写入终端、文件、数据库或者其他地方的handler 创建输出的formatter； 基于输入进行筛选的过滤器。 123456789import logginglogging.basicConfig(level='DEBUG',filename='bulue_ox.log')#filename会创建一个fileHandler并对logger进行设置。logging模块至少包含15钟handler#以日期和时间的格式写入日志文件LOG_FORMAT = "%(asctime)s - %(levelname)s - %(message)s"logging.basicConfig(filename='./gzipcompressor.log', filemode='a', level=logging.DEBUG, format=LOG_FORMAT) 算法和数据结构 列表解析比添加元素快2倍。 NumPy是Python的一个数学库，它是用c编写的，运行速度很快。Python并不会编译成机器语言，而是被翻译成中间语言，然后被虚拟机解释执行。]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python系统]]></title>
    <url>%2F2019%2F04%2F08%2Fpython%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[文件 创建文件 12fb = open('test.txt','wt')fb.close() 检查文件是否存在 12import osos.path.exists('oops.txt') 用isfile()检查是否为文件 12345678#判断是否文件name = 'oops.txt'os.path.isfile(name)#判断是否是目录os.path.isdir(name)#isabs()判断参数是否是一个绝对路径名，参数不需要是一个真正的文件os.path.isabs(name)os.path.isabs('/big/fake/name') copy()复制文件copy()函数来自另一个模块shutil 12import shutilshutil.copy(oops.txt,'ohno.txt') rename()重命名文件 12import osos.rename('ohno.txt','ohwell.txt') 用abspath()获取路径名该函数会把相对路径扩展为一个绝对路径名os.path.abspath(‘oops.txt’) realpath()获取符号的路径名 remove 删除文件os.remove(‘oops.txt’) 目录 创建目录os.mkdir(‘pomes’) rmdir()删除目录os.rmdir(‘pomes’) 列出目录内容os.listdir(‘pomes’) 使用chdir()修改当前目录可以从一个目录跳转到另一个目录os.chdir(‘pomes’) glob()列出匹配文件 123456import golbglob.glob('m*')#获取以m开头的文件和目录glob.glob('？？')#获取所有名称为两个字符的文件和目录glob.glob('m????e')#获取名称为6个字符并且以m开头以e结尾glob.glob('[klm]*e')#获取所有以k、l或者m开头的文件和目录#[!abc]会匹配除了a、b和c之外的所有字符 程序和进程 进程之间是相互隔离的，一个进程无法访问其他进程的内容，也无法操作其他进程。操作系统会根据所有正在运行的进程，给每一个进程一小段运行时间，然后切换到其他进程，这样既可以做到公平又可以响应用户操作。 12345import osos.getpid()#获取当前进程id号os.getcwd()#当前工作目录os.getuid()#获取用户IDos.getgid()#获取用户组ID subprocess创建进程 import subprocess ret = subprocess.getoutput(‘date’) 使用multiprocessing创建进程 multiprocessing模块可以在一个程序中运行多个进程 123456789101112131415import multiprocessingimport osdef do_this(what): whoami(what)def whoami(what): print 'Process %s says:%s' %(os.getpid(),what) if __name__=="__main__": whoami("I'm the main program") for n in range(4): p = multiprocessing.Process(target=do_this,args=("I'm function %d" %n)) p.start() 使用terminate()终止进程123p = multiprocessing.Process(target=do_this,args=("I'm function %d" %n))p.start()p.terminate() 日期和时间 import calendar calendar.isleap(1900)#判断1900是否死闰年 datetime模块 dattime定义了4个主要的对象： date 处理年、月、日 time 处理时、分、秒 datetime 处理日期和时间同时出现的情况 timedelta处理日期和时间的间隔 12345from datetime import date halloween = date(2014,10,31)halloween.dayhalloween.monthhalloween.isoformat()#打印一个date对象，ISO是ISO 8601，一种表示日期和时间的国际标准 time模块 一种表示绝对时间的方法是计算从某个起点开始的秒数。unix时间使用的是从1970年1月1日0点开始的秒数。 time模块的time()函数会返回当前时间的纪元 localtime()函数返回当前系统时区下的时间，gmtime()返回UTC时间 strftime()12345import timenow = time.time()time.ctime(now) #把一个纪元值转换为一个字符curtime = time.strftime('%Y-%m-%d',time.localtime(time.time()))#获取当天的时间cur = time.mktime(time.strptime(curtime,'%Y-%m-%d')) 读写日期和时间 格式化字符串 日期/时间单元 范围 %Y 年 1900-… %m 月 01-12 %B 月名 January，…. %b 月名缩写 Jan-… %d 日 01-31 %A 星期 Sunday，…. %a 星期缩写 Sun-… %H 时（24小时制） 00-23 %I 时（12小时制） 01-12…. %p 上午/下午 AM，PM %M 分 00-59 %S 秒 00-59 123import timefmt ="It's %A ,%B %d,%Y,local time %I:%M%S%p"t = time.localtime() 其他模块 arrow分 dateutil iso8601 fleming 提供许多时区的函数]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据的归宿]]></title>
    <url>%2F2019%2F04%2F08%2FPython%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%92%E5%AE%BF%2F</url>
    <content type="text"><![CDATA[文件的输入/输出 一个运行中的程序会存取放在随机存储器（ARM）上的数据。 fileobj = open(filname,mode) mode的第一个字母表明对其的操作： r表示读模式 w表示写模式。如果文件不存在则新创建，如果存在则重写新内容 x表示文件不存在的情况下创建并写文件 a表示文件如果存在，在文件的末尾追加写内容mode的第二个字母是文件类型： t(或者省略)代表文本类型 b代表二进制文件 123fb = open('test.txt','wt')fb.write(str1)fb.close() write()写文本文件 数据大可以分块写： fout = open('relativity','wt') size = len(pome) offset = 0 chunk = 100 while Ture: if offset &gt; size: break fout.write(pome[offset:offset+chunk]) offset += chunk 用read、readline、readlines读取文本文件 read()读到文件末尾，再次调用read()会返回字符串‘’。 readline()读取文件的一行，readlines()调用时读取一行，并返回单行字符列表。 fout = open('relativity','wt') while Ture: line = fout.readline() if not line: break poem += line fout.close() 使用with自动关闭文件 with expression as variable: with open('relativity','wt') as fout: fb.write(str1) 使用seek()改变位置 函数tell()返回距离文件开始处的字节偏移量。函数seek()允许跳转到文件其他字节偏移量的位置。 seek(offset,origin) 如果origin=0，从头开始偏移offset个字节 如果origin=1，从当前位置偏移offset个字节 如果origin=2，距离最后结尾处偏移offset个字节 fin = open('relativity','rt') fin.tell() fin.seek(151)#偏移到151处 关系型数据库 数据库展现了表单形式的不同类型数据之间的关系，每一项有对应的关系。NoSQL数据库是键值对形式存储的数据。 db = sqlite3.connect('books.db')#连接数据库 curs = db.cursor() #创建一个cursor对象来管理数据库 curs.execute('''create table book (title text,author text,year int)''') #对数据库执行一个或多个sql命令 db.commit() #插入数据 ins_str = 'insert into book values(?, ?, ?)' with open('books.csv','rt') as infile: books = csv.DictReader(infile) for book in books: print(book) print book[' title'] curs.execute(ins_str,(book[' title'],book['author'],book['year'])) DB-API 应用程序编程接口。是访问某些服务的函数集合。DB_API是Python中访问关系型数据库的标准API。主要函数如下所示： connect（） 连接数据库，包含参数用户名，密码，服务器地址等 cursor()创建一个cursor对象来管理数据库 execute()和executemany() 对数据库执行一个或者多个SQL命令 fetchone()、fetchmany()和fetchall()得到execute之后的结果]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python数据的存取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python玩转数据]]></title>
    <url>%2F2019%2F04%2F05%2Fpython%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[Python数据编码 表1：编码方式 编码 说明 ‘ascii’ 经典的7比特ASCII编码 ‘utf-8’ 最长用的以8比特为单位的变长编码 ‘latin-1’ 被称为ISO 8859-1编码 ‘cp-1252’ windows常用编码 ‘unicode-escape’ Python中Unicode的转义文本格式，\uxxxx或者\uxxxxxxxx 解码 解码是将字节序列转化为Unicode字符串的过程。 123place = 'abcrdddd'place_bytes = place.encode('utf-8')place2 = place.decode('utf-8') 尽可能统一使用UTF-8编码，出错率低，兼容性好，可以表达所有的Unicode字符 格式化使用%的旧式格式化 表2：转换类型 格式 说明 %s 字符串 %d 十进制整数 %x 十六进制整数 %o 八进制整数 %f 十进制浮点数 %e 以科学计数法表示的浮点数 %g 十进制或科学计数法表示的浮点数 %% 文本值%本身 1234'%s' %42'%10d %10f %10s' %(n,f,s) #最小域宽为10个字符，右对齐'%-10d %-10f %-10s' %(n,f,s) #最小域宽为10个字符，左对齐'%10.4d %10.4f %10.4s' %(n,f,s) #设定最大字符宽度为4，右对齐，浮点数的精度限制在小数点后4位 使用{}和format的新式格式化12345678910111213'&#123;&#125; &#123;&#125; &#123;&#125;'.format(n,f,s)'&#123;2&#125; &#123;0&#125; &#123;1&#125;'.format(n,f,s)#0代表第一个参数d = &#123;'n':42,'f':7.03,'s':'string cheese'&#125;'&#123;0[n]&#125; &#123;0[f]&#125; &#123;0[s]&#125; &#123;1&#125;'.format(d,'other')#0代表整个字典，&#123;1&#125;代表字典后面的字符串的值'&#123;0:&gt;10d&#125; &#123;1:&gt;10f&#125; &#123;2:&gt;10s&#125;'.format(n,f,s)#最小域宽为10个字符，左对齐'&#123;0:&lt;10d&#125; &#123;1:&lt;10f&#125; &#123;2:&lt;10s&#125;'.format(n,f,s)#最小域宽为10个字符，右对齐'&#123;0:^10d&#125; &#123;1:^10f&#125; &#123;2:^10s&#125;'.format(n,f,s)#最小域宽为10个字符,居中'&#123;0:&lt;10.4d&#125; &#123;1:&lt;10.4f&#125; &#123;2:&lt;10.4s&#125;'.format(n,f,s)#设定最大字符宽度为4，右对齐，浮点数的精度限制在小数点后4位'&#123;0:!^20s&#125;'.format('BIG SALE')#用！代替空格填充 使用正则表达式匹配 相关功能都在标准库re中，因此首先需要引用他。match()函数用于查看源是否是以模式开头 123result = re.match('You','Young Frankenstein')youpatter = re.compile('You') #编译以加快匹配速度result = youpatter.match('Young Frankenstein') search()返回第一次成功匹配，如果存在的话 findall() 返回所有不重叠的匹配，如果存在的话 split()会根据pattern将source切分成若干段，返回这些片段组成的列表， sub()需要一个额外的参数replacement，它会把source中所有匹配的pattern改成replacement 特殊字符表1：特殊字符 模式 匹配 \d 一个数字字符 \D 一个非数字字符 \w 一个字母或数字字符 \W 一个非字母非数字字符 \s 空白符 \S 非空白符 \b 单词边界 \B 非单词边界 表2：模式标识符 模式 匹配 abc 文本值 （expr） expr . 除\n外的任何字符 ^ 源字符串的开头 $ 源字符串的结尾 prev? 0个或1个prev prev* 0个或多个prev，尽可能多地匹配 prev*? 0个或多个prev，尽可能少地匹配 prev+ 1个或多个prev，尽可能多地匹配 prev+？ 1个或多个prev，尽可能少地匹配 prev{m} m个连续的prev prev{m,n} m到n个连续的prev，尽可能多地匹配 prev{m,n}？ m到n个连续的prev，尽可能少地匹配 [ abd ] a或b或c [^abd ] 非（a或b或c） prev{?=next} 如果后面为next，返回prev prev{?!next} 如果后面非next，返回prev （?&lt;=prev）next 如果前面为prev，返回next （?&lt;!prev）next 如果前面非prev，返回next 注：在匹配是为了防止转义用r’\bxxxxx’， “expr1 | expr2” 表示 eppr1或expr2 。 模式：定义匹配的输出 当使用match()或search()时，所有的匹配会以m.group()的形式返回到对象m中。 123456789101112source = ''' I wish I may,I wish I might have a dish of fish tonight'''m = re.search(r'(. dish\b).*(\bfish)',source)&gt;&gt;&gt; m.group()'a dish of fish'm = re.search(r'(?P&lt;DISH&gt;. dish\b).*(?P&lt;FISH&gt;\bfish)',source)#(?P&lt;name&gt;expr)这样的匹配模式会匹配expr，并将匹配结果存入name的组中&gt;&gt;&gt; m.groups() ('a dish', 'fish')&gt;&gt;&gt; m.group('DISH') 'a dish'&gt;&gt;&gt; m.group('FISH') 'fish']]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python对象和类]]></title>
    <url>%2F2019%2F04%2F04%2FPython%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[对象 Python中所有数据都是以对象的形式出现，只有当你想要创建属于自己的对象或者需要修改已有的对象的行为时，才需要关注对象的内部实现细节。对象就是包含了代码的超级数据结构。 class 定义类123class Person(): def __init__(self):#初始化，self是参数指向了这个正在被创建的对象的本身 pass 在类声明里定义init()方法时，第一个参数必须为self，在定义类的方法（函数）时，第一个参数也必须为self。在定义中init不是必须的。只有当需要区分由该类创建的不同对象时，才需要指定。 继承 从已有的类衍生出新的类，添加或修改部分功能。习惯称原始的类为父类，超类或基类，将新的类称为子类或衍生类。 12345class Person(): def __init__(self):#初始化，self是参数指向了这个正在被创建的对象的本身 passclass People(Person):#继承了Person pass 在子类中可有覆盖父类的方法，从新实现父类的方法即可实现方法的覆盖。 用super从父类得到帮助 重子类中调用父类的方法，用super实现 1234567class Person(): def __init__(self,name):#初始化，self是参数指向了这个正在被创建的对象的本身 passclass People(Person):#继承了Person def __init__(self,name): super().__init__(name)#调用父类的方法 pass 使用属性对特性进行访问和设置 不希望别人直接访问这个特性，因此需要定义两个方法：getter，setter。123456789101112class Person(): def __init__(self,name):#初始化，self是参数指向了这个正在被创建的对象的本身 passclass People(Person):#继承了Person def __init__(self,name): super().__init__(name)#调用父类的方法 @property #用于指定getter方法 def name(self): retrun 'afad' @name.setter #用于指定setter方法 def name(self,input_name) self.name = input_name 如果没有指定setter属性，将无法从类的外部对它进行值的改变。 使用名称重整保护私有特性 对那些需要刻意隐藏在类内部的特性有自己的命名规范：由（__）双下划线开头。 12345678910class Duck(): def __init__(self): pass @property def name(self): retrun self.__name @name.setter def name(self,name) self.__name = name#这种，让外部的代码无法使用 方法的类型’ 有些数据（特性）和函数（方法）是类本身的一部分，还有一些是由类创建的实例的一部分。在类的定义中，以self作为第一个参数的方法都是实例的方法。 12345678910class A(): count = 0 def __init__(self): A.count += 1;#类特性 def __init__(self): print 'I'm an A' @classmethod#类方法，第一个参数是类本身。参数被写作cls，全称class是保留字 def kids(cls): print 'A has',cls.count,"little objects"easy_A =A() 特殊方法 特殊方法的名称以双下划线（__）开头和结束。 表1：和比较相关的方法 方法名 使用 _ _eq_ _(self,other) self == other _ _ ne _ _(self,other) self != other _ _ lt _ _(self,other) self &lt; other _ _gt_ _(self,other) self &gt; other _ _le_ _(self,other) self &lt;= other _ _ge_ _(self,other) self &gt;= other 表2：和数学相关的方法 方法名 使用 _ _ add _(self,other) self + other _ _ sub _ _(self,other) self != other _ _ _ mul _ _ _(self,other) self * other _ _ floordiv _ _(self,other) self // other _ _ truediv _ _(self,other) self / other _ _ mov _ _(self,other) self % other _ _ pow _ _(self,other) self ** other 表2：其他种类的方法 方法名 使用 _ _ str _ _(self,other) str(self) _ _ repr _ _(self,other) repr(self) _ _ len _ _(self,other) len(self) 12345678910class Word(): def __init__(self,text): self.text = text def __eq__(self,words): return self.text.lower = words.text.lower() def __str__(self,words): return self.text def __repr__(self,words): return 'Word(" 'self.text' ")'first = word('ha') 组合 将类作为参数传入另一个类。12345678910111213class Bill(): def __init__(self,description): self.description = description class Bill(): def __init__(self,length): self.length = lengthclass Duck(): def __init__(self,bill,tail): self.bill = bill self.tail = tail def about(self): print('this duck has a ',bill.description,'bill and a',tail.length,'tail')]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python中的类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python盒子：模块、包、程序]]></title>
    <url>%2F2019%2F04%2F02%2Fpython%E7%9B%92%E5%AD%90%EF%BC%9A%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[命令行参数 主要是sys库，调用sys.argv12import sysprint ('fafdsaf:',sys.argv)#接收外部的参数 模块使用别名导入模块1import report as wr # 把report别名为wr 包 把多个模块组织成文件层次，称之为包。1234567#主程序是boxes/weather.pyfrom source import daily,weekly#模块1：boxes/sources/daily.py 模块2：boxes/source/weekly.py#还要在sources目录下添加一个文件：init.py。这个文件可以是空的，但是不能少#在主程序下就可以调用source目录下的文件了import report as wr # 把report别名为wr 双端队列 模块deque，from collections import deque;函数popleft()去掉最左边的项并返回该项，pop()去掉最右边的项并返回该项。 1234567def palindrome(word): from collections import deque dq = deque(word) while len(dq) &gt; 1: if dq.popleft != dq.pop()： return False return True itertools迭代代码结构 在for…in循环中调用迭代函数，每次会返回一项，并记住当前调用的状态 12345678910import itertoolsfor item in itertools.chain([[1,2],['a','b']): print(item) #每次输出一项... 12abcycle()是在参数之间循环的无限迭代器accumulate()计算积累的值 友好输出pprint pprint()会尽量排列输出元素从而增加可读性 1from pprint import pprint 获取更多python代码 pypi: http://pypi.python.org 也称为cheese shop github： http://github.com/python readthedocs https://readthedoces.org]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2F2019%2F03%2F31%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数的定义 依次输入def，函数名，带有参数的圆括号，最后紧跟冒号（:），一个函数可以接受任何类型的值作为输入变量，并且返回任何数量的任何类型的结果。如果函数不显示调用return，会默认返回none。 注：none不代表false，作为布尔值和FALSE是一样的。12def do_nothing pass 函数的参数位置参数传入的参数值是按照顺序依次复制过去的，顺序不同，参数的引用结果不同、 关键字参数 调用参数时可以指定对应参数的名字，这样可以不遵从顺序传入的原则。若一部分指定了参数名字，而另一部分参数没有指定名字，则没指定名字的按照顺序传入的原则调用。 指定默认参数值默认参数值在函数被指定时已经计算出来了，而不是在程序运行时。 12def menu(wine,entree,dessert='pudding'): return &#123;&#125; 使用*收集位置参数12def print_args(*args): pass 星号将一组可变数量的位置参数集合成参数值的元组。同样的道理，如果你的函数同时有限定的位置参数，那么*args会收集剩下的参数。 使用**收集关键字参数使用两个星号可以将参数收集到一个字典中，参数的名字是字典的键，对应参数的值是字典的值。 12def print_args(**args): pass 如果把带有*args和**args的位置参数混合起来，就会按照顺序解析。 文档字符串在函数体开始的部分附上函数定义说明的文档，就是函数的字符串。 123456789 def print_args(**args): 'echo return its input argument' pass #可以定义更长的字符串 def print_args(**args): '''echo return its input argument gdjglajfgag jfaojigiab fjajofdi ''' pass 用Python函数help()可以打印出一个函数的文档字符串。如：help(print_args) 一等公民：函数（函数复杂定义及应用） Python中一切皆对象，包括数字，字符串，元组，列表，字典，函数。函数是Python中一等公民，可以把它们（返回值赋给变量），可以作为被其他函数调用，也可以从其他函数中返回值。 123456#函数中的函数,传入的值是一个函数名，在一个函数中调用另一个函数def run_something(func) func()#传参函数的函数def run_something(func,arg1,arg2) func(arg1,arg2) 内部函数可以在函数中定义另外一个函数 12345#返回的是一个值def print_args(**args): def inner(): pass return inner() 闭包闭包：一个可以被动态创建的可以记录外部变量的函数。 12345#返回的是一个函数，def print_args(args): def inner(): return "%s" ,%args return inner 匿名函数：lambda()函数lambda函数是用一个语句表达的匿名函数，可以用它来代替小的函数。 12345678910111213def edit_stroy(words,func): for word in words: print(func(word))def enliven(word): return word.capitalize() + '!' #调用函数为edit_stroy(starirs,enliven)#用匿名函数为edit_stroy(starirs,lambda word: word.capitalize() + '!')#lambda函数接收一个参数word。在冒号和末尾圆括号之间的部分为函数的定义。 生成器 生成器使用来创建一个Python对象的。用它可以迭代庞大的序列，且不需要在内存中创建和存储整个序列。通常，生成器是为迭代器产生数的。它会记录上一次调用的位置，并且返回下一个值。这一点和普通函数都是不一样的，一般函数不记录前一次调用，而且都会在函数的第一行执行。 12345def my_range(first=0,last=10,step=1): number=first while number &lt; last: yield number #记录上一次调用的位置，并且返回下一个值 number += step 装饰器装饰器实质是一个函数 =。它把一个函数作为输入并且返回另外一个函数。通常使用如下技巧： *args 和 **kwargs 闭包 作为参数的函数 名称中的_和_的用法12345678def my_range(first=0,last=10,step=1): number=first while number &lt; last: yield number #记录上一次调用的位置，并且返回下一个值 number += stepmy_range._name_ #显示函数名my_range._doc_ #显示文档字符串 try和except处理错误正常执行try后面的语句，错误则执行except后面的语句。 1234try： passexcept： pass 获取异常对象： except exceptiontype as name 如：except IndexError as err：将一个IndexError异常值赋给err]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python代码结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python外壳：代码结构]]></title>
    <url>%2F2019%2F03%2F30%2Fpython%E5%A4%96%E5%A3%B3%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[引言python 没有用花括号（{}）或者关键字(begin和end)来划分代码段，Python用空白来区分代码结构， 用严格的缩进来区分代码块结构。用“#”号来对代码进行注释。用“\”做为续行符来连接不同行的代码。 if、elif和else用法跟c语言的一样，不同的是，在每个判断语句后不用加括号，但是要加冒号(:),表示判断的结束。 每个判断语句下面的执行语句，要有严格的缩进，表示一个代码块。 比较操作符in 表示属于，其余跟c一样。在连接不同的比较时，有and ，or，not布尔操作符进行不同判断语句的连接。 比如：5 &lt; x and x &lt; 10;可以写成： 5 &lt; x &lt; 10;是同样的效果。 真值的判断在所有的比较判断中，非空（零）即真。 while和for循环判断同if一样，while 语句后的冒号（：）表示该语句的结束（如：while count &lt; 5 :）; for循环，在Python中也称对容器的迭代；其中列表，字符串，元组，集合等都是可以迭代的对象，基本语法：如：for rabbit in rabbits: rabbits可以是上述的迭代对象。元组或列表的迭代都是产生一项，而字符串的迭代则产生单个字符。 对字典的迭代，可以迭代键（for key in keys.key(): 或for key in keys:）也可以迭代值（for value in value.value():）,也可以用元组的方式返回（for item in accusation.items(): 或者分别赋值 for card,contents in accusation.items():）。 break和continuebreak和continue都是在循环体里使用，break跳出整个循环，continue跳出当前循环。 在循环外使用else基本形式如下： 12345678910111213141516while pos &lt; len(num): ..... break else： #没有执行break ... #for的结构for cheese in cheeses: ... break else： #没有执行break ... 上述代码，如果没有执行break，即没有找到可执行的解。则执行else。 用zip()并行迭代所谓并行迭代就是把多个列表（或者其他容器）放在一起同时迭代，在最短序列用完后，迭代结束。 1234567891011121314days = ['mon','tue',wed]fruits = ['banana','orangs','peach']drinks = ['offee','tea','beer']#在最短序列用完后结束迭代for day, fruits, drinks in zip(days, fruits, drinks): ...#用zip()配对两个元组English = 'mon','tue','wed'french = 'lundi','mardi','mercredi'list(zip(English, french))#生成字典dict(zip(English, french)) 用range（）生成自然序列range()函数可以返回在特定区间的自然序列，range(start,stop,step),start默认为0，产生的最后一个 数的值是stop的前一个：stop - 1。step默认为1；也可以反向创建自然序列，step = -1；1234for x in range(0,3):#反向创建for x in range(2,-1,-1): 推导式推导式是一个或者多个迭代器快速简洁地创建数据结构的一种方法，可以将循环和条件判断 相结合，从而避免语法冗长。 列表和集合推导式语法：[expression for item in iterable] [expression for item in iterable if condition] 集合语法：{expression for expression in iterable} 中括号变为花括号 1234567number_list = [number for number in range(0,3)]a_list = [number for number in range(1,6) if number % 2 == 1] cells = [(row, col) for row in rows for col in cols]for cell in cells: print(cell) 字典的推导式语法： {key_expression:value_expression for expression in iterable} 也可以有if判断，以及多个for循环迭代 123456789words = 'letters'letter_counts = &#123;letter:words.count(letter) for letter in words&#125;print(letter_counts) &#123;'s': 1, 'r': 1, 'e': 2, 'l': 1, 't': 2&#125;#对于程序执行来说，两次调用word.count(letter)浪费时间，因为‘t’和‘e’出现了两次# 优化如下letter_counts = &#123;letter:words.count(letter) for letter in set(words)&#125;#这是对集合进行迭代而不是字符串 生成器推导式元组是没有推导式的。用圆括号是生成器推导式 1234567891011121314 &gt;&gt;&gt; number_thing=(number for number in range(1,6))&gt;&gt;&gt; number_thing&lt;type 'generator'&gt;&gt;&gt;&gt; for number in number_thing:... print number... 12345#一个生成器只能运行一次，之后就会被擦除]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python代码结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python容器：列表、元组、字典与集合]]></title>
    <url>%2F2019%2F03%2F29%2Fpython%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E4%B8%8E%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[列表和元组 列表和元组都是包含0个或者多个元素，与字符不同，不要求所含元素的种类相同。元组是不可变的，列表是可变的。 列表的创建 列表适合利用顺序和位置定位某一元素。 用[]或者list（）创建列表1234empty_list = list()number = [1,2,3]#列表的值允许重复#列表可以包含列表 列表相关函数list()将其他数据类型转换为列表 split()函数可以将字符串分割为列表 [offset]获取列表元素，也可以用来修改相应的元素，指定切片提取元素，列如：marxes[::2]步长为2，从后往前去以负数（-1）开始，marxes[::-1]可实现逆序 append()添加元素到尾部 extend（）或+=合并列表 insert（）在指定位置插入元素，如：marxes.insert(3,&apos;fadfa&apos;) del 删除元素，如：del marxes[0],del是Python语句而不是列表方法，marxes[1].del无法进行调用。 remove()删除具有指定元素如：marxes.remove(&apos;fadfa&apos;) pop()获取并删除指定位置的元素，如marxes.pop()弹出最后一个元素，括号可以加元素的索引 index()查询具有指定元素的位置marxes.index（&apos;1122&apos;） count()记录特定值出现的次数 join（）转换为字符串，join是字符串的方法而不是列表的方法。‘445’.join(marxes) sort()重新排列元素：sort()会对原列表进行排序，改变原列表的内容，sorted()返回排好序的列表副本，原列表不变，排序中默认从小到大，可以通过reverse=true或false改变先后顺序 len()获取列表长度 in 判断值是否存在 用等号（=）或者copy（）复制列表等号，是给原始列表多加一个标签，而不会从新生成一个新列表，用下面的方法： 列表copy函数 list()函数 列表分片 元组的创建123empy = ()one = 'fafdsa', #每个元素后跟一个逗号，多个元素中最后一个元素的逗号可以省略a,b,c = 'afd','fsadf','454' #一次性将元组值赋给多个变量 元组函数tuple(marx_list) 可以将其他类型转换为元组 元组的特点 元组占用的空间小 不会意外修改元组的值 可以将元组作为字典的键 命名元组可以作为对象的替代 函数的参数是以元组的形式传递的 字典字典中每个元素有对应的键，通过键来访问元素，键可以是任意的变量，但通常是字符，字典是可变的，可以通过修改键值对字典进行修改，键之间是不能重复 字典的创建1empy = &#123;&#125; 字典的函数dict（） 转换为字典 用[key] 添加或修改元素，也可以用以获取元素 update()合并字典 del pythons[&apos;121&apos;]删除具有指定键的元素 clear（）删除所有元素 in判断是否存在 key()获取所键 values()获取所有值 items()获取所有键值对以元组的形式返回 用copy复制字典 集合 集合就像舍弃了值，只剩键一样的字典 集合的创建1empy = set() 集合的函数用in测试值是否存在 set()将其他类型转换为集合 &amp; 或intersection() 合并及运算符，可用以获取集合中的交集 | 或 union()获取集合中的并集， - 或 difference()获取集合中的差集 ^ 或symmtric_difference()获取两个集合的异或集 &lt;= 或者 issubset()判断一个集合是否是另一个集合的子集]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基本元素：字符串，数字，变量]]></title>
    <url>%2F2019%2F03%2F26%2Fpython%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E6%95%B0%E5%AD%97%EF%BC%8C%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量、名字和对象 Python里所欲的数据都是以对象的形式存在，甚至大型的数据结构、函数以及程序。 Python是很强类型的，你永远无法修改一个已有的对象的类型，即使它包含的值是可变的。 变量：就是在程序中为了方便引用内存中的值而为它取的名字。对对象的赋值并不会实际复制值，它只是为数据取个相关的名字，名字是对象的引用而不是对象的本身。比如： 吧a的值赋给b，相当于给刚刚创建的对象又贴上了标签b type（）；该函数可以打印出对象的类型 数字运算法则：跟c语言一样 但是： / 用来执行浮点除法， // 用来取整，在除法中不能除0 基数 0b或0B代表二进制 0o或0O代表八进制 0x或0X代表十六进制 int类型 Python2中一个int包含32位，long包含64位 Python3中long类型不存在，而int类型变为可以存储任意大小的整数，甚至超过64位 字符串 字符串是不可改变的，无法对字符串进行修改，但可以将字符串的一部分复制到新字符串，来达到修改的效果。 字符串的创建 字符串可以是单引号，双引号，三引号。双引号是为了创建字符串本身有单引号的字符串，三引号同理。三引号可以跨行创建字符串字符串的使用使用字符串函数 str（）可以将其参数转换为字符串 len（）获取字符串的长度 split（）对字符串进行分割，括号内填分割的字符 join（）对字符串进行合并 capitalize（）让字符串的首字母变成大写 title（）让所有单词开头变成大写 upper（）让所有字母变成大写 lower（）让所有字母变成小写 seapcase（）让所有字母大小写转换 center（30）在30个字符位居中 ljust（30）在30个字符位左对齐 rjust（30）在30个字符位右对齐 replace（）字符串替换，格式replace（’a ‘,’a famous’,100）把a 替换为a famous，替换100处。拼接字符串用+号可以直接将两个字符串相加。复制字符串用*号可以进行字符串的复制。 start = “nan” * 4 //可将nan复制4遍 用[]提取字符串偏移量可以从0开始增加到字符串长度-1。从左到右从0开始，从右到左从-1开始计数， [start:end:step] 可对字符串进行分片。 [:] 提取从开头到结尾的整个字符串 [start:]从start提取到结尾 [：end]从头提取到end-1 [star:end] 从start提取到end-1 [start:end:step] 从start提取到end-1，步长为step]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python基本元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[番茄助手的安装]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%95%AA%E8%8C%84%E5%8A%A9%E6%89%8B%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[visual assist的安装1、 visual assist软件下载https://pan.baidu.com/s/1uD7GmjuSbdemNOdEhFqReQ rr8i 2、 visual assist X通用补丁下载https://pan.baidu.com/s/1u-vOHdN7-m5vqiG6R1aEpA ed1q 步骤： 安装完visual assist软件软件后，打开通用补丁，直接点击安装就破解了visual assist，如果之前有安装过其他的破解补丁，先点击卸载，卸载后再安装。 自定义vs的快捷键1、步骤 工具-&gt;选项-&gt;环境-&gt;键盘； 搜索你定义快捷键的功能，然后按自定义的快捷键即可；比如： 修改返回上一处光标位置，之前的快捷键是“Ctrl + -”；搜索“向后”（Navigatebackward），然后修改自己的快捷键即可，同理向前（navigateForward）。]]></content>
      <categories>
        <category>visual studio的使用</category>
      </categories>
      <tags>
        <tag>visual assist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的日志与进程管理]]></title>
    <url>%2F2019%2F03%2F16%2Flinux%E7%9A%84%E6%97%A5%E5%BF%97%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601%2F</url>
    <content type="text"><![CDATA[nice:设置优先级 语法：nice [-可选参数] [指令] [属性]范例12 nice -n 17 free -s 60&amp; # 在后台运行free指令，设置优先级为17# 注解：将free -s 60&amp;的优先级设为17，通过ps -l输出的NI项就可以看当前系统中相关进程的优先级 ps指令：报告程序状况 语法：ps [-可选参数] 范例12ps -a #显示系统进程pstree -anh #显示进程间的关系 a:显示完整的指令，n:以进程ID排序，h:对现在执行的程序进行特别标注 fg：将后台任务拉到前台执行范例12ftp 192.198.88.2 &amp;fg %1 #将ftp拉到前台执行 killall：杀死同名的所有进程范例1killall joe]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux网络服务01]]></title>
    <url>%2F2019%2F03%2F14%2Flinux%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A101%2F</url>
    <content type="text"><![CDATA[ifconfig: 显示或者配置网络设备 语法：ifconfig [网络设备] [-可选参数] 范例12345ifconfig #显示当前网络设备状态ifconfig eth0 192.168.1.1 netmask 255.255.255.0 #配置网卡参数ifconfig eth1 down #关闭网卡ifconfig eth1 up #开启网卡ifconfig eth1 hw ether 00:10:B2:56:64:2B #修改网卡的物理地址 ping:测试网络 语法：ping [-可选参数] 网络地址 范例12ping 128.168.12.13 #检测ping的与远端主机的连通情况ping -c 128.168.12.13 #指定发送数据包的次数 netstat：显示网络状态 语法：netstat [必要参数] [选择性参数] 范例12netstat -r #显示系统的路由表netstat -an #显示详细的网络状况 telnet:远程登录 语法：telnet [-可选参数] 主机名/IP 范例1telnet 192.168.1.1 #远程登录 rsh ：远端登录的shell 语法：rsh [-可选参数] 主机 指令 范例123chkconfig rlogin on #启动rlogin工具rlogin 192.168.1.1 #登录远程主机rsh -l mary 192.168.1.1 /bin/pwd #登录远程主机执行指令/bin/pwd,要正确执行该指令，必须现在远程主机192.168.1.1上启动rlogin指令]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux磁盘操作管理]]></title>
    <url>%2F2019%2F03%2F13%2Flinux%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C%E7%AE%A1%E7%90%8601%2F</url>
    <content type="text"><![CDATA[badblocks ：检查磁盘坏道 语法：badblocks [-可选参数] 磁盘设备 [结束块 [启始块]] 参数说明 参 数 说明 -f 强制检查一个已经挂载的设备 -b&lt;区块大小&gt; 指定磁盘的区块大小，以字节为单位 -c&lt;区块大小&gt; 指定每个磁盘区块检查的次数 -i&lt;文件&gt; 跳过保存在指定文件中的坏道消息，避免重复检查 -o&lt;文件&gt; 将检查的结果输出到指定的文件中进行保存 -s 显示检查进度 注：/dev/hd:IDE磁盘；/dev/sd:SCSI磁盘；/dev/ed:ESDI磁盘；/dev/fd:软磁盘 范例123badblocks /dev/fd0H1440 #检查整个磁盘是否有坏道badblocks -b /dev/hdal -o had-badblocks #检查/dev/hdal 是否有坏道，同时将检查的结果保存到文件hda-badlocks中\#如果有坏道查看文件将显示列表，如果没有无信息被列出 df:磁盘信息 说明：使用df查看磁盘空间的信息，可以查看文件系统的占有情况。 语法：df [-可选参数] [文件或设备] 参数说明 参 数 说明 -h 以可读性较高的方式显示 -H 相当于“-h”，但在计算时，1K = 1000,而不是1024 -a 显示包括0块在内的所有文件系统的情况 -i 显示inode节点信息 范例1234df #显示磁盘信息df -hdf -iadf -t ext2 #显示当前磁盘的文件系统的信息 du ：显示目录或者文件所占的磁盘空间范例12du ax #显示ax文件占用的磁盘空间du #显示当前目录所占的磁盘空间 tree ：以树状图显示目录内容 语法：tree [-可选参数] [目录] 范例1tree]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下的文本编辑01]]></title>
    <url>%2F2019%2F03%2F11%2Flinux%E4%B8%8B%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%9101%2F</url>
    <content type="text"><![CDATA[vim :文本编辑 语法：vim [-可选参数] [文件]vim环境下的常用指令 命令模式：D:删除光标所在行后的所有词nG：n为数字，将光标移至第n行位置p：将复制的内容粘贴到光标所在位置r：修改光标所在处的字符x：删除光标所在处的字符X：删除光标所在处的前一个字符d+d：连按两次，将删除光标所在行n+d+d：n为数字，删除光标所在行及其下面的n-1行，共n行y+y：整行复制Ctrl+b：向上翻一页Ctrl+f：向下翻一页Ctrl+d：向后翻半页Ctrl+u：向前翻半页Ctrl+g：在最后一行处显示光标所在位置的行数和文章的总行数 输入模式：i：从当前光标处插入I：从当前光标所在行的行首开始插入o：在当前光标所在行下方新增一行，从新增行的行首开始输入O：在当前光标所在行上方新增一行，从新增行的行首开始输入 末行模式：n:加载文件：w:存盘：w newfile：文件另存为：wq：存盘退出：W!：对只读文件强制写入存盘：q：退出：q！：强制退出：set nu：在每行的开头显示行数：set none：取消每行开头的行数显示：/字符串：匹配字符串查找，按n向下查找，N向上查找 wc：计算字数 语法：wc[-可选参数][文件] 参数说明 参 数 说明 -c 只显示字符数 -l 只显示行数 -w 只显示字数 范例wc -c ar #计算字节数 wc -w ar # 计算字数 wc -l #计算行数 tail ：显示文件的末尾内容 语法：tail [ 必要参数] [选择性参数][文件] 参数说明（1）必要参数 参 数 说明 -f 循环读取 -q 不显示处理信息 -v 运行时显示详细的处理信息 （2）选择性参数 参 数 说明 -c 要显示的字节数 -n 显示的行数 -help 帮助信息 范例tail -n 30 install.log #显示文件末尾30行的内容 tail -f 2.log #显示文件内容。2.log文件是更新的，-f可以动态监测文件末尾的内容 tail -n 5 *.log #显示文件末尾内容]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux文件操作与管理03]]></title>
    <url>%2F2019%2F03%2F09%2Flinux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%AE%A1%E7%90%8603%2F</url>
    <content type="text"><![CDATA[rcp ：远程复制文件或目录 语法：rcp [- 可选参数]远程/本地主机名：源文件/目录 本地/远程主机名：目标文件/目录 参数选择 参 数 说明 -p 保留源文件/目录的属性 -r 处理指定文件夹下的文件及其子目录下的所有文件 范例1rcp -p 192.168.1.121:/home/vc /home/yy/ #复制文件，将远程文件复制到本地/home/yy/，同时保留源文件的属性，一般主机名不用给 tar ：打包同时压缩/解压文件 语法：[- 可选参数] [文件] 参数选择 参 数 说明 -c 压缩文件 -x 解压文件 -r 添加文件到已存在的备份文件的尾部 -j 使用bzip2压缩文件 -z 使用gzip压缩文件 -v 显示详细信息 -f 指定备份文件 范例123tar -xzvf s1.tar.gz #解压s1.tar.gz 文件tar -czvf s1.tar.gz *.txt #压缩.txt文件tar -c a1.txt a2.txt &gt;s1.tar #打包文件 whereis ，which：查找文件-语法 ：whereis/which [-可选参数] 文件 范例12whereis *.txt #查找文件，查找目录下的.txt文件which az #查找文件，执行which az， 在环境变量$PATH指定的目录“/usr/bin”下查找文件，显示查找结果 info：读取目录信息范例12info init &gt;1.log #显示init的帮助信息info info #显示info的具体使用方法]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux文件操作与管理02]]></title>
    <url>%2F2019%2F03%2F08%2Flinux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%AE%A1%E7%90%8602%2F</url>
    <content type="text"><![CDATA[less :一次显示一页文本 语法 ： less [-参数] 文件名 范例1less a3.txt 注：显示文本后：按b：向后翻页，d：向后翻半页，h:显示帮助界面，u：向前滚动半页，y:向前滚动一行；回车键：滚动一行；空壳键：滚动一页；q：退出 mv：移动或更名现有的文件或目录 语法：mv [-可选参数] 源文件 目标文件/目录 范例1mv a.txt b.txt ncftp：文件传输指令 语法：ncftp [-可选参数] [主机/IP地址] 参数选择 参 数 说明 -u&lt;用户名&gt; 使用用户名 -p&lt;密码&gt; 使用指定密码 -P&lt;端口号&gt; 使用指定端口号，默认为21 范例1234ncftp -u sy114 -p 123456 192.168.128.1 #登录##相似的命令ncftpget -u sy114 -p 123456 192.168.128.1 /home/yy1/vc #下载文件ncftpput -u sy114 -p 123456 192.168.128.1 /home/yy1/vc #上传文件 注：登录上后跟ftp指令相似 paste：合并文件 语法：paste [-可选参数] [文件]范例12paste a1 a2 #合并文件的行paste -s a1 a2 #合并文件的行，并指定间隔符 patch：修补文件，给文件打补丁 语法： patch [-可选参数] [文件]范例12diff a1 a2&gt;sy.diff #比较文件的差异，生成差异文件sy.diffpatch a1&lt;sy.diff #修复a1]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux文件操作与管理01]]></title>
    <url>%2F2019%2F03%2F06%2Flinux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%AE%A1%E7%90%8601%2F</url>
    <content type="text"><![CDATA[diff：生成差异文件（1）参数说明 参 数 说明 -c 显示所有内容，同时标出不同之处 -a 对文本文件进行逐行比较，非文本文件看作文本文件进行比较 -i 忽略大小写的不同 -r 比较目录时递归比较子目录中的文件 范例123diff -a a1.txt a3.txt #比较两个文件的不同diff Desktop/yy1 Desktop/yy2 # 比较两个文件夹的不同diff -c a1.txt a3.txt #比较两个文件的不同，并生成差异文件 find ：查找目录或者文件 语法： find[路径][-可选参数] 范例12345find *.txt # 查找.txt的文件find /root/edsktop/yy1/ -ctime -2 #查找448小时内被修改过的文件find -name yy* #查找指定字符串类型的目录find -name yy.*#查找的结果是以yy命名的文件find -size 0#查找字节数为0的文件 ftp ：文件传输指令范例1ftp 192.168.1.1 connected to 192.168.1.2#使用ftp地址建立ftp连接 注：建立的过程会输入用户名和密码，建立之后可用get和put指令实现文件的上传和下载删除文件用delete指令 gunzip：解压文件范例12gunzip yy.txt.gz #解压文件gunzip -l yy.txt.gz #解压文件时显示文件相关信息 gzip：压缩文件范例12gzip -v yy.txt #压缩文件时显示文件相关信息gzip -d yy.txt.gz #解压指定文件]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qt-for-android的安装]]></title>
    <url>%2F2019%2F03%2F05%2Fqt-for-android%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[QT软件的安装下载软件https://pan.baidu.com/s/1o8CxKaptmVthHVE3x3sjXw zndu参考相关博客链接：https://www.jianshu.com/p/437465a530dc https://blog.csdn.net/qq_32250025/article/details/79106662 1、安装安装 java -jdk ,android-ndk,android-sdktools 安装 java -jdk，对应版本：jdk1.8.0_201 安装android-ndk ， 安装ndk的时候，android-ndk-r10e以上的版本没有arm-linux-androideabi-gdb.exe，所以在下载安装包的时候不能下载版本太高，10以下的版本就够. 安装android-sdktools 在安装sdk的时候会出现jdk找不到，或者版本过低，这时要先配置环境变量。当配置好环境变量出现版本过低的时候要重新下载jdk安装文件重新安装，之前我安装jdk-11.0.2后，再安装sdk时出现版本过低，重新下载了jdk1.8.0_201安装就可以。在配置qt文件的时候会出现不适一个平台，这时候要启动sdk文件夹下的SDK Manager.exe安装Android包。 安装ant 这个是在qt软件上:工具-&gt;选项-&gt;android:下的Ant executable项后面有一个下载的符号，点击可自动下载。ps：对应的软件都在网盘里环境变量的配置(1) JAVA_HOME 值： C:\Program Files\Java\jdk1.8.0_45(2)ANDROID_HOME 值：D:\Android\sdk(3)CLASSPATH 值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 编译文件 在构建的时候选择Android构建和运行就能够编译出.apk文件，对应的文件再编译文件夹下的/bin目录]]></content>
      <categories>
        <category>QT学习</category>
      </categories>
      <tags>
        <tag>QT for Android环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux用户指令01]]></title>
    <url>%2F2019%2F03%2F03%2Flinux%E7%94%A8%E6%88%B7%E6%8C%87%E4%BB%A401%2F</url>
    <content type="text"><![CDATA[who：显示系统用户信息范例12who #显示当前登录系统的用户信息who -l -H# 显示用户登录位置 whois：查找用户/域名信息范例12whois mary #查找Mary用户的信息whois www.miwifi.com # 查找目标网络信息 bunzip2，bzip2，bzip2recover：解压.bz2类型的文件，压缩成.bz2文件，损坏.bz2文件的修复范例12345bunzip2 -c filename.bz2 #解压后文件直接输出到标准输出bzip2 filenamebzip2 -7 -k filename #压缩文件filename并保留原文件bzip2-b filename.bz2 #解压文件bzip2recover filename #修复.bz2文件 linux中cat、more、less命令区别详解 linux中命令cat、more、less均可用来查看文件内容，主要区别有： cat是一次性显示整个文件的内容，还可以将多个文件连接起来显示，它常与重定向符号配合使用，适用于文件内容少的情况；more和less一般用于显示文件内容超过一屏的内容，并且提供翻页的功能。more比cat强大，提供分页显示的功能，less比more更强大，提供翻页，跳转，查找等命令。而且more和less都支持：用空格显示下一页，按键b显示上一页。下面详细介绍这3个命令。]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基本配置指令05]]></title>
    <url>%2F2019%2F02%2F25%2Flinux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A405%2F</url>
    <content type="text"><![CDATA[pkill ：杀死进程 语法: pkill [必要参数][选择性参数][字符串] 功能说明：pkill指令是和kill指令的结合，用来杀死指定的进程必要参数 参 数 说明 -n 显示新进程 -v 与条件不符的进程 -x 与条件符合的程序 -t 指定终端下的进程 -u 指定用户的程序 范例12345pkill -9 ftp #杀死进程ftppkill -t tty1 #杀死所有终端1下的进程ps -A #显示所有进程pkill -u kk #杀死用户kk的所有进程pkill -vu kk #杀死不属于用户kk的所有进程 pmap ：显示程序的内存信息范例123pmap -2253 #显示进程2263的内存信息pmap -x 2253 #显示进程2263使用内存的详细信息pmap -d 2253 #显示内存对应同时显示设备号 pwck ：检查密码文件 语法 : pwck [必要参数][文件] 范例pwck /etc/passwd #检测密码文件]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基本配置指令04]]></title>
    <url>%2F2019%2F02%2F24%2Flinux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A404%2F</url>
    <content type="text"><![CDATA[export ：设置或在显示环境变量范例12export -p #列出所有环境变量export M_ENV = http://www.linux.org/ #定义环境变量 lsmod：显示Linux内核的模块信息范例1lsmod #显示载入系统的模块信息 reboot指令：重新启动 语法: reboot [-可选参数]范例123reboot -f #强制重启reboot -i #关闭网络设置后在重新启动reboot -n #先保存数据，再重启 hostname ：显示或者设置当前系统的主机名 语法：hostname [必要参数][选择性参数] 范例123hostname -i #显示主机ip地址hostname -d #显示主机域名hostname Apple #设置主机名称]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基本配置指令03]]></title>
    <url>%2F2019%2F02%2F23%2Flinux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A403%2F</url>
    <content type="text"><![CDATA[manpath ：设置man手册的查询路径范例12manpath #列出目前的查询路径manpath -M /home/zhang #指定查询路径 free：显示内存信息范例1234free -b #以字节为单位显示free -k #以KB为单位显示free -m #以MB为单位显示free -s 10 #每隔10s执行一次free，连续显示内存信息 crontab ：指定自动执行任务 语法: crontab [-u&lt;用户名&gt;] [-可选参数] 创建新的 crontab 文件，或编辑现有文件 创建 crontab 文件的最简单方法是使用 crontab -e 命令。 此命令会调用已为系统环境设置的文本编辑器。系统环境的缺省编辑器在 EDITOR 环境变量中定义。如果尚未设置此变量，crontab 命令将使用缺省编辑器 ed。最好选择您熟悉的编辑器。以下示例说明如何确定是否已定义编辑器，以及如何将 vi 设置为缺省值1234$ which $EDITOR$ $ EDITOR=vi$ export EDITOR 创建 crontab 文件时，该文件会自动放入 /var/spool/cron/crontabs 目录， 并以您的用户名命名。如果具有超级用户特权，则可为其他用户或 root 创建或编辑 crontab 文件。 $ crontab -e [username]以下示例说明如何为其他用户创建 crontab 文件1234crontab -e jones1 0 * * 0 rm /home/jones/*.log &gt; /dev/null 2&gt;&amp;1 #添加到新 crontab 文件中的以下命令项将在每个星期日的凌晨 1:00 自动删除用户起始目录中的所有日志文件。由于该命令项不重定向输出，因此将重定向字符添加到 *.log 之后的命令行中。这样可以确保正常执行命令。crontab -l #列出目前的时程表crontab -r #删除目前的时程表 时程表格式如下123456 f1 f2 f3 f4 f5 program#其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。#当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推#当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推#当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推#当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其馀类推]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的基本配置指令02]]></title>
    <url>%2F2019%2F02%2F22%2Flinux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A402%2F</url>
    <content type="text"><![CDATA[clear 指令：清除屏幕信息 目的：对杂乱的屏幕进行清理 语法： clear date 指令： 显示或设置系统时间指令 目的：根据指定格式显示或设置当前系统的时间 语法：date [-可选参数][日期和时间格式] 格式为MMDDhhmm范例12datedate “Date:%Y.%m.%d Time:%H.%M.%S” echo指令：字符串输出 目的；应用该指令的字符串的值输出到标准输出 语法：echo [-可选参数] 字符串输出（1）必要参数 参 数 说明 -n 不在最后自动换行 -e 若字符串出现以下字符，加以特别处理 \a发出警告 \v删除前一个字符 \c最后不加换行符号 \f换行但光标任停在原来的位置上 \n换行且光标移至行首 \r光标移至行首，但不换行 \t插入tab \v同\f \在输出插入\字符 \nnn 将nnn看做八进制，输出它所代表的ASCII字符 -help 帮助信息 -version 版本信息 范例1echo -e “123456\n”]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用的指令]]></title>
    <url>%2F2019%2F01%2F20%2Flinux%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux查询进程指令1、进程查询指令1ps -ef | grep calculatorBuysell | grep -v grep | wc -l 注：该命令可以查询calculatorBuysell进程的个数]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大牛们的博客网站]]></title>
    <url>%2F2018%2F12%2F09%2F%E5%A4%A7%E7%89%9B%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[大牛们的博客网址 http://www.yanmin99.com/hexo 博客迁移 https://www.cnblogs.com/iHeling/p/14095937.html]]></content>
      <categories>
        <category>初识hexo</category>
      </categories>
      <tags>
        <tag>初识hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next创建about]]></title>
    <url>%2F2018%2F12%2F09%2Fhexo%E7%9A%84next%E5%88%9B%E5%BB%BAabout%2F</url>
    <content type="text"><![CDATA[hexo的next创建about创建步骤 1、新建一个about页面，命令如下 ： 1$ hexo new page about 注：在myBlog/source下会生成一个行的文件夹about，在该文件夹下会有一个index.md文件 - 2、 菜单显示about链接，在主题的thems/next/_configy.yml设置中将menu中的about前面的注释去掉 123456menu:home: /archives: /archives/categories: /categories/tags: /tags/about: /about/]]></content>
      <categories>
        <category>初识hexo</category>
      </categories>
      <tags>
        <tag>初识hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 标准头文件]]></title>
    <url>%2F2018%2F10%2F20%2Fc-%E6%A0%87%E5%87%86%E5%A4%B4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[常用到的头文件1234567#include &lt;string&gt; //标准字符串类#include &lt;iostream&gt; //标准输入输出#include &lt;vector&gt; //标准向量容器#include &lt;set&gt; //标准集合容器#include &lt;map&gt; //标准映射容器#include &lt;algorithm&gt; //标准算法using namespace std; //打开标准库的名字空间]]></content>
      <categories>
        <category>boost库开发</category>
      </categories>
      <tags>
        <tag>c++ &amp; boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习软件的安装]]></title>
    <url>%2F2018%2F10%2F19%2F%E5%AD%A6%E4%B9%A0%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[vs软件的安装 安装软件百度云盘的visual studio 文件夹下有安装包：zmvss2k8.iso，兼容性补丁包：VS2008SP1ENUX1512962.iso以及番茄助手：Visual Assist X 2048 安装步骤先安装zmvss2k8.iso，再安装VS2008SP1ENUX1512962.iso。安装文件是.exe结尾的目标文件。再安装番茄助手安装后将破解动态库VA_X.dll替换到安装文件夹下。注：安装过程中会出现安装Windows的.net文件。打开Windows的更新直接更新 配置boost库https://blog.csdn.net/qq1987924/article/details/7897503 modelsim安装 软件位置百度网盘上modelsim文件夹下 安装步骤先安装.exe的文件，再打开破解器破解，破解方式： https://www.cnblogs.com/lamblabs/p/8604360.htmlPython安装 软件位置百度网盘上Python软件文件夹下 安装步骤直接安装无需破解虚拟机安装 安装步骤软件在百度云盘上虚拟机软件文件夹下，直接安装无需破解hexo和git的安装 安装步骤软件在百度云盘的hexo&amp;git文件夹下直接安装注：进入我的博客文件夹下安装 配置hexohttps://www.cnblogs.com/fengxiongZz/p/7707219.html QT的安装 安装步骤软件的位置在百度网盘上qt软件文件夹下，安装教程参考如下网站：https://jingyan.baidu.com/article/656db918d9292ae380249c4f.html quartus II的安装 软件位置百度网盘上，FPGA的文件夹下 安装及破解步骤https://blog.csdn.net/qq_18649781/article/details/81025650]]></content>
      <categories>
        <category>安装软件</category>
      </categories>
      <tags>
        <tag>软件的安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选购主板]]></title>
    <url>%2F2018%2F10%2F17%2F%E9%80%89%E8%B4%AD%E4%B8%BB%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[主板的认识 主板是一个电脑的中枢，所有部件及其外设只有通过它才能与处理器连接在一起进行通信，并由处理器发出相应的操作指令执行相关的操作。 主板上包含CPU、内存条插座、芯片组、BIOS芯片、供电电路、各种接口插座、各种散热器等部件。它们决定了主板的性能和类型。 主流主板 目前有Intel公司处理器的主板和AMD公司处理器的主板。 识别主板芯片组 主板芯片组是主板的灵魂与核心，芯片组的性能优劣决定了主板性能的好坏。所有的信息都是交给芯片组来完成的。在主板的构架中，北桥芯片和南桥芯片是硬件设备进行通信及沟通的桥梁。 北桥芯片位于CPU插座与pci-e插槽的中间，其芯片体型较大，一般会覆盖一个散热风扇。北桥芯片主要负责联系CPU和控制内存。 南桥芯片一般位于主板的下方，PCI插槽附件。它主要负责支持键盘控制器、USB接口、实时时钟控制、数据传递方式和高级电源管理。 主板BIOS芯片BIOS实际上是“Basic Input/Output System”的英文缩写，中文意思是“基本输入/输出系统”。BIOS实际上 是电脑中底层的一种程序。当启动系统时，BIOS进行加电自检、检查系统基本部件，然后系统启动启动程序将系统的配置参数写入CMOS中。 CMOS指的是主板上的一块可以反复读写的RAM芯片，也称为互补金属氧化物半导体随机存储器。CMOS主要用来保存当前系统的硬件配置和用户对某些参数的设定，靠一块纽扣电池供电，即使断电内容也不会丢失。 CMOS跳线 1 跳线的目的 用于清除CMOS中的数据，在清空数据之后，BIOS将出厂时的原始数据传给CMOS存储器。 2 CMOS跳线的作用 用放电的方法来清除开机密码或者BIOS进入密码。 3 CMOS跳线的方法 将CMOS电池旁边的跳线帽拔出，插入另外一个针和中间针上几秒，然后在拔出插回原来的位置。或者将电池取出，将电池盒上的正负极短路几秒，再把电池安上即可。硬盘接口 硬盘的接口非常多，主要有IDE接口、SATA接口、SCSI接口、Fibre Channel接口、IEEE1394接口和USB接口。 1 IDE接口 IDE接口的英文全称为integrated Drive Electronics（电子集成驱动器），它的本意是把盘体与控制器集成在一起的做法减少了硬盘的接口电缆数目与长度，数据传输可靠得到了增强，硬盘控制起来变得更容易。 有39针的接口 2 SCSI接口SCSI的英文全称是small computer system interface（小型计算机系统接口）。它的优势在于支持多种设备，独立的总线使得他对CPU的占用率很低，传输速率也比ATA接口快很多，但价格也高很多。 3 SRIAL ATA接口 用四个针口就完成了所有工作，SATAII接口的传输速率达到了3Gbps，SATAIII接口的传输速率达到了6gbps。 4 Fibre channel 接口 中文名“光纤通道”，它与SCSI接口祸IDE接口有很大不同。]]></content>
      <categories>
        <category>电脑硬件选购</category>
      </categories>
      <tags>
        <tag>电脑主板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选购CPU]]></title>
    <url>%2F2018%2F10%2F15%2F%E9%80%89%E8%B4%ADCPU%2F</url>
    <content type="text"><![CDATA[初识cpu CPU是central processing unit的缩写，中文名称是“中央处理器”。其内部结构归纳起来可分为：控制单元、逻辑单元和存储单元三部分，这三部分相互协调，可以进行分析判断、运算并控制电脑各个部分协调工作。 CPU的生产商及产品 目前世界上生产CPU的厂商主要有Intel公司，AMD公司 inter公司的产品主要是酷睿i系列。 处理器核数 1 Intel公司Intel公司六核处理器主要有：i7-5930K、i7-4960X、i7-4930K、i7-3970X等Intel公司四核处理器主要有：第三代、第四代核第六代corei7四核处理器，第三代、四代核六代corei5四核处理器。 2 AMD公司 AMD公司主流cpu有FX系列8核，6核、4核处理器， APU系列4核、三核、双核处理器， phenomII（羿龙II）X4四核、X3三核、X2双核等。CPU及CPU散热器选购实战 1 主频购买不要追求过高的主频。 2 注意购买时机购买时可以选择推出半年到一年的CPU产品 3 注意应用需求在不同的应用环境下对于CPU的性能需求是不同的，所以，在进行电脑选购时必须注意“适合应用”的原则。 4 注意预防购买假的CPU（1） 看分界线 原包装在外盒背面印有多种文字的产品介绍，这些文字的上下分界处，有一行看起来很像黑道的分解线。如果是正品的话，即可发现这些黑道其实是极小的“intel”标志组成，而且十分清晰。（2）看包装盒颜色正品色彩鲜艳，次品色彩比较浅。（3）看封装线正品盒装Intel CPU的塑料封纸的封装线不可能在盒的右侧条形码处。（4）看水印字 正品刮不下来（5）看激光标签正品采用了四重着色技术，层次丰富，字迹清晰。（6）电话查询盒装上有一串很长的编码，可以通过拨打热线电话800-820-1100来查产品的真伪。（7）看热封点正品有4个热封点，每个热封点有两个圆点，它们在揭开后就不能复原。（8）看风扇看风扇的热片和轴承，原装的风扇的轴承是金属的，散热片见得凹槽为圆弧形，而且热片的低端厚实。假风扇的做工很粗糙，手感很轻。 5 使用时尽量选择高外频在主频情况相同的情况下，更高的外频和前端总线可以提供更大的数据传输带宽，因此相对来说表现也更优秀。CPU风扇选购实战 1 cpu风扇的生产厂商：清华华天公司，富士康公司、博美特公司注：除了风冷扇热之外，还有一种比较好的散热方式-水冷散热。]]></content>
      <categories>
        <category>电脑硬件选购</category>
      </categories>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑的组成]]></title>
    <url>%2F2018%2F10%2F15%2F%E7%94%B5%E8%84%91%E7%9A%84%E7%BB%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[电脑装机维修预备知识 1 主机的内部构造主机中主要包括：电源、cpu、内存、主板、硬盘、显卡、声卡、网卡、光驱等（1）主板主板把电脑的各个部件联系到一起，各个部件通过主板进行数据的传输。它工作的稳定性直接影响整机的工作的稳定。 2 电脑的软件系统（1）操作系统软件（2）程序设计软件（3）应用软件注： 连接各个设备时电源线要最后连接，其他设备随意。 制定多核电脑配置方案 1 原则（1）购买电脑的目的 简单用途普通配置，复杂用途高档配置。（2）购买者的资金状况（3）确定资金消费重点 如果购机时资金不是很充足，这时应该根据购机目的和实际情况，确定资金消费的、重点。如商务用机，应侧重于显示器和主板的选择。 2 配置方案类型（1）入门型用户 2000-3000元（2）大众型用户 3000-6000（3）专业型用户6000-10000查看系统信息依次单击“开始-&gt;所有应用-&gt;windows管理工具-&gt;系统信息”]]></content>
      <categories>
        <category>电脑硬件选购</category>
      </categories>
      <tags>
        <tag>主机硬件结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[purchase hard-disk]]></title>
    <url>%2F2018%2F10%2F14%2Fpurchase-hard-disk%2F</url>
    <content type="text"><![CDATA[选购硬盘1、 硬盘的认识 硬盘的内部包括磁盘、读写磁头、精密的电动机和线路等。硬盘转速有3600r/min、4500r/min、5400r/min、7200r/min及10000r/min.2、 硬盘的选购指标 容量、转速、换成、传输率、接口、单碟容量等。尽量购买保质时间长的硬盘。注意硬盘的生产日期。如果发现后面有个”R“字母，这块硬盘是返修的，或者有“refurbished”的字样，也说明硬盘是返修的。3、 硬盘接口主流用的是SATA接口标准为SATA 3.0规格，它的传输输速率可达到6Gbit/s，因此，选择要注意硬盘的接口。 固态硬盘是采用固态电子存储芯片阵列而制成的硬盘，它由控制单元和存储单元组成。固态硬盘在接口、功能和使用方法上与普通硬盘相同。 主流硬盘1、希捷2、西部数据3、日立4、三星 硬盘相关参数的识别]]></content>
      <categories>
        <category>电脑硬件选购</category>
      </categories>
      <tags>
        <tag>电脑硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[purchase memory]]></title>
    <url>%2F2018%2F10%2F14%2Fpurchase-memory%2F</url>
    <content type="text"><![CDATA[选购内存 内存的分类第一种是DRAM(动态内存),此内存集成度高，功耗和成本低，是目前主流产品，第二种是SRAM（静态内存），广泛用于工作站，高档电脑、大型机和巨型机种的Cache（缓存） 内存选择（1） DDR SDRAM内存 双倍数据速率同步内存，DDR2内存即第二代同步双倍速率动态随机存取存储器。DDR2内存可进行4bit预读取，DDR3可进行8bit，DDR4 16bit预取机制，是DDR3的两倍。（2）选择容量1）用来上网、学习、游戏、办公、炒股、文字处理、配置8GB内存总体够用。2）用来刻录、视频影像处理，8GB够用，16GB好用3）用来编程16GB内存较好4）用来二维或者三维图形图像设计，配置8GB内存勉强用，16GB够用，32GB内存好用。5）用来设计、密集数据采集运算、虚拟现实等，配置16GB内存勉强，32GB够用6）用来作web服务器，配置8GB内存勉强，32GB内存够用。售后也很重要。 内存的速率目前主流内存的速率小于1.5ns “打磨”内存 正品的芯片表面一般都有质感，要么有光泽或荧光感，要么就是亚光。如果芯片的表面色泽不存甚至比较粗糙、发毛，芯片必然受到了打磨。内存的生产商1、 金士顿（Kingston）2、 金邦（GEIL）3、 宇瞻（Apacer）4、 胜创（KINGMAX）相关参数的识别]]></content>
      <categories>
        <category>电脑硬件选购</category>
      </categories>
      <tags>
        <tag>电脑内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[table]]></title>
    <url>%2F2018%2F10%2F05%2Ftable%2F</url>
    <content type="text"><![CDATA[表格样式md 水果 价格 数量 香蕉 $1 5 苹果 $1 6 草莓 $1 7]]></content>
      <categories>
        <category>学习表格</category>
      </categories>
      <tags>
        <tag>表格的格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python eval函数]]></title>
    <url>%2F2018%2F10%2F04%2Fpython-eval%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python中eval函数的作用1、函数说明eval函数就是实现list、dict、tuple与str之间的转化str函数把list、dict、tuple转为字符串eg1：字符串转换成列表1234567a = "[[1,2], [3,4], [5,6], [7,8], [9,0]]"print(type(a))b = eval(a)print(b)# 输出： &lt;type 'str'&gt; [[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]] eg2:字符串转换成字典123456789a = "&#123;1: 'a', 2: 'b'&#125;"print(type(a))b = eval(a)print(type(b))print(b)# 输出： &lt;type 'str'&gt; &lt;type 'dict'&gt; &#123;1: 'a', 2: 'b'&#125; eg3：字符串转换成元组123456789a = "([1,2], [3,4], [5,6], [7,8], (9,0))"print(type(a))b=eval(a)print(type(b))print(b)# 输出： &lt;type 'str'&gt; &lt;type 'tuple'&gt; ([1, 2], [3, 4], [5, 6], [7, 8], (9, 0))]]></content>
      <categories>
        <category>python相关函数</category>
      </categories>
      <tags>
        <tag>Python eval函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的基本配置指令01]]></title>
    <url>%2F2018%2F10%2F04%2Flinux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A401%2F</url>
    <content type="text"><![CDATA[alias指令： 设置指令的别名 目的： 使用该指令可以对存在的指令设置一个容易记忆的别名 语法： alias 别名 = ‘复杂的指令’范例123alias p = ‘passwd’alias a = 'adduser -d /home/she-p 123456 sun' #设置别名alias #列出当前已经设置的别名 ps： 重启系统别名失效，如果想要永久生效，需要编辑文档/home/gec/.bashrc来实现该文件在root用户下。 man:显示指令的帮助信息 目的:用man指令查看shell指令和相关函数 语法:[-可选参数] 指令名 说明: ubuntu中man的手册默认没有装。用下面几条命令就行了：sudo apt-get install manpagessudo apt-get install manpages-desudo apt-get install manpages-de-devsudo apt-get install manpages-devubuntu man手册完善Linux提供了丰富的帮助手册，当你需要查看某个命令的参数时不必到处上网查找，只要man一下即可。Linux 的man手册共有以下几个章节：1、Standard commands （标准命令）2、System calls （系统调用）3、Library functions （库函数）4、Special devices （设备说明）5、File formats （文件格式）6、Games and toys （游戏和娱乐）7、Miscellaneous （杂项）8、Administrative Commands （管理员命令）范例123man --help #帮助文档man 3 open #查看open函数，3代表查看库函数man 1 ls #查看ls命令，1代表查看标准命令 ps：man -k who 后面提到，-k：显示与指定字符匹配的标题字符串的每一行 apropos：查找使用手册的名字和相关描述 目标：查找一个不知道的能完成某种特殊任务的命令名称，有时候会忘记执行特定任务的命令，就可以使用apropos找出来 语法：apropos [必要参数] [选择性参数] 关键词 参数说明：（1）必要参数 参 数 说明 -d 输出调试信息 -v 输出详细的警告信息 -r 认为每个关键词是一个通常的表达式 -w 认为每个关键词进行精确匹配 -c 对每个关键词进行精确匹配 （2）非必要参数 参 数 说明 -s 只在给定的部分进行搜索 -h 帮助信息 -V 版本信息 内建指令：whatis，man 范例12apropos -r ls#以通常的方式找关键词lsapropos who #等同于man -k who]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vs 2008&2015]]></title>
    <url>%2F2018%2F07%2F28%2Fvs-2008%2F</url>
    <content type="text"><![CDATA[vs 的快捷键https://www.cnblogs.com/feichengwulai/articles/3515899.html 空格和tab键的设置 首先，先后按下两组快捷键Ctrl+R和Ctrl+W可以显示程序中的空格显示为圆点的样式，这样，在编码时，就可以知道Tab键是否为空格了。 同样，再次按下上述快捷键可以取消该显示。 将Tab键改为四个空格的方法： Tools-&gt;Options-&gt;Text Editor-&gt;C/C++-&gt;Tabs中的Tab选项由Keep tabs该为Insert Space 注释 注释：ctrl+ K + C 取消注释：ctrl +K + U 全屏显示/全屏退出 shift + alt + enter 快速切换窗口使用组合键“Ctrl+Tab”（此时可以打开IDE的导航，获得鸟瞰视 图）。 调试相关 调试启动： F5 调试重新启动：ctrl+shift+F5 调试（开始执行不调试）：ctrl+F5 ctrl+shift+f9取消所有断点 F10跨过程执行 F11单步逐句执行 窗口快捷键 ctrl+w，s 打开解决方案管理器 ctrl+w，c 类视图 ctrl+w，e 错误列表 ctrl+w，o 输出视图 f4或者ctrl+w，p 属性窗口 ctrl+w，x 工具箱 调用智能提示1）方法1：使用组合键“Ctrl+J”；2）方法2：使用组合键“Alt+→” 回到上一个光标位置/前进到下一个光标位置1）回到上一个光标位置：使用组合键“Ctrl + -”；2）前进到下一个光标位置：“Ctrl + Shift + - ”。vs2015的调试技巧 在调试过程中，打开不同的调试窗口调试-&gt;窗口-&gt;（选择要打开的窗口）]]></content>
      <categories>
        <category>vs学习</category>
      </categories>
      <tags>
        <tag>VS快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python items和itertems函数的用法]]></title>
    <url>%2F2018%2F07%2F28%2Fpython-items%E5%92%8Citertems%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字典的定义123456#第一种：创建空字典dict=&#123;&#125;#第二种：创建字典常量dict=&#123;'key1':'value1','key2':'value2'&#125;#第三种：创建字典dict=dict() 字典的赋值1234#第一种：直接赋值dict=&#123;'key1':'value1','key2':'value2'&#125;;#第二种：创建时赋值dict(key1='value1',key2='value2') items函数 函数说明：items函数，将一个字典以列表的形式返回，因为字典是无序的，所以返回的列表也是无序的。123a = &#123;'a':1,'b':3&#125;a.items()返回 ：a = [('a',1),('b',3)] iteritems函数 函数说明：该函数返回一个迭代器1234567891011a = &#123;'a':1,'b':3&#125;b = a.iteritems()list(b) = [('a',1),('b',3)]for k, v in b: print k,v 返回：a 1 b 3 注：在Python 3.x 里面，iteritems()方法已经废除了。在3.x里用 items()替换iteritems() ，可以用于 for 来循环遍历。]]></content>
      <categories>
        <category>python相关函数</category>
      </categories>
      <tags>
        <tag>python 字典的访问方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有用的学习网站]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%9C%89%E7%94%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[大神的博客：http://www.yanmin99.com/linux公社 免费下载地址：http://linux.linuxidc.com/ 用户名与密码都是 www.linuxidc.com Markdown 学习网站 Markdown 介绍与入门https://blog.csdn.net/u010565454/article/details/65937558 简介 Markdownhttps://ouweiya.gitbooks.io/markdown/注：该网页刷新很慢，建议使用第一个 MaHua在线markdownhttp://mahua.jser.me/ 好用的Markdown编辑器https://www.williamlong.info/archives/4319.html Markdown : An error occurred with the Html rendering componenthttps://blog.csdn.net/gxseveryday/article/details/80031755 MarkdownPad2.5 注册码https://www.jianshu.com/p/9e5cd946696d markdown文件的基本常用编写语法（图文并茂）https://blog.csdn.net/tyyking/article/details/79682157视频学习网站 1 电子工程师在线课堂 http://www.moore8.com/courses/list/ 课业答案 1 国际交流英语视听说B2 https://wenku.baidu.com/view/4b2d7bc3f121dd36a32d8283.html 2 国际交流英语视听说B2 Further Listening参考答案 https://wenku.baidu.com/view/2d43ec5e5901020207409cf8.html?pn=51 3 《误差理论与数据处理(第6版)》费业泰-课后答案 https://wenku.baidu.com/view/372fcd1b3d1ec5da50e2524de518964bcf84d222.html 4 研究生英语读写教程（2） http://www.doc88.com/p-9863795133644.html hexo&amp;git 1 利用github+hexo搭建自己的博客 https://blog.csdn.net/u012150360/article/details/72793482 2 使用hexo+GitHub一步一步搭建属于自己的博客 https://www.cnblogs.com/fengxiongZz/p/7707219.html 2 vue-cli 安装过程中报错npm ERR! code EPERM npm ERR! errno -4048 npm ERR! syscall scandir解决 https://blog.csdn.net/u010622874/article/details/80499523 3 npm ERR! code EPERM npm ERR! errno -4048 npm ERR! syscall scandir解决方法 https://blog.csdn.net/brain_bo/article/details/80675282 4 hexo 搜索功能 https://blog.csdn.net/ganzhilin520/article/details/79047983 5 Hexo安装配置详解 https://blog.csdn.net/tonydandelion2014/article/details/61615898 6 Hexo配置文件详细说明 https://blog.csdn.net/gyq1998/article/details/78294689wox 使用说明 1 Wox - 开源免费强大的快捷启动器辅助工具，快速高效率打开软件/搜索文件！ https://blog.csdn.net/xiaotongbiji/article/details/80620228c++ 1 vs2008配置boost库 https://blog.csdn.net/qq1987924/article/details/7897503]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>学习网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[代码样式1234567891011//c++类的框架：class MyFristBlog&#123; public： MyFristBlog(); ~MyFristBlog(); private: int i; float j;&#125; 下载主题的命令git clone https://github.com/iissnan/hexo-theme-next themes/next 注：next是主题的名称，git clone是hexo命令，https://github.com/iissnan/hexo-theme-next是下载主题的网站，themes是下载的目录 hexo的基础配置修改全局的config.yml文件123456789101112theme:landscape 把landscap改为我们要替换的主题 如next然后进行主题更新：cd themes/nextgit pull再通过hexo cleanhexo g -d或者hexo cleanhexo g hexo d这样就将博客上传到github上了 添加about标签在博客所在目录下用： hexo new page about 这样会添加一个about文件夹，里面包含一个index.md。在这个文件内，可以编写一些about的信息。 然后，进入themes/jacman(进入你使用的主题下)打开_config.yml，在menu中添加about的链接。12345menu:首页: /归档: /archives关于: /about这样就会再页面菜单中生成一个关于about的链接了。 添加categories分类和tags标签1、新建标签 hexo new page tags hexo new page categories2、确认站点配置文件里有tag_dir: tags category_dir: categories3、确认主题配置文件里有tags: /tags categories: /categories4、编辑站点的source/tags/index.md，添加title: tagsdate: 2015-10-20 06:49:50type: “tags”comments: false5、编辑站点的source/categories/index.md，添加title: categoriesdate: 2015-10-20 06:49:50type: “categories”comments: false 注：编写tags和categories：冒号后面要有空格，格式如下：123456title: javascript深入理解(一)js类型知多少date: 2018-07-17 14:18:12tags: - javascriptcategories: - javascript深入理解 创建新博客1$ hexo new "My New Post"]]></content>
      <categories>
        <category>初识hexo</category>
      </categories>
      <tags>
        <tag>初识hexo</tag>
      </tags>
  </entry>
</search>
