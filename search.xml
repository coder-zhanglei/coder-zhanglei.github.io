<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[代码库常见错误]]></title>
    <url>%2F2019%2F04%2F14%2F%E4%BB%A3%E7%A0%81%E5%BA%93%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[Git新建分支出现fatal: Not a valid object name: ‘master’错误 原因是没有提交一个对象，要先commit之后才会真正建立master分支，此时才可以建立其它分支。 123456git add c++git commot -m "提交c++"#然后创建分支git branch wapgit branch -a #查看分支 出现error: The following untracked working tree files would be overwritten by checkout pull代码出现error: The following untracked working tree files would be overwritten by checkout $ git clean -d -fx “” Git使用之(pathspec master did not match any file(s) known to git) 不能查看分支git checkout master提示如下错误:error: pathspec ‘master’ did not match any file(s) known to git 解决1.首先我们看一下分支情况:git branch -a2.如果没有看到你想要的分支,先获取所有分支:git fetch 需要注意的是: 和push不同, fetch会自动获取远程 `新加入’ 的分支. 执行git push出现”Everything up-to-date”在github上git clone一个项目，在里面创建一个目录，然后git push的时候，出现报错”Everything up-to-date” 原因：1）没有git add .2）没有git commit -m “提交信息”如果上面两个步骤都成功执行，还出现这个错误是因为创建的目录下是空的，目录下必须有文件才能git push上传成功。在github上创建文件的时候，在新文件名后加/符号就是文件夹，但是这种方式只支持英文名目录，中文名目录不支持。 对于在git上面拉代码报”error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054”解决方法主要原因是安全设置的问题：首先执行git config http.sslVerify “false” 若出现下列错误git config http.sslVerify “false” fatal: not in a git directory再继续执行 git config –globle http.sslVerify “false” 问题解决]]></content>
      <categories>
        <category>代码托管</category>
      </categories>
      <tags>
        <tag>github代码库错误总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建自己的github代码库]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84github%E4%BB%A3%E7%A0%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[我的代码库 网址： https://github.com/coder-zhanglei/zhanglei.github.io.git 参考的博客： https://www.cnblogs.com/zhixi/p/9584624.html 准备工作1、 在github上创建自己账号，建立自己的代码库，已完成2、 安装git软件，下载地址：https://windows.github.com/ 或 https://git-scm.com/download/win注：安装好git后右键就有Git Bash Here可以打开git上传下载文件的框 基本配置1、 添加本地目录到远程仓库 在你的本地文件目录下右击，就会出现Git Bash选项，点击进入。2、 设置用户名和邮箱地址。这两个值是作为上传时记录的值。输入命令： 1234 git config --global user.name "用户名" git config --global user.email "邮箱"#设置好后可以用命令查看当前的设置：git config --global user.name 下载和上传远程仓库的文件1、 首先初始化本地仓库 1git init 注：会生成.git的隐藏文件。没有生成就是没初始化成功 2、 连接远程仓库 12git remote add origin "https://github.com/GitHub用户名/代码仓库名称.git"git remote add origin https://github.com/coder-zhanglei/zhanglei.github.io.git 可以通过git remote -v 查看本地链接到的远程仓库1git remote -v 若分支设置错误，可以查看后切换分支【git remote rm origin】 删除现有远程仓库【git remote add origin url】添加新远程仓库 12git remote rm origingit remote add origin url 下载1、 从远程仓库拉取所有更新（每次上传项目都要操作） 1git pull origin master 注意：此处极易报错！ 因为远程代码仓库和本地代码仓库合并后，可能会有冲突，如有报错，使用git status查看状态 pull，因为两个仓库不同，发现refusing to merge unrelated histories，无法pull 因为他们是两个不同的项目，要把两个不同的项目合并，git需要添加一句代码，在git pull，这句代码是在git 2.9.2版本发生的，最新的版本需要添加–allow-unrelated-historiesgit pull origin master –allow-unrelated-histories 注：在 git pull origin master –allow-unrelated-histories此步操作时，.gitignore文件错误冲突并没有解决，只是强制合并忽略掉了 创建分支，上传文件 因为git是分布式管理，所以尽量不要在master主分支上作开发，例如自己有一个项目，在外面开发时，可以使用分支1，在家开发时可以使用分支2，如果有其他人参入 ，分别 使用分支3，4，5每次提交本地代码时候，先合并远程master主分支到本地，再提交 1、 创建本地分支 1git branch 分支名 2、 切换本地分支1git checkout 分支名 3、 本地分支提交 123git add .git commit -m ‘dev'git push -u origin dev 4、 合并本地分支到master 12345678910111213 git checkout master git pull origin master git merge origin/master //合并分支 git status On branch masterYour branch is ahead of 'origin/master' by 12 commits. (use "git push" to publish your local commits)nothing to commit, working tree clean #上面的意思就是你有12个commit，需要push到远程master上 #执行下面命令即可 git push origin master 上传指令的区别$ git push origin 上面命令表示，将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。$ git push 如果当前分支与多个主机存在追踪关系，那么这个时候-u选项会指定一个默认主机，这样后面就可以不加任何参数使用git push。$ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。 仓库的管理 删除仓库，参考博客：https://blog.csdn.net/weixin_42152081/article/details/80635777 分支的管理 ：参考博客：https://blog.csdn.net/wankui/article/details/53328369 一.删除已有仓库 如果我们想要删除Github中没有用的仓库，应该如何去做呢？ 进入到我们需要删除的仓库里面，找到“settings”即仓库设置： 然后，在仓库设置里拉到最底部，找到“Danger Zone”即危险区域： 点击“Delete this repository”这样就可以删除该仓库了。 二.删除Github中的某个文件或文件夹 1.本地仓库和远程仓库同时删除 例如要删除如图所示的_config.yml和index.md两个文件： 我们先在本地把两个文件删除，然后执行以下命令： 123git add * //把本地仓库的文件上传到缓存。git commit -m 'del' //把第一步上传到缓存的东西上传到本地仓库，其中'del'是操作标识，内容随便填，方便用户观看。git push origin master //把本地仓库的文件上传到远程仓库。 这样，再打开远程仓库就可以看到两个文件已经被删除了： 列几个常用的git命令git init 项目初始化git clone 拉取项目git add . 添加到暂存区git commit -m 添加commit信息git push 将本地分支推送到服务器上去git pull origin master 本地与服务器端同步 git log 查看日志git status 查看当前状态git tag 查看版本号git diff 查看尚未提交的更新 git fetch：相当于是从远程获取最新版本到本地，不会自动mergeGit log -p master..origin/master 比较本地的master分支和origin/master分支的差别查看对比一下 ，具体效果这里就不贴了，各位可以自行测试git merge origin/master 进行合并 需要注意的是: 和push不同, fetch会自动获取远程`新加入’的分支.]]></content>
      <categories>
        <category>代码托管</category>
      </categories>
      <tags>
        <tag>创建自己的代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github和gitlab]]></title>
    <url>%2F2019%2F04%2F12%2Fgithub%E5%92%8Cgitlab%2F</url>
    <content type="text"><![CDATA[github和gitlab的相同点 二者都是基于web的Git仓库，在很大程度上GitLab是仿照GitHub来做的，它们都提供了分享开源项目的平台，为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。GitHub同时提供公共仓库和私有仓库，但如果要使用私有仓库，是需要付费的。而GitLab解决了这个问题，你可以在上面创建私人的免费仓库。 github和gitlab的不相同点 GitHub同时提供公共仓库和私有仓库，但如果要使用私有仓库，是需要付费的。而GitLab解决了这个问题，你可以在上面创建私人的免费仓库。GitLab让开发团队对他们的代码仓库拥有更多的控制，相比于GitHub，它有不少的特色： 允许免费设置仓库权限； 允许用户选择分享一个project的部分代码 允许用户设置project的获取权限，进一步的提升安全性；可以设置获取到团队整体的改进进度；通过innersourcing让不在权限范围内的人访问不到该资源。 从代码私有性方面来看，有时公司并不希望员工获取到全部的代码，这个时候GitLab无疑是更好的选择。但对于开源项目而言，GitHub依然是代码托管的首选。]]></content>
      <categories>
        <category>代码托管</category>
      </categories>
      <tags>
        <tag>github和gitlab的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的安装]]></title>
    <url>%2F2019%2F04%2F11%2Fpython%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Python的下载Python 下载链接：https://www.python.org/downloads/注：点击下载链接后跳转页面，在页面的files标题下选择下载的版本 Linux或unix下Python 下载链接：https://www.python.org/ftp/python/ 安装Anaconda anaconda是一个针对科学设计的多合一安装包：包括Python本体，标准库以及许多实用的第三方库。下载链接：https://repo.continuum.io/archive/ anaconda将所有文件都安装到属于它自己的目录中。不需要特殊的权限来执行安装]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python并发和网络]]></title>
    <url>%2F2019%2F04%2F10%2Fpython%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[进程和线程 使用线程来解决I/O限制问题 使用进程、网络或事件来处理cpu问题标准库中有一个Queue函数。 multiprocessing包 multiprocessing包是Python中的多进程管理包。与threading.Thread类似，它可以利用multiprocessing.Process对象来创建一个进程。该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有start(), run(), join()的方法。此外multiprocessing包中也有Lock/Event/Semaphore/Condition类 (这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。但在使用这些共享API的时候，我们要注意以下几点: 在UNIX平台上，当某个进程终结之后，该进程需要被其父进程调用wait，否则进程成为僵尸进程(Zombie)。所以，有必要对每个Process对象调用join()方法 (实际上等同于wait)。对于多线程来说，由于只有一个进程，所以不存在此必要性。 multiprocessing提供了threading包中没有的IPC(比如Pipe和Queue)，效率上更高。应优先考虑Pipe和Queue，避免使用Lock/Event/Semaphore/Condition等同步方式 (因为它们占据的不是用户进程的资源)。 多进程应该避免共享资源。在多线程中，我们可以比较容易地共享资源，比如使用全局变量或者传递参数。在多进程情况下，由于每个进程有自己独立的内存空间，以上方法并不合适。此时我们可以通过共享内存和Manager的方法来共享资源。但这样做提高了程序的复杂度，并因为同步的需要而降低了程序的效率。 Process.PID中保存有PID，如果进程还没有start()，则PID为None。window系统下，需要注意的是要想启动一个子进程，必须加上那句if _ _ name _ _ == “main”，进程相关的要写在这句下面。 简单创建多进程 有两种使用方法，直接传入要运行的方法或从Process继承并覆盖run()： 12345678910111213141516171819202122232425262728293031from multiprocessing import Processimport threadingimport timedef foo(i): print 'say hi', iif __name__ == '__main__': for i in range(10): p = Process(target=foo, args=(i,)) p.start()# 方法二from multiprocessing import Processimport timeclass MyProcess(Process): def __init__(self, arg): super(MyProcess, self).__init__() self.arg = arg def run(self): print 'say hi', self.arg time.sleep(1) if __name__ == '__main__': for i in range(10): p = MyProcess(i) p.start() Process类 构造方法： def _ _ init _ _ (self, group=None, target=None, name=None, args=(), kwargs={}): group: 线程组，目前还没有实现，库引用中提示必须是None； target: 要执行的方法； name: 进程名； args/kwargs: 要传入方法的参数。 注：一般是用 target和args/kwargs 实例方法： is_alive()：返回进程是否在运行。 join ( [ timeout ] )：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。 start()：进程准备就绪，等待CPU调度 run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。 terminate()：不管任务是否完成，立即停止工作进程 属性： authkey daemon：和线程的setDeamon功能一样 exitcode(进程在运行时为None、如果为–N，表示被信号N结束） name：进程名字。 pid：进程号。daemon属性： 如果某个子线程的daemon属性为False，主线程结束时会检测该子线程是否结束，如果该子线程还在运行，则主线程会等待它完成后再退出； 如果某个子线程的daemon属性为True，主线程运行结束时不对这个子线程进行检查而直接退出，同时所有daemon值为True的子线程将随主线程一起结束，而不论是否运行完成。 属性daemon的值默认为False，如果需要修改，必须在调用start()方法启动线程之前进行设置。另外要注意的是，上面的描述并不适用于IDLE环境中的交互模式或脚本运行模式，因为在该环境中的主线程只有在退出Python IDLE时才终止。 Pool类 进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。进程池设置最好等于CPU核心数量 构造方法： def Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None): Pool( [ processes[, initializer[, initargs[, maxtasksperchild[, context] ]]]]) processes ：使用的工作进程的数量，如果processes是None那么使用 os.cpu_count()返回的数量。 initializer： 如果initializer是None，那么每一个工作进程在开始的时候会调用initializer(*initargs)。 maxtasksperchild：工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来替代原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。 context: 用在制定工作进程启动时的上下文，一般使用 multiprocessing.Pool() 或者一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context实例方法： apply(func[, args[, kwds]])：同步进程池 apply_async(func[, args[, kwds[, callback[, error_callback]]]]) ：异步进程池 close() ： 关闭进程池，阻止更多的任务提交到pool，待任务完成后，工作进程会退出。 terminate() ： 结束工作进程，不在处理未完成的任务 join() : wait工作线程的退出，在调用join()前，必须调用close() or terminate()。这样是因为被终止的进程需要被父进程调用wait（join等价与wait），否则进程会成为僵尸进程。pool.join()必须使用在 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 #例子一（异步进程池）：#pool.close()或者pool.terminate()之后。其中close()跟terminate()的区别在于close()会等待池中的worker进程执行结束再关闭pool,而terminate()则是直接关闭。# coding:utf-8from multiprocessing import Poolimport timedef Foo(i): time.sleep(2) return i + 100def Bar(arg): print argif __name__ == '__main__': t_start=time.time() pool = Pool(5) for i in range(10): pool.apply_async(func=Foo, args=(i,), callback=Bar)#维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去 pool.close() pool.join() # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。 pool.terminate() t_end=time.time() t=t_end-t_start print 'the program time is :%s' %t ###例子二（同步进程池）： # -*- coding:utf-8 -*-from multiprocessing import Process, Poolimport timedef Foo(i): time.sleep(1) print i + 100if __name__ == '__main__': t_start=time.time() pool = Pool(5) for i in range(10): pool.apply(Foo, (i,)) pool.close() pool.join() # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。 t_end=time.time() t=t_end-t_start print 'the program time is :%s' %t ##例子三：异步进程池使用get()方法获得进程执行结果值（错误使用get（）方法获取结果）def Bar(arg): return argif __name__ == '__main__': t_start=time.time() pool = Pool(5) for i in range(10): res = pool.apply_async(func=Foo, args=(i,), callback=Bar)#维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去 print res.get() ###错误使用get pool.close() pool.join() # 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。 pool.terminate() t_end=time.time() t=t_end-t_start print 'the program time is :%s' %t ###例子四（正确使用get（）方法获取结果） # coding:utf-8from multiprocessing import Poolimport timedef Foo(i): time.sleep(2) return i + 100def Bar(arg): return argif __name__ == '__main__': res_list=[] t_start=time.time() pool = Pool(5) for i in range(10): res = pool.apply_async(func=Foo, args=(i,), callback=Bar) res_list.append(res) ##正确使用get pool.close() pool.join() for res in res_list: print res.get() t_end=time.time() t=t_end-t_start print 'the program time is :%s' %t 进程数据共享 方法一（使用Array）：Array(‘i’, range(10))中的‘i’参数C语言中的类型：‘c’: ctypes.c_char ‘u’: ctypes.c_wchar ‘b’: ctypes.c_byte ‘B’: ctypes.c_ubyte‘h’: ctypes.c_short ‘H’: ctypes.c_ushort ‘i’: ctypes.c_int ‘I’: ctypes.c_uint‘l’: ctypes.c_long, ‘L’: ctypes.c_ulong ‘f’: ctypes.c_float ‘d’: ctypes.c_double1234567891011121314from multiprocessing import Process, Arraydef f(a): for i in range(len(a)): a[i] = -a[i]if __name__ == '__main__': arr = Array('i', range(10)) p = Process(target=f, args=(arr,)) p.start() p.join() print(arr[:]) 方法二（使用Manager）：Manager()返回的manager提供list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array类型的支持。 12345678910111213141516171819from multiprocessing import Process, Managerdef f(d, l): d[1] = '1' d['2'] = 2 d[0.25] = None l.reverse()if __name__ == '__main__': with Manager() as manager: d = manager.dict() l = manager.list(range(10)) p = Process(target=f, args=(d, l)) p.start() p.join() print(d) print(l) 网络 IP:本机IP地址一直是：127.0.0.1 ，名称一直为localhost 套接字 Python套接字编程教程（ https://docs.python.org/3/howto/sockets.html ） udp-服务器代码：服务器必须用socket包的两个方法来建立网络连接12345678910111213141516from datetime import datetimeimport socketserver_address = ('localhost', 6789)max_size = 4096 print 'starting the server at',datetime.now()print 'waiting for a client to call'server = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #创建一个套接字，SOCK_DGRAM表示发送的数据报，表示用UDPserver.bind(server_address) #绑定套接字data,client = server.recvfrom(max_size) #接收数据print ('At',datetime.now(), client, 'said', data)server.sendto(b'Are you talking to me?',client) #发送数据server.close() UDP-client代码：123456789101112131415from datetime import datetimeimport socketserver_address = ('localhost', 6789)max_size = 4096 print 'starting the client at',datetime.now()client = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #创建一个套接字，SOCK_DGRAM表示发送的数据报，表示用UDPclient.sendto(b'hey?',server_address) #发送数据data,server = client.recvfrom(max_size) #接收数据print ('At',datetime.now(), server, 'said', data) client.close() TCP-server代码：12345678910111213141516171819202122from datetime import datetimeimport socketserver_address = ('localhost', 6789)max_size = 1000 print 'starting the server at',datetime.now()print 'waiting for a client to call'server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建一个套接字，SOCK_STREAM表示发送的数据报，表示用UDPserver.bind(server_address) #绑定套接字server.listen(5) #监听client, addr = server.accept() #接收客户端连接data = client.recv(max_size)print ('At',datetime.now(), client, 'said', data)client.sendall(b'Are you talking to me?') #发送数据server.close()client.close() TCP-client代码：1234567891011121314from datetime import datetimeimport socketaddress = ('localhost', 6789)max_size = 1000 print 'starting the client at',datetime.now()client = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建一个套接字，SOCK_STREAM表示发送的数据报，表示用UDPclient.connect(address)client.sendall(b'hey')data = client.recv(max_size)print ('At',datetime.now(), 'someone said', data) client.close() 远程处理远程调用 RPC是一种非常流行的技术，有很多种实现方式。标准库中包含一种RPC实现，xmlrpc，使用XML作为传输格式。在服务器上定义并注册函数，。客户端使用类似导入方式来调用它们。xmlr_server.py 12345678910from xmlrpc.server import SimpleXMLRPCServer"""在服务器上提供了double()函数，注册函数后，才能通过RPC调用"""def double(num): return num*2server = simpleXMLRPCServer(("localhost",6789))server.register_function(double,"double")#注册函数server.serve_forever() xmlr_client.py 12345678910from xmlrpc.client"""客户端通过ServerProxy()和服务器连接。接着会调用proxy.double()"""proxy = xmlrpc.client.ServerProxy("http://localhost:6789/")num = 7result = proxy.double(num)print('Double %s is %s ' %(num,result)) 使用msgpack-rpc-python 安装：pip install msgpack-rpc-python server代码：msgpack_server.py 12345678910from msgpackrpc import Server, Addressclass Services(): def double(self, num): return num *2server = Server(Services())server.listen(Address('localhost',6789))server.start() client代码 :msgpack_client.py 123456from msgpackrpc import Client, Addressclient = Client(Address('localhost',6789))num = 8result = client.call('double',num)print("Double %s is %s " %(num, result)) 使用fabricfabric包可以运行远程或者本地命令、上传或下载文件、用sudo权限运行命令。 pip2 install fabric fab1.py123def iso(): from datetime import date print(date.today().isoformat()) 输入以下命令执行：fab -f fabl.py -H localhost iso 其中：-f fab1.py选项指定使用fabric文件执行fab1.py。-H localhosh选项指定运行本地的命令，最后的iso是fab文件中要运行的函数名。]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python真正的开发者]]></title>
    <url>%2F2019%2F04%2F08%2FPython%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%2F</url>
    <content type="text"><![CDATA[寻找Python代码 Python标准库：http://docs.python.org/3/library/ python包索引(PyPi)：https://pypi.python.org/pypi 安装包安装包的方法 用pip，如：pip install flask 用操作系统自带的包管理工具 源代码安装:python install setup.py 调试代码用pdb进行调试1、 语句123456789Python -m pdb capitals.py (Pdb) c #输入c（继续），程序会一直运行下去，直到正常结束或者出现错误(Pdb) s #单步执行，一行一行的执行Python代码，会进入函数内部(Pdb) n #也是单步执行，但是不会进入函数内部(Pdb) l #列表，查看之后的几行 -&gt; # 指示当前行(Pdb) b 6 #在第6行设置一段点(Pdb) p line #打印line的值 (Pdb) l 1 #l会显示代码行，1表示起始行。从第一行开始 记录错误日志 logging模块包含以下内容： 你想保存到日志中的消息 不同优先级以及对应的函数：debug()、info()、warn()、error()、critical(). 一个或多个logger对象，主要通过它们使用模块 把消息写入终端、文件、数据库或者其他地方的handler 创建输出的formatter； 基于输入进行筛选的过滤器。 123456789import logginglogging.basicConfig(level='DEBUG',filename='bulue_ox.log')#filename会创建一个fileHandler并对logger进行设置。logging模块至少包含15钟handler#以日期和时间的格式写入日志文件LOG_FORMAT = "%(asctime)s - %(levelname)s - %(message)s"logging.basicConfig(filename='./gzipcompressor.log', filemode='a', level=logging.DEBUG, format=LOG_FORMAT) 算法和数据结构 列表解析比添加元素快2倍。 NumPy是Python的一个数学库，它是用c编写的，运行速度很快。Python并不会编译成机器语言，而是被翻译成中间语言，然后被虚拟机解释执行。]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python系统]]></title>
    <url>%2F2019%2F04%2F08%2Fpython%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[文件 创建文件 12fb = open('test.txt','wt')fb.close() 检查文件是否存在 12import osos.path.exists('oops.txt') 用isfile()检查是否为文件 12345678#判断是否文件name = 'oops.txt'os.path.isfile(name)#判断是否是目录os.path.isdir(name)#isabs()判断参数是否是一个绝对路径名，参数不需要是一个真正的文件os.path.isabs(name)os.path.isabs('/big/fake/name') copy()复制文件copy()函数来自另一个模块shutil 12import shutilshutil.copy(oops.txt,'ohno.txt') rename()重命名文件 12import osos.rename('ohno.txt','ohwell.txt') 用abspath()获取路径名该函数会把相对路径扩展为一个绝对路径名os.path.abspath(‘oops.txt’) realpath()获取符号的路径名 remove 删除文件os.remove(‘oops.txt’) 目录 创建目录os.mkdir(‘pomes’) rmdir()删除目录os.rmdir(‘pomes’) 列出目录内容os.listdir(‘pomes’) 使用chdir()修改当前目录可以从一个目录跳转到另一个目录os.chdir(‘pomes’) glob()列出匹配文件 123456import golbglob.glob('m*')#获取以m开头的文件和目录glob.glob('？？')#获取所有名称为两个字符的文件和目录glob.glob('m????e')#获取名称为6个字符并且以m开头以e结尾glob.glob('[klm]*e')#获取所有以k、l或者m开头的文件和目录#[!abc]会匹配除了a、b和c之外的所有字符 程序和进程 进程之间是相互隔离的，一个进程无法访问其他进程的内容，也无法操作其他进程。操作系统会根据所有正在运行的进程，给每一个进程一小段运行时间，然后切换到其他进程，这样既可以做到公平又可以响应用户操作。 12345import osos.getpid()#获取当前进程id号os.getcwd()#当前工作目录os.getuid()#获取用户IDos.getgid()#获取用户组ID subprocess创建进程 import subprocess ret = subprocess.getoutput(‘date’) 使用multiprocessing创建进程 multiprocessing模块可以在一个程序中运行多个进程 123456789101112131415import multiprocessingimport osdef do_this(what): whoami(what)def whoami(what): print 'Process %s says:%s' %(os.getpid(),what) if __name__=="__main__": whoami("I'm the main program") for n in range(4): p = multiprocessing.Process(target=do_this,args=("I'm function %d" %n)) p.start() 使用terminate()终止进程123p = multiprocessing.Process(target=do_this,args=("I'm function %d" %n))p.start()p.terminate() 日期和时间 import calendar calendar.isleap(1900)#判断1900是否死闰年 datetime模块 dattime定义了4个主要的对象： date 处理年、月、日 time 处理时、分、秒 datetime 处理日期和时间同时出现的情况 timedelta处理日期和时间的间隔 12345from datetime import date halloween = date(2014,10,31)halloween.dayhalloween.monthhalloween.isoformat()#打印一个date对象，ISO是ISO 8601，一种表示日期和时间的国际标准 time模块 一种表示绝对时间的方法是计算从某个起点开始的秒数。unix时间使用的是从1970年1月1日0点开始的秒数。 time模块的time()函数会返回当前时间的纪元 localtime()函数返回当前系统时区下的时间，gmtime()返回UTC时间 strftime()12345import timenow = time.time()time.ctime(now) #把一个纪元值转换为一个字符curtime = time.strftime('%Y-%m-%d',time.localtime(time.time()))#获取当天的时间cur = time.mktime(time.strptime(curtime,'%Y-%m-%d')) 读写日期和时间 格式化字符串 日期/时间单元 范围 %Y 年 1900-… %m 月 01-12 %B 月名 January，…. %b 月名缩写 Jan-… %d 日 01-31 %A 星期 Sunday，…. %a 星期缩写 Sun-… %H 时（24小时制） 00-23 %I 时（12小时制） 01-12…. %p 上午/下午 AM，PM %M 分 00-59 %S 秒 00-59 123import timefmt ="It's %A ,%B %d,%Y,local time %I:%M%S%p"t = time.localtime() 其他模块 arrow分 dateutil iso8601 fleming 提供许多时区的函数]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据的归宿]]></title>
    <url>%2F2019%2F04%2F08%2FPython%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%92%E5%AE%BF%2F</url>
    <content type="text"><![CDATA[文件的输入/输出 一个运行中的程序会存取放在随机存储器（ARM）上的数据。 fileobj = open(filname,mode) mode的第一个字母表明对其的操作： r表示读模式 w表示写模式。如果文件不存在则新创建，如果存在则重写新内容 x表示文件不存在的情况下创建并写文件 a表示文件如果存在，在文件的末尾追加写内容mode的第二个字母是文件类型： t(或者省略)代表文本类型 b代表二进制文件 123fb = open('test.txt','wt')fb.write(str1)fb.close() write()写文本文件 数据大可以分块写： fout = open('relativity','wt') size = len(pome) offset = 0 chunk = 100 while Ture: if offset &gt; size: break fout.write(pome[offset:offset+chunk]) offset += chunk 用read、readline、readlines读取文本文件 read()读到文件末尾，再次调用read()会返回字符串‘’。 readline()读取文件的一行，readlines()调用时读取一行，并返回单行字符列表。 fout = open('relativity','wt') while Ture: line = fout.readline() if not line: break poem += line fout.close() 使用with自动关闭文件 with expression as variable: with open('relativity','wt') as fout: fb.write(str1) 使用seek()改变位置 函数tell()返回距离文件开始处的字节偏移量。函数seek()允许跳转到文件其他字节偏移量的位置。 seek(offset,origin) 如果origin=0，从头开始偏移offset个字节 如果origin=1，从当前位置偏移offset个字节 如果origin=2，距离最后结尾处偏移offset个字节 fin = open('relativity','rt') fin.tell() fin.seek(151)#偏移到151处 关系型数据库 数据库展现了表单形式的不同类型数据之间的关系，每一项有对应的关系。NoSQL数据库是键值对形式存储的数据。 db = sqlite3.connect('books.db')#连接数据库 curs = db.cursor() #创建一个cursor对象来管理数据库 curs.execute('''create table book (title text,author text,year int)''') #对数据库执行一个或多个sql命令 db.commit() #插入数据 ins_str = 'insert into book values(?, ?, ?)' with open('books.csv','rt') as infile: books = csv.DictReader(infile) for book in books: print(book) print book[' title'] curs.execute(ins_str,(book[' title'],book['author'],book['year'])) DB-API 应用程序编程接口。是访问某些服务的函数集合。DB_API是Python中访问关系型数据库的标准API。主要函数如下所示： connect（） 连接数据库，包含参数用户名，密码，服务器地址等 cursor()创建一个cursor对象来管理数据库 execute()和executemany() 对数据库执行一个或者多个SQL命令 fetchone()、fetchmany()和fetchall()得到execute之后的结果]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python数据的存取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python玩转数据]]></title>
    <url>%2F2019%2F04%2F05%2Fpython%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[Python数据编码 表1：编码方式 编码 说明 ‘ascii’ 经典的7比特ASCII编码 ‘utf-8’ 最长用的以8比特为单位的变长编码 ‘latin-1’ 被称为ISO 8859-1编码 ‘cp-1252’ windows常用编码 ‘unicode-escape’ Python中Unicode的转义文本格式，\uxxxx或者\uxxxxxxxx 解码 解码是将字节序列转化为Unicode字符串的过程。 123place = 'abcrdddd'place_bytes = place.encode('utf-8')place2 = place.decode('utf-8') 尽可能统一使用UTF-8编码，出错率低，兼容性好，可以表达所有的Unicode字符 格式化使用%的旧式格式化 表2：转换类型 格式 说明 %s 字符串 %d 十进制整数 %x 十六进制整数 %o 八进制整数 %f 十进制浮点数 %e 以科学计数法表示的浮点数 %g 十进制或科学计数法表示的浮点数 %% 文本值%本身 1234'%s' %42'%10d %10f %10s' %(n,f,s) #最小域宽为10个字符，右对齐'%-10d %-10f %-10s' %(n,f,s) #最小域宽为10个字符，左对齐'%10.4d %10.4f %10.4s' %(n,f,s) #设定最大字符宽度为4，右对齐，浮点数的精度限制在小数点后4位 使用{}和format的新式格式化12345678910111213'&#123;&#125; &#123;&#125; &#123;&#125;'.format(n,f,s)'&#123;2&#125; &#123;0&#125; &#123;1&#125;'.format(n,f,s)#0代表第一个参数d = &#123;'n':42,'f':7.03,'s':'string cheese'&#125;'&#123;0[n]&#125; &#123;0[f]&#125; &#123;0[s]&#125; &#123;1&#125;'.format(d,'other')#0代表整个字典，&#123;1&#125;代表字典后面的字符串的值'&#123;0:&gt;10d&#125; &#123;1:&gt;10f&#125; &#123;2:&gt;10s&#125;'.format(n,f,s)#最小域宽为10个字符，左对齐'&#123;0:&lt;10d&#125; &#123;1:&lt;10f&#125; &#123;2:&lt;10s&#125;'.format(n,f,s)#最小域宽为10个字符，右对齐'&#123;0:^10d&#125; &#123;1:^10f&#125; &#123;2:^10s&#125;'.format(n,f,s)#最小域宽为10个字符,居中'&#123;0:&lt;10.4d&#125; &#123;1:&lt;10.4f&#125; &#123;2:&lt;10.4s&#125;'.format(n,f,s)#设定最大字符宽度为4，右对齐，浮点数的精度限制在小数点后4位'&#123;0:!^20s&#125;'.format('BIG SALE')#用！代替空格填充 使用正则表达式匹配 相关功能都在标准库re中，因此首先需要引用他。match()函数用于查看源是否是以模式开头 123result = re.match('You','Young Frankenstein')youpatter = re.compile('You') #编译以加快匹配速度result = youpatter.match('Young Frankenstein') search()返回第一次成功匹配，如果存在的话 findall() 返回所有不重叠的匹配，如果存在的话 split()会根据pattern将source切分成若干段，返回这些片段组成的列表， sub()需要一个额外的参数replacement，它会把source中所有匹配的pattern改成replacement 特殊字符表1：特殊字符 模式 匹配 \d 一个数字字符 \D 一个非数字字符 \w 一个字母或数字字符 \W 一个非字母非数字字符 \s 空白符 \S 非空白符 \b 单词边界 \B 非单词边界 表2：模式标识符 模式 匹配 abc 文本值 （expr） expr . 除\n外的任何字符 ^ 源字符串的开头 $ 源字符串的结尾 prev? 0个或1个prev prev* 0个或多个prev，尽可能多地匹配 prev*? 0个或多个prev，尽可能少地匹配 prev+ 1个或多个prev，尽可能多地匹配 prev+？ 1个或多个prev，尽可能少地匹配 prev{m} m个连续的prev prev{m,n} m到n个连续的prev，尽可能多地匹配 prev{m,n}？ m到n个连续的prev，尽可能少地匹配 [ abd ] a或b或c [^abd ] 非（a或b或c） prev{?=next} 如果后面为next，返回prev prev{?!next} 如果后面非next，返回prev （?&lt;=prev）next 如果前面为prev，返回next （?&lt;!prev）next 如果前面非prev，返回next 注：在匹配是为了防止转义用r’\bxxxxx’， “expr1 | expr2” 表示 eppr1或expr2 。 模式：定义匹配的输出 当使用match()或search()时，所有的匹配会以m.group()的形式返回到对象m中。 123456789101112source = ''' I wish I may,I wish I might have a dish of fish tonight'''m = re.search(r'(. dish\b).*(\bfish)',source)&gt;&gt;&gt; m.group()'a dish of fish'm = re.search(r'(?P&lt;DISH&gt;. dish\b).*(?P&lt;FISH&gt;\bfish)',source)#(?P&lt;name&gt;expr)这样的匹配模式会匹配expr，并将匹配结果存入name的组中&gt;&gt;&gt; m.groups() ('a dish', 'fish')&gt;&gt;&gt; m.group('DISH') 'a dish'&gt;&gt;&gt; m.group('FISH') 'fish']]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python对象和类]]></title>
    <url>%2F2019%2F04%2F04%2FPython%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[对象 Python中所有数据都是以对象的形式出现，只有当你想要创建属于自己的对象或者需要修改已有的对象的行为时，才需要关注对象的内部实现细节。对象就是包含了代码的超级数据结构。 class 定义类123class Person(): def __init__(self):#初始化，self是参数指向了这个正在被创建的对象的本身 pass 在类声明里定义init()方法时，第一个参数必须为self，在定义类的方法（函数）时，第一个参数也必须为self。在定义中init不是必须的。只有当需要区分由该类创建的不同对象时，才需要指定。 继承 从已有的类衍生出新的类，添加或修改部分功能。习惯称原始的类为父类，超类或基类，将新的类称为子类或衍生类。 12345class Person(): def __init__(self):#初始化，self是参数指向了这个正在被创建的对象的本身 passclass People(Person):#继承了Person pass 在子类中可有覆盖父类的方法，从新实现父类的方法即可实现方法的覆盖。 用super从父类得到帮助 重子类中调用父类的方法，用super实现 1234567class Person(): def __init__(self,name):#初始化，self是参数指向了这个正在被创建的对象的本身 passclass People(Person):#继承了Person def __init__(self,name): super().__init__(name)#调用父类的方法 pass 使用属性对特性进行访问和设置 不希望别人直接访问这个特性，因此需要定义两个方法：getter，setter。123456789101112class Person(): def __init__(self,name):#初始化，self是参数指向了这个正在被创建的对象的本身 passclass People(Person):#继承了Person def __init__(self,name): super().__init__(name)#调用父类的方法 @property #用于指定getter方法 def name(self): retrun 'afad' @name.setter #用于指定setter方法 def name(self,input_name) self.name = input_name 如果没有指定setter属性，将无法从类的外部对它进行值的改变。 使用名称重整保护私有特性 对那些需要刻意隐藏在类内部的特性有自己的命名规范：由（__）双下划线开头。 12345678910class Duck(): def __init__(self): pass @property def name(self): retrun self.__name @name.setter def name(self,name) self.__name = name#这种，让外部的代码无法使用 方法的类型’ 有些数据（特性）和函数（方法）是类本身的一部分，还有一些是由类创建的实例的一部分。在类的定义中，以self作为第一个参数的方法都是实例的方法。 12345678910class A(): count = 0 def __init__(self): A.count += 1;#类特性 def __init__(self): print 'I'm an A' @classmethod#类方法，第一个参数是类本身。参数被写作cls，全称class是保留字 def kids(cls): print 'A has',cls.count,"little objects"easy_A =A() 特殊方法 特殊方法的名称以双下划线（__）开头和结束。 表1：和比较相关的方法 方法名 使用 _ _eq_ _(self,other) self == other _ _ ne _ _(self,other) self != other _ _ lt _ _(self,other) self &lt; other _ _gt_ _(self,other) self &gt; other _ _le_ _(self,other) self &lt;= other _ _ge_ _(self,other) self &gt;= other 表2：和数学相关的方法 方法名 使用 _ _ add _(self,other) self + other _ _ sub _ _(self,other) self != other _ _ _ mul _ _ _(self,other) self * other _ _ floordiv _ _(self,other) self // other _ _ truediv _ _(self,other) self / other _ _ mov _ _(self,other) self % other _ _ pow _ _(self,other) self ** other 表2：其他种类的方法 方法名 使用 _ _ str _ _(self,other) str(self) _ _ repr _ _(self,other) repr(self) _ _ len _ _(self,other) len(self) 12345678910class Word(): def __init__(self,text): self.text = text def __eq__(self,words): return self.text.lower = words.text.lower() def __str__(self,words): return self.text def __repr__(self,words): return 'Word(" 'self.text' ")'first = word('ha') 组合 将类作为参数传入另一个类。12345678910111213class Bill(): def __init__(self,description): self.description = description class Bill(): def __init__(self,length): self.length = lengthclass Duck(): def __init__(self,bill,tail): self.bill = bill self.tail = tail def about(self): print('this duck has a ',bill.description,'bill and a',tail.length,'tail')]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python中的类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python盒子：模块、包、程序]]></title>
    <url>%2F2019%2F04%2F02%2Fpython%E7%9B%92%E5%AD%90%EF%BC%9A%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[命令行参数 主要是sys库，调用sys.argv12import sysprint ('fafdsaf:',sys.argv)#接收外部的参数 模块使用别名导入模块1import report as wr # 把report别名为wr 包 把多个模块组织成文件层次，称之为包。1234567#主程序是boxes/weather.pyfrom source import daily,weekly#模块1：boxes/sources/daily.py 模块2：boxes/source/weekly.py#还要在sources目录下添加一个文件：init.py。这个文件可以是空的，但是不能少#在主程序下就可以调用source目录下的文件了import report as wr # 把report别名为wr 双端队列 模块deque，from collections import deque;函数popleft()去掉最左边的项并返回该项，pop()去掉最右边的项并返回该项。 1234567def palindrome(word): from collections import deque dq = deque(word) while len(dq) &gt; 1: if dq.popleft != dq.pop()： return False return True itertools迭代代码结构 在for…in循环中调用迭代函数，每次会返回一项，并记住当前调用的状态 12345678910import itertoolsfor item in itertools.chain([[1,2],['a','b']): print(item) #每次输出一项... 12abcycle()是在参数之间循环的无限迭代器accumulate()计算积累的值 友好输出pprint pprint()会尽量排列输出元素从而增加可读性 1from pprint import pprint 获取更多python代码 pypi: http://pypi.python.org 也称为cheese shop github： http://github.com/python readthedocs https://readthedoces.org]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2F2019%2F03%2F31%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数的定义 依次输入def，函数名，带有参数的圆括号，最后紧跟冒号（:），一个函数可以接受任何类型的值作为输入变量，并且返回任何数量的任何类型的结果。如果函数不显示调用return，会默认返回none。 注：none不代表false，作为布尔值和FALSE是一样的。12def do_nothing pass 函数的参数位置参数传入的参数值是按照顺序依次复制过去的，顺序不同，参数的引用结果不同、 关键字参数 调用参数时可以指定对应参数的名字，这样可以不遵从顺序传入的原则。若一部分指定了参数名字，而另一部分参数没有指定名字，则没指定名字的按照顺序传入的原则调用。 指定默认参数值默认参数值在函数被指定时已经计算出来了，而不是在程序运行时。 12def menu(wine,entree,dessert='pudding'): return &#123;&#125; 使用*收集位置参数12def print_args(*args): pass 星号将一组可变数量的位置参数集合成参数值的元组。同样的道理，如果你的函数同时有限定的位置参数，那么*args会收集剩下的参数。 使用**收集关键字参数使用两个星号可以将参数收集到一个字典中，参数的名字是字典的键，对应参数的值是字典的值。 12def print_args(**args): pass 如果把带有*args和**args的位置参数混合起来，就会按照顺序解析。 文档字符串在函数体开始的部分附上函数定义说明的文档，就是函数的字符串。 123456789 def print_args(**args): 'echo return its input argument' pass #可以定义更长的字符串 def print_args(**args): '''echo return its input argument gdjglajfgag jfaojigiab fjajofdi ''' pass 用Python函数help()可以打印出一个函数的文档字符串。如：help(print_args) 一等公民：函数（函数复杂定义及应用） Python中一切皆对象，包括数字，字符串，元组，列表，字典，函数。函数是Python中一等公民，可以把它们（返回值赋给变量），可以作为被其他函数调用，也可以从其他函数中返回值。 123456#函数中的函数,传入的值是一个函数名，在一个函数中调用另一个函数def run_something(func) func()#传参函数的函数def run_something(func,arg1,arg2) func(arg1,arg2) 内部函数可以在函数中定义另外一个函数 12345#返回的是一个值def print_args(**args): def inner(): pass return inner() 闭包闭包：一个可以被动态创建的可以记录外部变量的函数。 12345#返回的是一个函数，def print_args(args): def inner(): return "%s" ,%args return inner 匿名函数：lambda()函数lambda函数是用一个语句表达的匿名函数，可以用它来代替小的函数。 12345678910111213def edit_stroy(words,func): for word in words: print(func(word))def enliven(word): return word.capitalize() + '!' #调用函数为edit_stroy(starirs,enliven)#用匿名函数为edit_stroy(starirs,lambda word: word.capitalize() + '!')#lambda函数接收一个参数word。在冒号和末尾圆括号之间的部分为函数的定义。 生成器 生成器使用来创建一个Python对象的。用它可以迭代庞大的序列，且不需要在内存中创建和存储整个序列。通常，生成器是为迭代器产生数的。它会记录上一次调用的位置，并且返回下一个值。这一点和普通函数都是不一样的，一般函数不记录前一次调用，而且都会在函数的第一行执行。 12345def my_range(first=0,last=10,step=1): number=first while number &lt; last: yield number #记录上一次调用的位置，并且返回下一个值 number += step 装饰器装饰器实质是一个函数 =。它把一个函数作为输入并且返回另外一个函数。通常使用如下技巧： *args 和 **kwargs 闭包 作为参数的函数 名称中的_和_的用法12345678def my_range(first=0,last=10,step=1): number=first while number &lt; last: yield number #记录上一次调用的位置，并且返回下一个值 number += stepmy_range._name_ #显示函数名my_range._doc_ #显示文档字符串 try和except处理错误正常执行try后面的语句，错误则执行except后面的语句。 1234try： passexcept： pass 获取异常对象： except exceptiontype as name 如：except IndexError as err：将一个IndexError异常值赋给err]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python代码结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python外壳：代码结构]]></title>
    <url>%2F2019%2F03%2F30%2Fpython%E5%A4%96%E5%A3%B3%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[引言python 没有用花括号（{}）或者关键字(begin和end)来划分代码段，Python用空白来区分代码结构， 用严格的缩进来区分代码块结构。用“#”号来对代码进行注释。用“\”做为续行符来连接不同行的代码。 if、elif和else用法跟c语言的一样，不同的是，在每个判断语句后不用加括号，但是要加冒号(:),表示判断的结束。 每个判断语句下面的执行语句，要有严格的缩进，表示一个代码块。 比较操作符in 表示属于，其余跟c一样。在连接不同的比较时，有and ，or，not布尔操作符进行不同判断语句的连接。 比如：5 &lt; x and x &lt; 10;可以写成： 5 &lt; x &lt; 10;是同样的效果。 真值的判断在所有的比较判断中，非空（零）即真。 while和for循环判断同if一样，while 语句后的冒号（：）表示该语句的结束（如：while count &lt; 5 :）; for循环，在Python中也称对容器的迭代；其中列表，字符串，元组，集合等都是可以迭代的对象，基本语法：如：for rabbit in rabbits: rabbits可以是上述的迭代对象。元组或列表的迭代都是产生一项，而字符串的迭代则产生单个字符。 对字典的迭代，可以迭代键（for key in keys.key(): 或for key in keys:）也可以迭代值（for value in value.value():）,也可以用元组的方式返回（for item in accusation.items(): 或者分别赋值 for card,contents in accusation.items():）。 break和continuebreak和continue都是在循环体里使用，break跳出整个循环，continue跳出当前循环。 在循环外使用else基本形式如下： 12345678910111213141516while pos &lt; len(num): ..... break else： #没有执行break ... #for的结构for cheese in cheeses: ... break else： #没有执行break ... 上述代码，如果没有执行break，即没有找到可执行的解。则执行else。 用zip()并行迭代所谓并行迭代就是把多个列表（或者其他容器）放在一起同时迭代，在最短序列用完后，迭代结束。 1234567891011121314days = ['mon','tue',wed]fruits = ['banana','orangs','peach']drinks = ['offee','tea','beer']#在最短序列用完后结束迭代for day, fruits, drinks in zip(days, fruits, drinks): ...#用zip()配对两个元组English = 'mon','tue','wed'french = 'lundi','mardi','mercredi'list(zip(English, french))#生成字典dict(zip(English, french)) 用range（）生成自然序列range()函数可以返回在特定区间的自然序列，range(start,stop,step),start默认为0，产生的最后一个 数的值是stop的前一个：stop - 1。step默认为1；也可以反向创建自然序列，step = -1；1234for x in range(0,3):#反向创建for x in range(2,-1,-1): 推导式推导式是一个或者多个迭代器快速简洁地创建数据结构的一种方法，可以将循环和条件判断 相结合，从而避免语法冗长。 列表和集合推导式语法：[expression for item in iterable] [expression for item in iterable if condition] 集合语法：{expression for expression in iterable} 中括号变为花括号 1234567number_list = [number for number in range(0,3)]a_list = [number for number in range(1,6) if number % 2 == 1] cells = [(row, col) for row in rows for col in cols]for cell in cells: print(cell) 字典的推导式语法： {key_expression:value_expression for expression in iterable} 也可以有if判断，以及多个for循环迭代 123456789words = 'letters'letter_counts = &#123;letter:words.count(letter) for letter in words&#125;print(letter_counts) &#123;'s': 1, 'r': 1, 'e': 2, 'l': 1, 't': 2&#125;#对于程序执行来说，两次调用word.count(letter)浪费时间，因为‘t’和‘e’出现了两次# 优化如下letter_counts = &#123;letter:words.count(letter) for letter in set(words)&#125;#这是对集合进行迭代而不是字符串 生成器推导式元组是没有推导式的。用圆括号是生成器推导式 1234567891011121314 &gt;&gt;&gt; number_thing=(number for number in range(1,6))&gt;&gt;&gt; number_thing&lt;type 'generator'&gt;&gt;&gt;&gt; for number in number_thing:... print number... 12345#一个生成器只能运行一次，之后就会被擦除]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python代码结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python容器：列表、元组、字典与集合]]></title>
    <url>%2F2019%2F03%2F29%2Fpython%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E4%B8%8E%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[列表和元组 列表和元组都是包含0个或者多个元素，与字符不同，不要求所含元素的种类相同。元组是不可变的，列表是可变的。 列表的创建 列表适合利用顺序和位置定位某一元素。 用[]或者list（）创建列表1234empty_list = list()number = [1,2,3]#列表的值允许重复#列表可以包含列表 列表相关函数list()将其他数据类型转换为列表 split()函数可以将字符串分割为列表 [offset]获取列表元素，也可以用来修改相应的元素，指定切片提取元素，列如：marxes[::2]步长为2，从后往前去以负数（-1）开始，marxes[::-1]可实现逆序 append()添加元素到尾部 extend（）或+=合并列表 insert（）在指定位置插入元素，如：marxes.insert(3,&apos;fadfa&apos;) del 删除元素，如：del marxes[0],del是Python语句而不是列表方法，marxes[1].del无法进行调用。 remove()删除具有指定元素如：marxes.remove(&apos;fadfa&apos;) pop()获取并删除指定位置的元素，如marxes.pop()弹出最后一个元素，括号可以加元素的索引 index()查询具有指定元素的位置marxes.index（&apos;1122&apos;） count()记录特定值出现的次数 join（）转换为字符串，join是字符串的方法而不是列表的方法。‘445’.join(marxes) sort()重新排列元素：sort()会对原列表进行排序，改变原列表的内容，sorted()返回排好序的列表副本，原列表不变，排序中默认从小到大，可以通过reverse=true或false改变先后顺序 len()获取列表长度 in 判断值是否存在 用等号（=）或者copy（）复制列表等号，是给原始列表多加一个标签，而不会从新生成一个新列表，用下面的方法： 列表copy函数 list()函数 列表分片 元组的创建123empy = ()one = 'fafdsa', #每个元素后跟一个逗号，多个元素中最后一个元素的逗号可以省略a,b,c = 'afd','fsadf','454' #一次性将元组值赋给多个变量 元组函数tuple(marx_list) 可以将其他类型转换为元组 元组的特点 元组占用的空间小 不会意外修改元组的值 可以将元组作为字典的键 命名元组可以作为对象的替代 函数的参数是以元组的形式传递的 字典字典中每个元素有对应的键，通过键来访问元素，键可以是任意的变量，但通常是字符，字典是可变的，可以通过修改键值对字典进行修改，键之间是不能重复 字典的创建1empy = &#123;&#125; 字典的函数dict（） 转换为字典 用[key] 添加或修改元素，也可以用以获取元素 update()合并字典 del pythons[&apos;121&apos;]删除具有指定键的元素 clear（）删除所有元素 in判断是否存在 key()获取所键 values()获取所有值 items()获取所有键值对以元组的形式返回 用copy复制字典 集合 集合就像舍弃了值，只剩键一样的字典 集合的创建1empy = set() 集合的函数用in测试值是否存在 set()将其他类型转换为集合 &amp; 或intersection() 合并及运算符，可用以获取集合中的交集 | 或 union()获取集合中的并集， - 或 difference()获取集合中的差集 ^ 或symmtric_difference()获取两个集合的异或集 &lt;= 或者 issubset()判断一个集合是否是另一个集合的子集]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基本元素：字符串，数字，变量]]></title>
    <url>%2F2019%2F03%2F26%2Fpython%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E6%95%B0%E5%AD%97%EF%BC%8C%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量、名字和对象 Python里所欲的数据都是以对象的形式存在，甚至大型的数据结构、函数以及程序。 Python是很强类型的，你永远无法修改一个已有的对象的类型，即使它包含的值是可变的。 变量：就是在程序中为了方便引用内存中的值而为它取的名字。对对象的赋值并不会实际复制值，它只是为数据取个相关的名字，名字是对象的引用而不是对象的本身。比如： 吧a的值赋给b，相当于给刚刚创建的对象又贴上了标签b type（）；该函数可以打印出对象的类型 数字运算法则：跟c语言一样 但是： / 用来执行浮点除法， // 用来取整，在除法中不能除0 基数 0b或0B代表二进制 0o或0O代表八进制 0x或0X代表十六进制 int类型 Python2中一个int包含32位，long包含64位 Python3中long类型不存在，而int类型变为可以存储任意大小的整数，甚至超过64位 字符串 字符串是不可改变的，无法对字符串进行修改，但可以将字符串的一部分复制到新字符串，来达到修改的效果。 字符串的创建 字符串可以是单引号，双引号，三引号。双引号是为了创建字符串本身有单引号的字符串，三引号同理。三引号可以跨行创建字符串字符串的使用使用字符串函数 str（）可以将其参数转换为字符串 len（）获取字符串的长度 split（）对字符串进行分割，括号内填分割的字符 join（）对字符串进行合并 capitalize（）让字符串的首字母变成大写 title（）让所有单词开头变成大写 upper（）让所有字母变成大写 lower（）让所有字母变成小写 seapcase（）让所有字母大小写转换 center（30）在30个字符位居中 ljust（30）在30个字符位左对齐 rjust（30）在30个字符位右对齐 replace（）字符串替换，格式replace（’a ‘,’a famous’,100）把a 替换为a famous，替换100处。拼接字符串用+号可以直接将两个字符串相加。复制字符串用*号可以进行字符串的复制。 start = “nan” * 4 //可将nan复制4遍 用[]提取字符串偏移量可以从0开始增加到字符串长度-1。从左到右从0开始，从右到左从-1开始计数， [start:end:step] 可对字符串进行分片。 [:] 提取从开头到结尾的整个字符串 [start:]从start提取到结尾 [：end]从头提取到end-1 [star:end] 从start提取到end-1 [start:end:step] 从start提取到end-1，步长为step]]></content>
      <categories>
        <category>Python心得</category>
      </categories>
      <tags>
        <tag>Python基本元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[番茄助手的安装]]></title>
    <url>%2F2019%2F03%2F24%2F%E7%95%AA%E8%8C%84%E5%8A%A9%E6%89%8B%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[visual assist的安装1、 visual assist软件下载https://pan.baidu.com/s/1uD7GmjuSbdemNOdEhFqReQ rr8i 2、 visual assist X通用补丁下载https://pan.baidu.com/s/1u-vOHdN7-m5vqiG6R1aEpA ed1q 步骤： 安装完visual assist软件软件后，打开通用补丁，直接点击安装就破解了visual assist，如果之前有安装过其他的破解补丁，先点击卸载，卸载后再安装。 自定义vs的快捷键1、步骤 工具-&gt;选项-&gt;环境-&gt;键盘； 搜索你定义快捷键的功能，然后按自定义的快捷键即可；比如： 修改返回上一处光标位置，之前的快捷键是“Ctrl + -”；搜索“向后”（Navigatebackward），然后修改自己的快捷键即可，同理向前（navigateForward）。]]></content>
      <categories>
        <category>visual studio的使用</category>
      </categories>
      <tags>
        <tag>visual assist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的日志与进程管理]]></title>
    <url>%2F2019%2F03%2F16%2Flinux%E7%9A%84%E6%97%A5%E5%BF%97%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601%2F</url>
    <content type="text"><![CDATA[nice:设置优先级 语法：nice [-可选参数] [指令] [属性]范例12 nice -n 17 free -s 60&amp; # 在后台运行free指令，设置优先级为17# 注解：将free -s 60&amp;的优先级设为17，通过ps -l输出的NI项就可以看当前系统中相关进程的优先级 ps指令：报告程序状况 语法：ps [-可选参数] 范例12ps -a #显示系统进程pstree -anh #显示进程间的关系 a:显示完整的指令，n:以进程ID排序，h:对现在执行的程序进行特别标注 fg：将后台任务拉到前台执行范例12ftp 192.198.88.2 &amp;fg %1 #将ftp拉到前台执行 killall：杀死同名的所有进程范例1killall joe]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux网络服务01]]></title>
    <url>%2F2019%2F03%2F14%2Flinux%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A101%2F</url>
    <content type="text"><![CDATA[ifconfig: 显示或者配置网络设备 语法：ifconfig [网络设备] [-可选参数] 范例12345ifconfig #显示当前网络设备状态ifconfig eth0 192.168.1.1 netmask 255.255.255.0 #配置网卡参数ifconfig eth1 down #关闭网卡ifconfig eth1 up #开启网卡ifconfig eth1 hw ether 00:10:B2:56:64:2B #修改网卡的物理地址 ping:测试网络 语法：ping [-可选参数] 网络地址 范例12ping 128.168.12.13 #检测ping的与远端主机的连通情况ping -c 128.168.12.13 #指定发送数据包的次数 netstat：显示网络状态 语法：netstat [必要参数] [选择性参数] 范例12netstat -r #显示系统的路由表netstat -an #显示详细的网络状况 telnet:远程登录 语法：telnet [-可选参数] 主机名/IP 范例1telnet 192.168.1.1 #远程登录 rsh ：远端登录的shell 语法：rsh [-可选参数] 主机 指令 范例123chkconfig rlogin on #启动rlogin工具rlogin 192.168.1.1 #登录远程主机rsh -l mary 192.168.1.1 /bin/pwd #登录远程主机执行指令/bin/pwd,要正确执行该指令，必须现在远程主机192.168.1.1上启动rlogin指令]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux磁盘操作管理]]></title>
    <url>%2F2019%2F03%2F13%2Flinux%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9C%E7%AE%A1%E7%90%8601%2F</url>
    <content type="text"><![CDATA[badblocks ：检查磁盘坏道 语法：badblocks [-可选参数] 磁盘设备 [结束块 [启始块]] 参数说明 参 数 说明 -f 强制检查一个已经挂载的设备 -b&lt;区块大小&gt; 指定磁盘的区块大小，以字节为单位 -c&lt;区块大小&gt; 指定每个磁盘区块检查的次数 -i&lt;文件&gt; 跳过保存在指定文件中的坏道消息，避免重复检查 -o&lt;文件&gt; 将检查的结果输出到指定的文件中进行保存 -s 显示检查进度 注：/dev/hd:IDE磁盘；/dev/sd:SCSI磁盘；/dev/ed:ESDI磁盘；/dev/fd:软磁盘 范例123badblocks /dev/fd0H1440 #检查整个磁盘是否有坏道badblocks -b /dev/hdal -o had-badblocks #检查/dev/hdal 是否有坏道，同时将检查的结果保存到文件hda-badlocks中\#如果有坏道查看文件将显示列表，如果没有无信息被列出 df:磁盘信息 说明：使用df查看磁盘空间的信息，可以查看文件系统的占有情况。 语法：df [-可选参数] [文件或设备] 参数说明 参 数 说明 -h 以可读性较高的方式显示 -H 相当于“-h”，但在计算时，1K = 1000,而不是1024 -a 显示包括0块在内的所有文件系统的情况 -i 显示inode节点信息 范例1234df #显示磁盘信息df -hdf -iadf -t ext2 #显示当前磁盘的文件系统的信息 du ：显示目录或者文件所占的磁盘空间范例12du ax #显示ax文件占用的磁盘空间du #显示当前目录所占的磁盘空间 tree ：以树状图显示目录内容 语法：tree [-可选参数] [目录] 范例1tree]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下的文本编辑01]]></title>
    <url>%2F2019%2F03%2F11%2Flinux%E4%B8%8B%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%9101%2F</url>
    <content type="text"><![CDATA[vim :文本编辑 语法：vim [-可选参数] [文件]vim环境下的常用指令 命令模式：D:删除光标所在行后的所有词nG：n为数字，将光标移至第n行位置p：将复制的内容粘贴到光标所在位置r：修改光标所在处的字符x：删除光标所在处的字符X：删除光标所在处的前一个字符d+d：连按两次，将删除光标所在行n+d+d：n为数字，删除光标所在行及其下面的n-1行，共n行y+y：整行复制Ctrl+b：向上翻一页Ctrl+f：向下翻一页Ctrl+d：向后翻半页Ctrl+u：向前翻半页Ctrl+g：在最后一行处显示光标所在位置的行数和文章的总行数 输入模式：i：从当前光标处插入I：从当前光标所在行的行首开始插入o：在当前光标所在行下方新增一行，从新增行的行首开始输入O：在当前光标所在行上方新增一行，从新增行的行首开始输入 末行模式：n:加载文件：w:存盘：w newfile：文件另存为：wq：存盘退出：W!：对只读文件强制写入存盘：q：退出：q！：强制退出：set nu：在每行的开头显示行数：set none：取消每行开头的行数显示：/字符串：匹配字符串查找，按n向下查找，N向上查找 wc：计算字数 语法：wc[-可选参数][文件] 参数说明 参 数 说明 -c 只显示字符数 -l 只显示行数 -w 只显示字数 范例wc -c ar #计算字节数 wc -w ar # 计算字数 wc -l #计算行数 tail ：显示文件的末尾内容 语法：tail [ 必要参数] [选择性参数][文件] 参数说明（1）必要参数 参 数 说明 -f 循环读取 -q 不显示处理信息 -v 运行时显示详细的处理信息 （2）选择性参数 参 数 说明 -c 要显示的字节数 -n 显示的行数 -help 帮助信息 范例tail -n 30 install.log #显示文件末尾30行的内容 tail -f 2.log #显示文件内容。2.log文件是更新的，-f可以动态监测文件末尾的内容 tail -n 5 *.log #显示文件末尾内容]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux文件操作与管理03]]></title>
    <url>%2F2019%2F03%2F09%2Flinux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%AE%A1%E7%90%8603%2F</url>
    <content type="text"><![CDATA[rcp ：远程复制文件或目录 语法：rcp [- 可选参数]远程/本地主机名：源文件/目录 本地/远程主机名：目标文件/目录 参数选择 参 数 说明 -p 保留源文件/目录的属性 -r 处理指定文件夹下的文件及其子目录下的所有文件 范例1rcp -p 192.168.1.121:/home/vc /home/yy/ #复制文件，将远程文件复制到本地/home/yy/，同时保留源文件的属性，一般主机名不用给 tar ：打包同时压缩/解压文件 语法：[- 可选参数] [文件] 参数选择 参 数 说明 -c 压缩文件 -x 解压文件 -r 添加文件到已存在的备份文件的尾部 -j 使用bzip2压缩文件 -z 使用gzip压缩文件 -v 显示详细信息 -f 指定备份文件 范例123tar -xzvf s1.tar.gz #解压s1.tar.gz 文件tar -czvf s1.tar.gz *.txt #压缩.txt文件tar -c a1.txt a2.txt &gt;s1.tar #打包文件 whereis ，which：查找文件-语法 ：whereis/which [-可选参数] 文件 范例12whereis *.txt #查找文件，查找目录下的.txt文件which az #查找文件，执行which az， 在环境变量$PATH指定的目录“/usr/bin”下查找文件，显示查找结果 info：读取目录信息范例12info init &gt;1.log #显示init的帮助信息info info #显示info的具体使用方法]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux文件操作与管理02]]></title>
    <url>%2F2019%2F03%2F08%2Flinux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%AE%A1%E7%90%8602%2F</url>
    <content type="text"><![CDATA[less :一次显示一页文本 语法 ： less [-参数] 文件名 范例1less a3.txt 注：显示文本后：按b：向后翻页，d：向后翻半页，h:显示帮助界面，u：向前滚动半页，y:向前滚动一行；回车键：滚动一行；空壳键：滚动一页；q：退出 mv：移动或更名现有的文件或目录 语法：mv [-可选参数] 源文件 目标文件/目录 范例1mv a.txt b.txt ncftp：文件传输指令 语法：ncftp [-可选参数] [主机/IP地址] 参数选择 参 数 说明 -u&lt;用户名&gt; 使用用户名 -p&lt;密码&gt; 使用指定密码 -P&lt;端口号&gt; 使用指定端口号，默认为21 范例1234ncftp -u sy114 -p 123456 192.168.128.1 #登录##相似的命令ncftpget -u sy114 -p 123456 192.168.128.1 /home/yy1/vc #下载文件ncftpput -u sy114 -p 123456 192.168.128.1 /home/yy1/vc #上传文件 注：登录上后跟ftp指令相似 paste：合并文件 语法：paste [-可选参数] [文件]范例12paste a1 a2 #合并文件的行paste -s a1 a2 #合并文件的行，并指定间隔符 patch：修补文件，给文件打补丁 语法： patch [-可选参数] [文件]范例12diff a1 a2&gt;sy.diff #比较文件的差异，生成差异文件sy.diffpatch a1&lt;sy.diff #修复a1]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux文件操作与管理01]]></title>
    <url>%2F2019%2F03%2F06%2Flinux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%AE%A1%E7%90%8601%2F</url>
    <content type="text"><![CDATA[diff：生成差异文件（1）参数说明 参 数 说明 -c 显示所有内容，同时标出不同之处 -a 对文本文件进行逐行比较，非文本文件看作文本文件进行比较 -i 忽略大小写的不同 -r 比较目录时递归比较子目录中的文件 范例123diff -a a1.txt a3.txt #比较两个文件的不同diff Desktop/yy1 Desktop/yy2 # 比较两个文件夹的不同diff -c a1.txt a3.txt #比较两个文件的不同，并生成差异文件 find ：查找目录或者文件 语法： find[路径][-可选参数] 范例12345find *.txt # 查找.txt的文件find /root/edsktop/yy1/ -ctime -2 #查找448小时内被修改过的文件find -name yy* #查找指定字符串类型的目录find -name yy.*#查找的结果是以yy命名的文件find -size 0#查找字节数为0的文件 ftp ：文件传输指令范例1ftp 192.168.1.1 connected to 192.168.1.2#使用ftp地址建立ftp连接 注：建立的过程会输入用户名和密码，建立之后可用get和put指令实现文件的上传和下载删除文件用delete指令 gunzip：解压文件范例12gunzip yy.txt.gz #解压文件gunzip -l yy.txt.gz #解压文件时显示文件相关信息 gzip：压缩文件范例12gzip -v yy.txt #压缩文件时显示文件相关信息gzip -d yy.txt.gz #解压指定文件]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qt-for-android的安装]]></title>
    <url>%2F2019%2F03%2F05%2Fqt-for-android%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[QT软件的安装下载软件https://pan.baidu.com/s/1o8CxKaptmVthHVE3x3sjXw zndu参考相关博客链接：https://www.jianshu.com/p/437465a530dc https://blog.csdn.net/qq_32250025/article/details/79106662 1、安装安装 java -jdk ,android-ndk,android-sdktools 安装 java -jdk，对应版本：jdk1.8.0_201 安装android-ndk ， 安装ndk的时候，android-ndk-r10e以上的版本没有arm-linux-androideabi-gdb.exe，所以在下载安装包的时候不能下载版本太高，10以下的版本就够. 安装android-sdktools 在安装sdk的时候会出现jdk找不到，或者版本过低，这时要先配置环境变量。当配置好环境变量出现版本过低的时候要重新下载jdk安装文件重新安装，之前我安装jdk-11.0.2后，再安装sdk时出现版本过低，重新下载了jdk1.8.0_201安装就可以。在配置qt文件的时候会出现不适一个平台，这时候要启动sdk文件夹下的SDK Manager.exe安装Android包。 安装ant 这个是在qt软件上:工具-&gt;选项-&gt;android:下的Ant executable项后面有一个下载的符号，点击可自动下载。ps：对应的软件都在网盘里环境变量的配置(1) JAVA_HOME 值： C:\Program Files\Java\jdk1.8.0_45(2)ANDROID_HOME 值：D:\Android\sdk(3)CLASSPATH 值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 编译文件 在构建的时候选择Android构建和运行就能够编译出.apk文件，对应的文件再编译文件夹下的/bin目录]]></content>
      <categories>
        <category>QT学习</category>
      </categories>
      <tags>
        <tag>QT for Android环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux用户指令01]]></title>
    <url>%2F2019%2F03%2F03%2Flinux%E7%94%A8%E6%88%B7%E6%8C%87%E4%BB%A401%2F</url>
    <content type="text"><![CDATA[who：显示系统用户信息范例12who #显示当前登录系统的用户信息who -l -H# 显示用户登录位置 whois：查找用户/域名信息范例12whois mary #查找Mary用户的信息whois www.miwifi.com # 查找目标网络信息 bunzip2，bzip2，bzip2recover：解压.bz2类型的文件，压缩成.bz2文件，损坏.bz2文件的修复范例12345bunzip2 -c filename.bz2 #解压后文件直接输出到标准输出bzip2 filenamebzip2 -7 -k filename #压缩文件filename并保留原文件bzip2-b filename.bz2 #解压文件bzip2recover filename #修复.bz2文件 linux中cat、more、less命令区别详解 linux中命令cat、more、less均可用来查看文件内容，主要区别有： cat是一次性显示整个文件的内容，还可以将多个文件连接起来显示，它常与重定向符号配合使用，适用于文件内容少的情况；more和less一般用于显示文件内容超过一屏的内容，并且提供翻页的功能。more比cat强大，提供分页显示的功能，less比more更强大，提供翻页，跳转，查找等命令。而且more和less都支持：用空格显示下一页，按键b显示上一页。下面详细介绍这3个命令。]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基本配置指令05]]></title>
    <url>%2F2019%2F02%2F25%2Flinux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A405%2F</url>
    <content type="text"><![CDATA[pkill ：杀死进程 语法: pkill [必要参数][选择性参数][字符串] 功能说明：pkill指令是和kill指令的结合，用来杀死指定的进程必要参数 参 数 说明 -n 显示新进程 -v 与条件不符的进程 -x 与条件符合的程序 -t 指定终端下的进程 -u 指定用户的程序 范例12345pkill -9 ftp #杀死进程ftppkill -t tty1 #杀死所有终端1下的进程ps -A #显示所有进程pkill -u kk #杀死用户kk的所有进程pkill -vu kk #杀死不属于用户kk的所有进程 pmap ：显示程序的内存信息范例123pmap -2253 #显示进程2263的内存信息pmap -x 2253 #显示进程2263使用内存的详细信息pmap -d 2253 #显示内存对应同时显示设备号 pwck ：检查密码文件 语法 : pwck [必要参数][文件] 范例pwck /etc/passwd #检测密码文件]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基本配置指令04]]></title>
    <url>%2F2019%2F02%2F24%2Flinux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A404%2F</url>
    <content type="text"><![CDATA[export ：设置或在显示环境变量范例12export -p #列出所有环境变量export M_ENV = http://www.linux.org/ #定义环境变量 lsmod：显示Linux内核的模块信息范例1lsmod #显示载入系统的模块信息 reboot指令：重新启动 语法: reboot [-可选参数]范例123reboot -f #强制重启reboot -i #关闭网络设置后在重新启动reboot -n #先保存数据，再重启 hostname ：显示或者设置当前系统的主机名 语法：hostname [必要参数][选择性参数] 范例123hostname -i #显示主机ip地址hostname -d #显示主机域名hostname Apple #设置主机名称]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基本配置指令03]]></title>
    <url>%2F2019%2F02%2F23%2Flinux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A403%2F</url>
    <content type="text"><![CDATA[manpath ：设置man手册的查询路径范例12manpath #列出目前的查询路径manpath -M /home/zhang #指定查询路径 free：显示内存信息范例1234free -b #以字节为单位显示free -k #以KB为单位显示free -m #以MB为单位显示free -s 10 #每隔10s执行一次free，连续显示内存信息 crontab ：指定自动执行任务 语法: crontab [-u&lt;用户名&gt;] [-可选参数] 创建新的 crontab 文件，或编辑现有文件 创建 crontab 文件的最简单方法是使用 crontab -e 命令。 此命令会调用已为系统环境设置的文本编辑器。系统环境的缺省编辑器在 EDITOR 环境变量中定义。如果尚未设置此变量，crontab 命令将使用缺省编辑器 ed。最好选择您熟悉的编辑器。以下示例说明如何确定是否已定义编辑器，以及如何将 vi 设置为缺省值1234$ which $EDITOR$ $ EDITOR=vi$ export EDITOR 创建 crontab 文件时，该文件会自动放入 /var/spool/cron/crontabs 目录， 并以您的用户名命名。如果具有超级用户特权，则可为其他用户或 root 创建或编辑 crontab 文件。 $ crontab -e [username]以下示例说明如何为其他用户创建 crontab 文件1234crontab -e jones1 0 * * 0 rm /home/jones/*.log &gt; /dev/null 2&gt;&amp;1 #添加到新 crontab 文件中的以下命令项将在每个星期日的凌晨 1:00 自动删除用户起始目录中的所有日志文件。由于该命令项不重定向输出，因此将重定向字符添加到 *.log 之后的命令行中。这样可以确保正常执行命令。crontab -l #列出目前的时程表crontab -r #删除目前的时程表 时程表格式如下123456 f1 f2 f3 f4 f5 program#其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。#当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推#当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推#当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推#当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其馀类推]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的基本配置指令02]]></title>
    <url>%2F2019%2F02%2F22%2Flinux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A402%2F</url>
    <content type="text"><![CDATA[clear 指令：清除屏幕信息 目的：对杂乱的屏幕进行清理 语法： clear date 指令： 显示或设置系统时间指令 目的：根据指定格式显示或设置当前系统的时间 语法：date [-可选参数][日期和时间格式] 格式为MMDDhhmm范例12datedate “Date:%Y.%m.%d Time:%H.%M.%S” echo指令：字符串输出 目的；应用该指令的字符串的值输出到标准输出 语法：echo [-可选参数] 字符串输出（1）必要参数 参 数 说明 -n 不在最后自动换行 -e 若字符串出现以下字符，加以特别处理 \a发出警告 \v删除前一个字符 \c最后不加换行符号 \f换行但光标任停在原来的位置上 \n换行且光标移至行首 \r光标移至行首，但不换行 \t插入tab \v同\f \在输出插入\字符 \nnn 将nnn看做八进制，输出它所代表的ASCII字符 -help 帮助信息 -version 版本信息 范例1echo -e “123456\n”]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用的指令]]></title>
    <url>%2F2019%2F01%2F20%2Flinux%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux查询进程指令1、进程查询指令1ps -ef | grep calculatorBuysell | grep -v grep | wc -l 注：该命令可以查询calculatorBuysell进程的个数]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大牛们的博客网站]]></title>
    <url>%2F2018%2F12%2F09%2F%E5%A4%A7%E7%89%9B%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[大牛们的博客网址 http://www.yanmin99.com/]]></content>
      <categories>
        <category>初识hexo</category>
      </categories>
      <tags>
        <tag>初识hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next创建about]]></title>
    <url>%2F2018%2F12%2F09%2Fhexo%E7%9A%84next%E5%88%9B%E5%BB%BAabout%2F</url>
    <content type="text"><![CDATA[hexo的next创建about创建步骤 1、新建一个about页面，命令如下 ： 1$ hexo new page about 注：在myBlog/source下会生成一个行的文件夹about，在该文件夹下会有一个index.md文件 - 2、 菜单显示about链接，在主题的thems/next/_configy.yml设置中将menu中的about前面的注释去掉 123456menu:home: /archives: /archives/categories: /categories/tags: /tags/about: /about/]]></content>
      <categories>
        <category>初识hexo</category>
      </categories>
      <tags>
        <tag>初识hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 标准头文件]]></title>
    <url>%2F2018%2F10%2F20%2Fc-%E6%A0%87%E5%87%86%E5%A4%B4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[常用到的头文件1234567#include &lt;string&gt; //标准字符串类#include &lt;iostream&gt; //标准输入输出#include &lt;vector&gt; //标准向量容器#include &lt;set&gt; //标准集合容器#include &lt;map&gt; //标准映射容器#include &lt;algorithm&gt; //标准算法using namespace std; //打开标准库的名字空间]]></content>
      <categories>
        <category>boost库开发</category>
      </categories>
      <tags>
        <tag>c++ &amp; boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习软件的安装]]></title>
    <url>%2F2018%2F10%2F19%2F%E5%AD%A6%E4%B9%A0%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[vs软件的安装 安装软件百度云盘的visual studio 文件夹下有安装包：zmvss2k8.iso，兼容性补丁包：VS2008SP1ENUX1512962.iso以及番茄助手：Visual Assist X 2048 安装步骤先安装zmvss2k8.iso，再安装VS2008SP1ENUX1512962.iso。安装文件是.exe结尾的目标文件。再安装番茄助手安装后将破解动态库VA_X.dll替换到安装文件夹下。注：安装过程中会出现安装Windows的.net文件。打开Windows的更新直接更新 配置boost库https://blog.csdn.net/qq1987924/article/details/7897503 modelsim安装 软件位置百度网盘上modelsim文件夹下 安装步骤先安装.exe的文件，再打开破解器破解，破解方式： https://www.cnblogs.com/lamblabs/p/8604360.htmlPython安装 软件位置百度网盘上Python软件文件夹下 安装步骤直接安装无需破解虚拟机安装 安装步骤软件在百度云盘上虚拟机软件文件夹下，直接安装无需破解hexo和git的安装 安装步骤软件在百度云盘的hexo&amp;git文件夹下直接安装注：进入我的博客文件夹下安装 配置hexohttps://www.cnblogs.com/fengxiongZz/p/7707219.html QT的安装 安装步骤软件的位置在百度网盘上qt软件文件夹下，安装教程参考如下网站：https://jingyan.baidu.com/article/656db918d9292ae380249c4f.html quartus II的安装 软件位置百度网盘上，FPGA的文件夹下 安装及破解步骤https://blog.csdn.net/qq_18649781/article/details/81025650]]></content>
      <categories>
        <category>安装软件</category>
      </categories>
      <tags>
        <tag>软件的安装</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[title:Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[选购主板]]></title>
    <url>%2F2018%2F10%2F17%2F%E9%80%89%E8%B4%AD%E4%B8%BB%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[主板的认识 主板是一个电脑的中枢，所有部件及其外设只有通过它才能与处理器连接在一起进行通信，并由处理器发出相应的操作指令执行相关的操作。 主板上包含CPU、内存条插座、芯片组、BIOS芯片、供电电路、各种接口插座、各种散热器等部件。它们决定了主板的性能和类型。 主流主板 目前有Intel公司处理器的主板和AMD公司处理器的主板。 识别主板芯片组 主板芯片组是主板的灵魂与核心，芯片组的性能优劣决定了主板性能的好坏。所有的信息都是交给芯片组来完成的。在主板的构架中，北桥芯片和南桥芯片是硬件设备进行通信及沟通的桥梁。 北桥芯片位于CPU插座与pci-e插槽的中间，其芯片体型较大，一般会覆盖一个散热风扇。北桥芯片主要负责联系CPU和控制内存。 南桥芯片一般位于主板的下方，PCI插槽附件。它主要负责支持键盘控制器、USB接口、实时时钟控制、数据传递方式和高级电源管理。 主板BIOS芯片BIOS实际上是“Basic Input/Output System”的英文缩写，中文意思是“基本输入/输出系统”。BIOS实际上 是电脑中底层的一种程序。当启动系统时，BIOS进行加电自检、检查系统基本部件，然后系统启动启动程序将系统的配置参数写入CMOS中。 CMOS指的是主板上的一块可以反复读写的RAM芯片，也称为互补金属氧化物半导体随机存储器。CMOS主要用来保存当前系统的硬件配置和用户对某些参数的设定，靠一块纽扣电池供电，即使断电内容也不会丢失。 CMOS跳线 1 跳线的目的 用于清除CMOS中的数据，在清空数据之后，BIOS将出厂时的原始数据传给CMOS存储器。 2 CMOS跳线的作用 用放电的方法来清除开机密码或者BIOS进入密码。 3 CMOS跳线的方法 将CMOS电池旁边的跳线帽拔出，插入另外一个针和中间针上几秒，然后在拔出插回原来的位置。或者将电池取出，将电池盒上的正负极短路几秒，再把电池安上即可。硬盘接口 硬盘的接口非常多，主要有IDE接口、SATA接口、SCSI接口、Fibre Channel接口、IEEE1394接口和USB接口。 1 IDE接口 IDE接口的英文全称为integrated Drive Electronics（电子集成驱动器），它的本意是把盘体与控制器集成在一起的做法减少了硬盘的接口电缆数目与长度，数据传输可靠得到了增强，硬盘控制起来变得更容易。 有39针的接口 2 SCSI接口SCSI的英文全称是small computer system interface（小型计算机系统接口）。它的优势在于支持多种设备，独立的总线使得他对CPU的占用率很低，传输速率也比ATA接口快很多，但价格也高很多。 3 SRIAL ATA接口 用四个针口就完成了所有工作，SATAII接口的传输速率达到了3Gbps，SATAIII接口的传输速率达到了6gbps。 4 Fibre channel 接口 中文名“光纤通道”，它与SCSI接口祸IDE接口有很大不同。]]></content>
      <categories>
        <category>电脑硬件选购</category>
      </categories>
      <tags>
        <tag>电脑主板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选购CPU]]></title>
    <url>%2F2018%2F10%2F15%2F%E9%80%89%E8%B4%ADCPU%2F</url>
    <content type="text"><![CDATA[初识cpu CPU是central processing unit的缩写，中文名称是“中央处理器”。其内部结构归纳起来可分为：控制单元、逻辑单元和存储单元三部分，这三部分相互协调，可以进行分析判断、运算并控制电脑各个部分协调工作。 CPU的生产商及产品 目前世界上生产CPU的厂商主要有Intel公司，AMD公司 inter公司的产品主要是酷睿i系列。 处理器核数 1 Intel公司Intel公司六核处理器主要有：i7-5930K、i7-4960X、i7-4930K、i7-3970X等Intel公司四核处理器主要有：第三代、第四代核第六代corei7四核处理器，第三代、四代核六代corei5四核处理器。 2 AMD公司 AMD公司主流cpu有FX系列8核，6核、4核处理器， APU系列4核、三核、双核处理器， phenomII（羿龙II）X4四核、X3三核、X2双核等。CPU及CPU散热器选购实战 1 主频购买不要追求过高的主频。 2 注意购买时机购买时可以选择推出半年到一年的CPU产品 3 注意应用需求在不同的应用环境下对于CPU的性能需求是不同的，所以，在进行电脑选购时必须注意“适合应用”的原则。 4 注意预防购买假的CPU（1） 看分界线 原包装在外盒背面印有多种文字的产品介绍，这些文字的上下分界处，有一行看起来很像黑道的分解线。如果是正品的话，即可发现这些黑道其实是极小的“intel”标志组成，而且十分清晰。（2）看包装盒颜色正品色彩鲜艳，次品色彩比较浅。（3）看封装线正品盒装Intel CPU的塑料封纸的封装线不可能在盒的右侧条形码处。（4）看水印字 正品刮不下来（5）看激光标签正品采用了四重着色技术，层次丰富，字迹清晰。（6）电话查询盒装上有一串很长的编码，可以通过拨打热线电话800-820-1100来查产品的真伪。（7）看热封点正品有4个热封点，每个热封点有两个圆点，它们在揭开后就不能复原。（8）看风扇看风扇的热片和轴承，原装的风扇的轴承是金属的，散热片见得凹槽为圆弧形，而且热片的低端厚实。假风扇的做工很粗糙，手感很轻。 5 使用时尽量选择高外频在主频情况相同的情况下，更高的外频和前端总线可以提供更大的数据传输带宽，因此相对来说表现也更优秀。CPU风扇选购实战 1 cpu风扇的生产厂商：清华华天公司，富士康公司、博美特公司注：除了风冷扇热之外，还有一种比较好的散热方式-水冷散热。]]></content>
      <categories>
        <category>电脑硬件选购</category>
      </categories>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑的组成]]></title>
    <url>%2F2018%2F10%2F15%2F%E7%94%B5%E8%84%91%E7%9A%84%E7%BB%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[电脑装机维修预备知识 1 主机的内部构造主机中主要包括：电源、cpu、内存、主板、硬盘、显卡、声卡、网卡、光驱等（1）主板主板把电脑的各个部件联系到一起，各个部件通过主板进行数据的传输。它工作的稳定性直接影响整机的工作的稳定。 2 电脑的软件系统（1）操作系统软件（2）程序设计软件（3）应用软件注： 连接各个设备时电源线要最后连接，其他设备随意。 制定多核电脑配置方案 1 原则（1）购买电脑的目的 简单用途普通配置，复杂用途高档配置。（2）购买者的资金状况（3）确定资金消费重点 如果购机时资金不是很充足，这时应该根据购机目的和实际情况，确定资金消费的、重点。如商务用机，应侧重于显示器和主板的选择。 2 配置方案类型（1）入门型用户 2000-3000元（2）大众型用户 3000-6000（3）专业型用户6000-10000查看系统信息依次单击“开始-&gt;所有应用-&gt;windows管理工具-&gt;系统信息”]]></content>
      <categories>
        <category>电脑硬件选购</category>
      </categories>
      <tags>
        <tag>主机硬件结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[purchase hard-disk]]></title>
    <url>%2F2018%2F10%2F14%2Fpurchase-hard-disk%2F</url>
    <content type="text"><![CDATA[选购硬盘1、 硬盘的认识 硬盘的内部包括磁盘、读写磁头、精密的电动机和线路等。硬盘转速有3600r/min、4500r/min、5400r/min、7200r/min及10000r/min.2、 硬盘的选购指标 容量、转速、换成、传输率、接口、单碟容量等。尽量购买保质时间长的硬盘。注意硬盘的生产日期。如果发现后面有个”R“字母，这块硬盘是返修的，或者有“refurbished”的字样，也说明硬盘是返修的。3、 硬盘接口主流用的是SATA接口标准为SATA 3.0规格，它的传输输速率可达到6Gbit/s，因此，选择要注意硬盘的接口。 固态硬盘是采用固态电子存储芯片阵列而制成的硬盘，它由控制单元和存储单元组成。固态硬盘在接口、功能和使用方法上与普通硬盘相同。 主流硬盘1、希捷2、西部数据3、日立4、三星 硬盘相关参数的识别]]></content>
      <categories>
        <category>电脑硬件选购</category>
      </categories>
      <tags>
        <tag>电脑硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[purchase memory]]></title>
    <url>%2F2018%2F10%2F14%2Fpurchase-memory%2F</url>
    <content type="text"><![CDATA[选购内存 内存的分类第一种是DRAM(动态内存),此内存集成度高，功耗和成本低，是目前主流产品，第二种是SRAM（静态内存），广泛用于工作站，高档电脑、大型机和巨型机种的Cache（缓存） 内存选择（1） DDR SDRAM内存 双倍数据速率同步内存，DDR2内存即第二代同步双倍速率动态随机存取存储器。DDR2内存可进行4bit预读取，DDR3可进行8bit，DDR4 16bit预取机制，是DDR3的两倍。（2）选择容量1）用来上网、学习、游戏、办公、炒股、文字处理、配置8GB内存总体够用。2）用来刻录、视频影像处理，8GB够用，16GB好用3）用来编程16GB内存较好4）用来二维或者三维图形图像设计，配置8GB内存勉强用，16GB够用，32GB内存好用。5）用来设计、密集数据采集运算、虚拟现实等，配置16GB内存勉强，32GB够用6）用来作web服务器，配置8GB内存勉强，32GB内存够用。售后也很重要。 内存的速率目前主流内存的速率小于1.5ns “打磨”内存 正品的芯片表面一般都有质感，要么有光泽或荧光感，要么就是亚光。如果芯片的表面色泽不存甚至比较粗糙、发毛，芯片必然受到了打磨。内存的生产商1、 金士顿（Kingston）2、 金邦（GEIL）3、 宇瞻（Apacer）4、 胜创（KINGMAX）相关参数的识别]]></content>
      <categories>
        <category>电脑硬件选购</category>
      </categories>
      <tags>
        <tag>电脑内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[table]]></title>
    <url>%2F2018%2F10%2F05%2Ftable%2F</url>
    <content type="text"><![CDATA[表格样式md 水果 价格 数量 香蕉 $1 5 苹果 $1 6 草莓 $1 7]]></content>
      <categories>
        <category>学习表格</category>
      </categories>
      <tags>
        <tag>表格的格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python eval函数]]></title>
    <url>%2F2018%2F10%2F04%2Fpython-eval%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python中eval函数的作用1、函数说明eval函数就是实现list、dict、tuple与str之间的转化str函数把list、dict、tuple转为字符串eg1：字符串转换成列表1234567a = "[[1,2], [3,4], [5,6], [7,8], [9,0]]"print(type(a))b = eval(a)print(b)# 输出： &lt;type 'str'&gt; [[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]] eg2:字符串转换成字典123456789a = "&#123;1: 'a', 2: 'b'&#125;"print(type(a))b = eval(a)print(type(b))print(b)# 输出： &lt;type 'str'&gt; &lt;type 'dict'&gt; &#123;1: 'a', 2: 'b'&#125; eg3：字符串转换成元组123456789a = "([1,2], [3,4], [5,6], [7,8], (9,0))"print(type(a))b=eval(a)print(type(b))print(b)# 输出： &lt;type 'str'&gt; &lt;type 'tuple'&gt; ([1, 2], [3, 4], [5, 6], [7, 8], (9, 0))]]></content>
      <categories>
        <category>python相关函数</category>
      </categories>
      <tags>
        <tag>Python eval函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux的基本配置指令01]]></title>
    <url>%2F2018%2F10%2F04%2Flinux%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A401%2F</url>
    <content type="text"><![CDATA[alias指令： 设置指令的别名 目的： 使用该指令可以对存在的指令设置一个容易记忆的别名 语法： alias 别名 = ‘复杂的指令’范例123alias p = ‘passwd’alias a = 'adduser -d /home/she-p 123456 sun' #设置别名alias #列出当前已经设置的别名 ps： 重启系统别名失效，如果想要永久生效，需要编辑文档/home/gec/.bashrc来实现该文件在root用户下。 man:显示指令的帮助信息 目的:用man指令查看shell指令和相关函数 语法:[-可选参数] 指令名 说明: ubuntu中man的手册默认没有装。用下面几条命令就行了：sudo apt-get install manpagessudo apt-get install manpages-desudo apt-get install manpages-de-devsudo apt-get install manpages-devubuntu man手册完善Linux提供了丰富的帮助手册，当你需要查看某个命令的参数时不必到处上网查找，只要man一下即可。Linux 的man手册共有以下几个章节：1、Standard commands （标准命令）2、System calls （系统调用）3、Library functions （库函数）4、Special devices （设备说明）5、File formats （文件格式）6、Games and toys （游戏和娱乐）7、Miscellaneous （杂项）8、Administrative Commands （管理员命令）范例123man --help #帮助文档man 3 open #查看open函数，3代表查看库函数man 1 ls #查看ls命令，1代表查看标准命令 ps：man -k who 后面提到，-k：显示与指定字符匹配的标题字符串的每一行 apropos：查找使用手册的名字和相关描述 目标：查找一个不知道的能完成某种特殊任务的命令名称，有时候会忘记执行特定任务的命令，就可以使用apropos找出来 语法：apropos [必要参数] [选择性参数] 关键词 参数说明：（1）必要参数 参 数 说明 -d 输出调试信息 -v 输出详细的警告信息 -r 认为每个关键词是一个通常的表达式 -w 认为每个关键词进行精确匹配 -c 对每个关键词进行精确匹配 （2）非必要参数 参 数 说明 -s 只在给定的部分进行搜索 -h 帮助信息 -V 版本信息 内建指令：whatis，man 范例12apropos -r ls#以通常的方式找关键词lsapropos who #等同于man -k who]]></content>
      <categories>
        <category>linux浅见</category>
      </categories>
      <tags>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vs 2008&2015]]></title>
    <url>%2F2018%2F07%2F28%2Fvs-2008%2F</url>
    <content type="text"><![CDATA[vs 的快捷键https://www.cnblogs.com/feichengwulai/articles/3515899.html 空格和tab键的设置 首先，先后按下两组快捷键Ctrl+R和Ctrl+W可以显示程序中的空格显示为圆点的样式，这样，在编码时，就可以知道Tab键是否为空格了。 同样，再次按下上述快捷键可以取消该显示。 将Tab键改为四个空格的方法： Tools-&gt;Options-&gt;Text Editor-&gt;C/C++-&gt;Tabs中的Tab选项由Keep tabs该为Insert Space 注释 注释：ctrl+ K + C 取消注释：ctrl +K + U 全屏显示/全屏退出 shift + alt + enter 快速切换窗口使用组合键“Ctrl+Tab”（此时可以打开IDE的导航，获得鸟瞰视 图）。 调试相关 调试启动： F5 调试重新启动：ctrl+shift+F5 调试（开始执行不调试）：ctrl+F5 ctrl+shift+f9取消所有断点 F10跨过程执行 F11单步逐句执行 窗口快捷键 ctrl+w，s 打开解决方案管理器 ctrl+w，c 类视图 ctrl+w，e 错误列表 ctrl+w，o 输出视图 f4或者ctrl+w，p 属性窗口 ctrl+w，x 工具箱 调用智能提示1）方法1：使用组合键“Ctrl+J”；2）方法2：使用组合键“Alt+→” 回到上一个光标位置/前进到下一个光标位置1）回到上一个光标位置：使用组合键“Ctrl + -”；2）前进到下一个光标位置：“Ctrl + Shift + - ”。vs2015的调试技巧 在调试过程中，打开不同的调试窗口调试-&gt;窗口-&gt;（选择要打开的窗口）]]></content>
      <categories>
        <category>vs学习</category>
      </categories>
      <tags>
        <tag>VS快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python items和itertems函数的用法]]></title>
    <url>%2F2018%2F07%2F28%2Fpython-items%E5%92%8Citertems%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字典的定义123456#第一种：创建空字典dict=&#123;&#125;#第二种：创建字典常量dict=&#123;'key1':'value1','key2':'value2'&#125;#第三种：创建字典dict=dict() 字典的赋值1234#第一种：直接赋值dict=&#123;'key1':'value1','key2':'value2'&#125;;#第二种：创建时赋值dict(key1='value1',key2='value2') items函数 函数说明：items函数，将一个字典以列表的形式返回，因为字典是无序的，所以返回的列表也是无序的。123a = &#123;'a':1,'b':3&#125;a.items()返回 ：a = [('a',1),('b',3)] iteritems函数 函数说明：该函数返回一个迭代器1234567891011a = &#123;'a':1,'b':3&#125;b = a.iteritems()list(b) = [('a',1),('b',3)]for k, v in b: print k,v 返回：a 1 b 3 注：在Python 3.x 里面，iteritems()方法已经废除了。在3.x里用 items()替换iteritems() ，可以用于 for 来循环遍历。]]></content>
      <categories>
        <category>python相关函数</category>
      </categories>
      <tags>
        <tag>python 字典的访问方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有用的学习网站]]></title>
    <url>%2F2018%2F07%2F23%2F%E6%9C%89%E7%94%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[大神的博客：http://www.yanmin99.com/linux公社 免费下载地址：http://linux.linuxidc.com/ 用户名与密码都是 www.linuxidc.com Markdown 学习网站 Markdown 介绍与入门https://blog.csdn.net/u010565454/article/details/65937558 简介 Markdownhttps://ouweiya.gitbooks.io/markdown/注：该网页刷新很慢，建议使用第一个 MaHua在线markdownhttp://mahua.jser.me/ 好用的Markdown编辑器https://www.williamlong.info/archives/4319.html Markdown : An error occurred with the Html rendering componenthttps://blog.csdn.net/gxseveryday/article/details/80031755 MarkdownPad2.5 注册码https://www.jianshu.com/p/9e5cd946696d markdown文件的基本常用编写语法（图文并茂）https://blog.csdn.net/tyyking/article/details/79682157视频学习网站 1 电子工程师在线课堂 http://www.moore8.com/courses/list/ 课业答案 1 国际交流英语视听说B2 https://wenku.baidu.com/view/4b2d7bc3f121dd36a32d8283.html 2 国际交流英语视听说B2 Further Listening参考答案 https://wenku.baidu.com/view/2d43ec5e5901020207409cf8.html?pn=51 3 《误差理论与数据处理(第6版)》费业泰-课后答案 https://wenku.baidu.com/view/372fcd1b3d1ec5da50e2524de518964bcf84d222.html 4 研究生英语读写教程（2） http://www.doc88.com/p-9863795133644.html hexo&amp;git 1 利用github+hexo搭建自己的博客 https://blog.csdn.net/u012150360/article/details/72793482 2 使用hexo+GitHub一步一步搭建属于自己的博客 https://www.cnblogs.com/fengxiongZz/p/7707219.html 2 vue-cli 安装过程中报错npm ERR! code EPERM npm ERR! errno -4048 npm ERR! syscall scandir解决 https://blog.csdn.net/u010622874/article/details/80499523 3 npm ERR! code EPERM npm ERR! errno -4048 npm ERR! syscall scandir解决方法 https://blog.csdn.net/brain_bo/article/details/80675282 4 hexo 搜索功能 https://blog.csdn.net/ganzhilin520/article/details/79047983 5 Hexo安装配置详解 https://blog.csdn.net/tonydandelion2014/article/details/61615898 6 Hexo配置文件详细说明 https://blog.csdn.net/gyq1998/article/details/78294689wox 使用说明 1 Wox - 开源免费强大的快捷启动器辅助工具，快速高效率打开软件/搜索文件！ https://blog.csdn.net/xiaotongbiji/article/details/80620228c++ 1 vs2008配置boost库 https://blog.csdn.net/qq1987924/article/details/7897503]]></content>
      <categories>
        <category>学习资料</category>
      </categories>
      <tags>
        <tag>学习网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[代码样式1234567891011//c++类的框架：class MyFristBlog&#123; public： MyFristBlog(); ~MyFristBlog(); private: int i; float j;&#125; 下载主题的命令git clone https://github.com/iissnan/hexo-theme-next themes/next 注：next是主题的名称，git clone是hexo命令，https://github.com/iissnan/hexo-theme-next是下载主题的网站，themes是下载的目录 hexo的基础配置修改全局的config.yml文件123456789101112theme:landscape 把landscap改为我们要替换的主题 如next然后进行主题更新：cd themes/nextgit pull再通过hexo cleanhexo g -d或者hexo cleanhexo g hexo d这样就将博客上传到github上了 添加about标签在博客所在目录下用： hexo new page about 这样会添加一个about文件夹，里面包含一个index.md。在这个文件内，可以编写一些about的信息。 然后，进入themes/jacman(进入你使用的主题下)打开_config.yml，在menu中添加about的链接。12345menu:首页: /归档: /archives关于: /about这样就会再页面菜单中生成一个关于about的链接了。 添加categories分类和tags标签1、新建标签 hexo new page tags hexo new page categories2、确认站点配置文件里有tag_dir: tags category_dir: categories3、确认主题配置文件里有tags: /tags categories: /categories4、编辑站点的source/tags/index.md，添加title: tagsdate: 2015-10-20 06:49:50type: “tags”comments: false5、编辑站点的source/categories/index.md，添加title: categoriesdate: 2015-10-20 06:49:50type: “categories”comments: false 注：编写tags和categories：冒号后面要有空格，格式如下：123456title: javascript深入理解(一)js类型知多少date: 2018-07-17 14:18:12tags: - javascriptcategories: - javascript深入理解 创建新博客1$ hexo new "My New Post"]]></content>
      <categories>
        <category>初识hexo</category>
      </categories>
      <tags>
        <tag>初识hexo</tag>
      </tags>
  </entry>
</search>
